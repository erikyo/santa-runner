/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 185:
/***/ (() => {

(function(){function l(a,b,c){return Function.prototype.call.apply(Array.prototype.slice,arguments)}function m(a,b,c){var e=l(arguments,2);return function(){return b.apply(a,e)}}function n(a,b){var c=new p(b);for(c.h=[a];c.h.length;){var e=c,d=c.h.shift();e.i(d);for(d=d.firstChild;d;d=d.nextSibling)1==d.nodeType&&e.h.push(d)}}function p(a){this.i=a}function q(a){a.style.display=""}function r(a){a.style.display="none"};var t=/\s*;\s*/;function u(a,b){this.l.apply(this,arguments)}u.prototype.l=function(a,b){this.a||(this.a={});if(b){var c=this.a,e=b.a;for(d in e)c[d]=e[d]}else{var d=this.a;e=v;for(c in e)d[c]=e[c]}this.a.$this=a;this.a.$context=this;this.f="undefined"!=typeof a&&null!=a?a:"";b||(this.a.$top=this.f)};var v={$default:null},w=[];function x(a){for(var b in a.a)delete a.a[b];a.f=null;w.push(a)}function y(a,b,c){try{return b.call(c,a.a,a.f)}catch(e){return v.$default}}
  u.prototype.clone=function(a,b,c){if(0<w.length){var e=w.pop();u.call(e,a,this);a=e}else a=new u(a,this);a.a.$index=b;a.a.$count=c;return a};var z;window.trustedTypes&&(z=trustedTypes.createPolicy("jstemplate",{createScript:function(a){return a}}));var A={};function B(a){if(!A[a])try{var b="(function(a_, b_) { with (a_) with (b_) return "+a+" })",c=window.trustedTypes?z.createScript(b):b;A[a]=window.eval(c)}catch(e){}return A[a]}
  function E(a){var b=[];a=a.split(t);for(var c=0,e=a.length;c<e;++c){var d=a[c].indexOf(":");if(!(0>d)){var g=a[c].substr(0,d).replace(/^\s+/,"").replace(/\s+$/,"");d=B(a[c].substr(d+1));b.push(g,d)}}return b};function F(){}var G=0,H={0:{}},I={},J={},K=[];function L(a){a.__jstcache||n(a,function(b){M(b)})}var N=[["jsselect",B],["jsdisplay",B],["jsvalues",E],["jsvars",E],["jseval",function(a){var b=[];a=a.split(t);for(var c=0,e=a.length;c<e;++c)if(a[c]){var d=B(a[c]);b.push(d)}return b}],["transclude",function(a){return a}],["jscontent",B],["jsskip",B]];
  function M(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(null!=b)return a.__jstcache=H[b];b=K.length=0;for(var c=N.length;b<c;++b){var e=N[b][0],d=a.getAttribute(e);J[e]=d;null!=d&&K.push(e+"="+d)}if(0==K.length)return a.setAttribute("jstcache","0"),a.__jstcache=H[0];var g=K.join("&");if(b=I[g])return a.setAttribute("jstcache",b),a.__jstcache=H[b];var h={};b=0;for(c=N.length;b<c;++b){d=N[b];e=d[0];var f=d[1];d=J[e];null!=d&&(h[e]=f(d))}b=""+ ++G;a.setAttribute("jstcache",
    b);H[b]=h;I[g]=b;return a.__jstcache=h}function P(a,b){a.j.push(b);a.o.push(0)}function Q(a){return a.c.length?a.c.pop():[]}
  F.prototype.g=function(a,b){var c=R(b),e=c.transclude;if(e)(c=S(e))?(b.parentNode.replaceChild(c,b),e=Q(this),e.push(this.g,a,c),P(this,e)):b.parentNode.removeChild(b);else if(c=c.jsselect){c=y(a,c,b);var d=b.getAttribute("jsinstance");var g=!1;d&&("*"==d.charAt(0)?(d=parseInt(d.substr(1),10),g=!0):d=parseInt(d,10));var h=null!=c&&"object"==typeof c&&"number"==typeof c.length;e=h?c.length:1;var f=h&&0==e;if(h)if(f)d?b.parentNode.removeChild(b):(b.setAttribute("jsinstance","*0"),r(b));else if(q(b),
  null===d||""===d||g&&d<e-1){g=Q(this);d=d||0;for(h=e-1;d<h;++d){var k=b.cloneNode(!0);b.parentNode.insertBefore(k,b);T(k,c,d);f=a.clone(c[d],d,e);g.push(this.b,f,k,x,f,null)}T(b,c,d);f=a.clone(c[d],d,e);g.push(this.b,f,b,x,f,null);P(this,g)}else d<e?(g=c[d],T(b,c,d),f=a.clone(g,d,e),g=Q(this),g.push(this.b,f,b,x,f,null),P(this,g)):b.parentNode.removeChild(b);else null==c?r(b):(q(b),f=a.clone(c,0,1),g=Q(this),g.push(this.b,f,b,x,f,null),P(this,g))}else this.b(a,b)};
  F.prototype.b=function(a,b){var c=R(b),e=c.jsdisplay;if(e){if(!y(a,e,b)){r(b);return}q(b)}if(e=c.jsvars)for(var d=0,g=e.length;d<g;d+=2){var h=e[d],f=y(a,e[d+1],b);a.a[h]=f}if(e=c.jsvalues)for(d=0,g=e.length;d<g;d+=2)if(f=e[d],h=y(a,e[d+1],b),"$"==f.charAt(0))a.a[f]=h;else if("."==f.charAt(0)){f=f.substr(1).split(".");for(var k=b,O=f.length,C=0,U=O-1;C<U;++C){var D=f[C];k[D]||(k[D]={});k=k[D]}k[f[O-1]]=h}else f&&("boolean"==typeof h?h?b.setAttribute(f,f):b.removeAttribute(f):b.setAttribute(f,""+h));
    if(e=c.jseval)for(d=0,g=e.length;d<g;++d)y(a,e[d],b);e=c.jsskip;if(!e||!y(a,e,b))if(c=c.jscontent){if(c=""+y(a,c,b),b.innerHTML!=c){for(;b.firstChild;)e=b.firstChild,e.parentNode.removeChild(e);b.appendChild(this.m.createTextNode(c))}}else{c=Q(this);for(e=b.firstChild;e;e=e.nextSibling)1==e.nodeType&&c.push(this.g,a,e);c.length&&P(this,c)}};function R(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");return b?a.__jstcache=H[b]:M(a)}
  function S(a,b){var c=document;if(b){var e=c.getElementById(a);if(!e){e=b();var d=c.getElementById("jsts");d||(d=c.createElement("div"),d.id="jsts",r(d),d.style.position="absolute",c.body.appendChild(d));var g=c.createElement("div");d.appendChild(g);g.innerHTML=e;e=c.getElementById(a)}c=e}else c=c.getElementById(a);return c?(L(c),c=c.cloneNode(!0),c.removeAttribute("id"),c):null}function T(a,b,c){c==b.length-1?a.setAttribute("jsinstance","*"+c):a.setAttribute("jsinstance",""+c)};window.jstGetTemplate=S;window.JsEvalContext=u;window.jstProcess=function(a,b){var c=new F;L(b);c.m=b?9==b.nodeType?b:b.ownerDocument||document:document;var e=m(c,c.g,a,b),d=c.j=[],g=c.o=[];c.c=[];e();for(var h,f,k;d.length;)h=d[d.length-1],e=g[g.length-1],e>=h.length?(e=c,f=d.pop(),f.length=0,e.c.push(f),g.pop()):(f=h[e++],k=h[e++],h=h[e++],g[g.length-1]=e,f.call(c,k,h))};
})()


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

;// CONCATENATED MODULE: ./src/images/default_100_percent/offline/100-offline-sprite.png
const _100_offline_sprite_namespaceObject = "data:image/png;base64,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";
;// CONCATENATED MODULE: ./src/images/default_200_percent/offline/200-offline-sprite.png
const _200_offline_sprite_namespaceObject = "data:image/png;base64,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";
;// CONCATENATED MODULE: ./src/sounds/button-press.mp3
const button_press_namespaceObject = "data:audio/mpeg;base64,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";
;// CONCATENATED MODULE: ./src/sounds/hit.mp3
const hit_namespaceObject = "data:audio/mpeg;base64,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";
;// CONCATENATED MODULE: ./src/sounds/score-reached.mp3
const score_reached_namespaceObject = "data:audio/mpeg;base64,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";
// EXTERNAL MODULE: ./src/scripts/jstemplate_compiled.js
var jstemplate_compiled = __webpack_require__(185);
;// CONCATENATED MODULE: ./src/scripts/load_time_data_deprecated.js
// Copyright 2012 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview
 * NOTE: This file is deprecated, and provides only the minimal LoadTimeData
 * functions for places in the code still not using JS modules. Use
 * load_time_data.ts in all new code.
 *
 * This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 *
 * Note that loadTimeData is not guaranteed to be consistent between page
 * refreshes (https://crbug.com/740629) and should not contain values that might
 * change if the page is re-opened later.
 */

/** @type {!LoadTimeData} */
// eslint-disable-next-line no-var
let load_time_data_deprecated_loadTimeData

class LoadTimeData {
  constructor () {
    /** @type {?Object} */
    this.data_ = null
  }

  /**
   * Sets the backing object.
   *
   * Note that there is no getter for |data_| to discourage abuse of the form:
   *
   *     var value = loadTimeData.data()['key'];
   *
   * @param {Object} value The de-serialized page data.
   */
  set data (value) {
    expect(!this.data_, 'Re-setting data.')
    this.data_ = value
  }

  get data () {
    return this.data_
  }

  /**
   * @param {string} id An ID of a value that might exist.
   * @return {boolean} True if |id| is a key in the dictionary.
   */
  valueExists (id) {
    return id in this.data_
  }

  /**
   * Fetches a value, expecting that it exists.
   * @param {string} id The key that identifies the desired value.
   * @return {*} The corresponding value.
   */
  getValue (id) {
    expect(this.data_, 'No data. Did you remember to include strings.js?')
    const value = this.data_[id]
    expect(typeof value !== 'undefined', 'Could not find value for ' + id)
    return value
  }

  /**
   * As above, but also makes sure that the value is a string.
   * @param {string} id The key that identifies the desired string.
   * @return {string} The corresponding string value.
   */
  getString (id) {
    const value = this.getValue(id)
    expectIsType(id, value, 'string')
    return /** @type {string} */ (value)
  }

  /**
   * Returns a formatted localized string where $1 to $9 are replaced by the
   * second to the tenth argument.
   * @param {string} id The ID of the string we want.
   * @param {...(string|number)} varArgs The extra values to include in the
   *     formatted output.
   * @return {string} The formatted string.
   */
  getStringF (id, varArgs) {
    const value = this.getString(id)
    if (!value) {
      return ''
    }

    const args = Array.prototype.slice.call(arguments)
    args[0] = value
    return this.substituteString.apply(this, args)
  }

  /**
   * Returns a formatted localized string where $1 to $9 are replaced by the
   * second to the tenth argument. Any standalone $ signs must be escaped as
   * $$.
   * @param {string} label The label to substitute through.
   *     This is not an resource ID.
   * @param {...(string|number)} varArgs The extra values to include in the
   *     formatted output.
   * @return {string} The formatted string.
   */
  substituteString (label, varArgs) {
    return label.replace(/\$(.|$|\n)/g, function (m) {
      expect(m.match(/\$[$1-9]/), 'Unescaped $ found in localized string.')
      return m === '$$' ? '$' : varArgs[m[1]]
    })
  }

  /**
   * As above, but also makes sure that the value is a boolean.
   * @param {string} id The key that identifies the desired boolean.
   * @return {boolean} The corresponding boolean value.
   */
  getBoolean (id) {
    const value = this.getValue(id)
    expectIsType(id, value, 'boolean')
    return /** @type {boolean} */ (value)
  }

  /**
   * As above, but also makes sure that the value is an integer.
   * @param {string} id The key that identifies the desired number.
   * @return {number} The corresponding number value.
   */
  getInteger (id) {
    const value = this.getValue(id)
    expectIsType(id, value, 'number')
    expect(value === Math.floor(value), 'Number isn\'t integer: ' + value)
    return /** @type {number} */ (value)
  }

  /**
   * Override values in loadTimeData with the values found in |replacements|.
   * @param {Object} replacements The dictionary object of keys to replace.
   */
  overrideValues (replacements) {
    expect(
      typeof replacements === 'object',
      'Replacements must be a dictionary object.')
    for (const key in replacements) {
      this.data_[key] = replacements[key]
    }
  }
}

/**
 * Checks condition, throws error message if expectation fails.
 * @param {*} condition The condition to check for truthiness.
 * @param {string} message The message to display if the check fails.
 */
function expect (condition, message) {
  if (!condition) {
    throw new Error(
      'Unexpected condition on ' + document.location.href + ': ' + message)
  }
}

/**
 * Checks that the given value has the given type.
 * @param {string} id The id of the value (only used for error message).
 * @param {*} value The value to check the type on.
 * @param {string} type The type we expect |value| to be.
 */
function expectIsType (id, value, type) {
  expect(
    // eslint-disable-next-line valid-typeof
    typeof value === type, '[' + value + '] (' + id + ') is not a ' + type)
}
expect(!load_time_data_deprecated_loadTimeData, 'should only include this file once')

load_time_data_deprecated_loadTimeData = new LoadTimeData()

load_time_data_deprecated_loadTimeData.data = {
  dinoGameA11yAriaLabel: 'Dino game, play',
  dinoGameA11yDescription: 'Dino game. A pixelated dinosaur dodges cacti and pterodactyls as it runs across a desolate landscape. When you hear an audio cue, press space to jump over obstacles.',
  dinoGameA11yGameOver: 'Game over, your score is $1.',
  dinoGameA11yHighScore: 'Your highest score is $1.',
  dinoGameA11yJump: 'Jump!',
  dinoGameA11ySpeedToggle: 'Start slower',
  dinoGameA11yStartGame: 'Game started.',
  errorCode: '',
  fontfamily: "'Segoe UI', Tahoma, sans-serif",
  fontsize: '75%',
  heading: { hostName: 'dino', msg: 'Press space to play' },
  iconClass: 'icon-offline',
  language: 'en',
  textdirection: 'ltr',
  title: 'chrome://dino/'
}
// Expose |loadTimeData| directly on |window|, since within a JS module the
// scope is local and not all files have been updated to import the exported
// |loadTimeData| explicitly.
window.loadTimeData = load_time_data_deprecated_loadTimeData

;// CONCATENATED MODULE: ./src/scripts/offline.js



// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * T-Rex runner.
 * @param {string} outerContainerId Outer containing element id.
 * @param {!Object=} optConfig
 * @constructor
 * @implements {EventListener}
 * @export
 */
function Runner (outerContainerId, optConfig) {
  // Singleton
  if (Runner.instance_) {
    return Runner.instance_
  }
  Runner.instance_ = this
  Runner.spriteDefinitionByType = spriteDefinitionByType

  this.outerContainerEl = document.querySelector(outerContainerId)
  this.containerEl = null
  this.snackbarEl = null
  // A div to intercept touch events. Only set while (playing && useTouch).
  this.touchController = null

  this.config = optConfig || Object.assign(Runner.config, Runner.normalConfig)
  // Logical dimensions of the container.
  this.dimensions = Runner.defaultDimensions

  this.gameType = null
  Runner.spriteDefinition = Runner.spriteDefinitionByType.original

  this.altGameImageSprite = null
  this.altGameModeActive = false
  this.altGameModeFlashTimer = null
  this.fadeInTimer = 0

  this.canvas = null
  this.canvasCtx = null

  this.tRex = null

  this.distanceMeter = null
  this.distanceRan = 0

  this.highestScore = 0
  this.syncHighestScore = false

  this.time = 0
  this.runningTime = 0
  this.msPerFrame = 1000 / FPS
  this.currentSpeed = this.config.SPEED
  Runner.slowDown = false

  this.obstacles = []

  this.activated = false // Whether the easter egg has been activated.
  this.playing = false // Whether the game is currently in play state.
  this.crashed = false
  this.paused = false
  this.inverted = false
  this.invertTimer = 0
  this.resizeTimerId_ = null

  this.playCount = 0

  // Sound FX.
  this.audioBuffer = null

  /** @type {Object} */
  this.soundFx = {}
  this.generatedSoundFx = null

  // Global web audio context for playing sounds.
  this.audioContext = null

  // Images.
  this.images = {}
  this.imagesLoaded = 0

  // Gamepad state.
  this.pollingGamepads = false
  this.gamepadIndex = undefined
  this.previousGamepad = null

  if (this.isDisabled()) {
    this.setupDisabledRunner()
  } else {
    if (Runner.isAltGameModeEnabled()) {
      this.initAltGameType()
      Runner.gameType = this.gameType
    }
    this.loadImages()

    this.initializeEasterEggHighScore = this.initializeHighScore.bind(this)
  }
}

/**
 * Default game width.
 * @const
 */
const DEFAULT_WIDTH = 600

/**
 * Frames per second.
 * @const
 */
const FPS = 60

/** @const */
const IS_HIDPI = window.devicePixelRatio > 1

/** @const */
const IS_IOS = /CriOS/.test(window.navigator.userAgent)

/** @const */
const IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS

/** @const */
const IS_RTL = document.querySelector('html').dir === 'rtl'

/** @const */
const ARCADE_MODE_URL = 'chrome://dino/'

/** @const */
const RESOURCE_POSTFIX = 'offline-resources-'

/** @const */
const A11Y_STRINGS = {
  ariaLabel: 'dinoGameA11yAriaLabel',
  description: 'dinoGameA11yDescription',
  gameOver: 'dinoGameA11yGameOver',
  highScore: 'dinoGameA11yHighScore',
  jump: 'dinoGameA11yJump',
  started: 'dinoGameA11yStartGame',
  speedLabel: 'dinoGameA11ySpeedToggle'
}

/**
 * Default game configuration.
 * Shared config for all  versions of the game. Additional parameters are
 * defined in Runner.normalConfig and Runner.slowConfig.
 */
Runner.config = {
  AUDIOCUE_PROXIMITY_THRESHOLD: 190,
  AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 250,
  BG_CLOUD_SPEED: 0.2,
  BOTTOM_PAD: 10,
  // Scroll Y threshold at which the game can be activated.
  CANVAS_IN_VIEW_OFFSET: -10,
  CLEAR_TIME: 3000,
  CLOUD_FREQUENCY: 0.5,
  FADE_DURATION: 1,
  FLASH_DURATION: 1000,
  GAMEOVER_CLEAR_TIME: 1200,
  INITIAL_JUMP_VELOCITY: 12,
  INVERT_FADE_DURATION: 12000,
  MAX_BLINK_COUNT: 3,
  MAX_CLOUDS: 6,
  MAX_OBSTACLE_LENGTH: 3,
  MAX_OBSTACLE_DUPLICATION: 2,
  RESOURCE_TEMPLATE_ID: 'audio-resources',
  SPEED: 6,
  SPEED_DROP_COEFFICIENT: 3,
  ARCADE_MODE_INITIAL_TOP_POSITION: 35,
  ARCADE_MODE_TOP_POSITION_PERCENT: 0.1
}

Runner.normalConfig = {
  ACCELERATION: 0.001,
  AUDIOCUE_PROXIMITY_THRESHOLD: 190,
  AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 250,
  GAP_COEFFICIENT: 0.6,
  INVERT_DISTANCE: 700,
  MAX_SPEED: 13,
  MOBILE_SPEED_COEFFICIENT: 1.2,
  SPEED: 6
}

Runner.slowConfig = {
  ACCELERATION: 0.0005,
  AUDIOCUE_PROXIMITY_THRESHOLD: 170,
  AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 220,
  GAP_COEFFICIENT: 0.3,
  INVERT_DISTANCE: 350,
  MAX_SPEED: 9,
  MOBILE_SPEED_COEFFICIENT: 1.5,
  SPEED: 4.2
}

/**
 * Default dimensions.
 */
Runner.defaultDimensions = {
  WIDTH: DEFAULT_WIDTH,
  HEIGHT: 150
}

/**
 * CSS class names.
 * @enum {string}
 */
Runner.classes = {
  ARCADE_MODE: 'arcade-mode',
  CANVAS: 'runner-canvas',
  CONTAINER: 'runner-container',
  CRASHED: 'crashed',
  ICON: 'icon-offline',
  INVERTED: 'inverted',
  SNACKBAR: 'snackbar',
  SNACKBAR_SHOW: 'snackbar-show',
  TOUCH_CONTROLLER: 'controller'
}

/**
 * Sound FX. Reference to the ID of the audio tag on interstitial page.
 * @enum {string}
 */
Runner.sounds = {
  BUTTON_PRESS: 'offline-sound-press',
  HIT: 'offline-sound-hit',
  SCORE: 'offline-sound-reached'
}

/**
 * Key code mapping.
 * @enum {Object}
 */
Runner.keycodes = {
  JUMP: { 38: 1, 32: 1 }, // Up, spacebar
  DUCK: { 40: 1 }, // Down
  RESTART: { 13: 1 } // Enter
}

/**
 * Runner event names.
 * @enum {string}
 */
Runner.events = {
  ANIM_END: 'webkitAnimationEnd',
  CLICK: 'click',
  KEYDOWN: 'keydown',
  KEYUP: 'keyup',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  RESIZE: 'resize',
  TOUCHEND: 'touchend',
  TOUCHSTART: 'touchstart',
  VISIBILITY: 'visibilitychange',
  BLUR: 'blur',
  FOCUS: 'focus',
  LOAD: 'load',
  GAMEPADCONNECTED: 'gamepadconnected'
}

Runner.prototype = {
  /**
   * Initialize alternative game type.
   */
  initAltGameType () {
    if (GAME_TYPE.length > 0) {
      this.gameType = load_time_data_deprecated_loadTimeData && load_time_data_deprecated_loadTimeData.valueExists('altGameType')
        ? GAME_TYPE[parseInt(load_time_data_deprecated_loadTimeData.getValue('altGameType'), 10) - 1]
        : ''
    }
  },

  /**
   * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.
   * @return {boolean}
   */
  isDisabled () {
    return load_time_data_deprecated_loadTimeData && load_time_data_deprecated_loadTimeData.valueExists('disabledEasterEgg')
  },

  /**
   * For disabled instances, set up a snackbar with the disabled message.
   */
  setupDisabledRunner () {
    this.containerEl = document.createElement('div')
    this.containerEl.className = Runner.classes.SNACKBAR
    this.containerEl.textContent = load_time_data_deprecated_loadTimeData.getValue('disabledEasterEgg')
    this.outerContainerEl.appendChild(this.containerEl)

    // Show notification when the activation key is pressed.
    document.addEventListener(Runner.events.KEYDOWN, function (e) {
      if (Runner.keycodes.JUMP[e.keyCode]) {
        this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW)
        document.querySelector('.icon').classList.add('icon-disabled')
      }
    }.bind(this))
  },

  /**
   * Setting individual settings for debugging.
   * @param {string} setting
   * @param {number|string} value
   */
  updateConfigSetting (setting, value) {
    if (setting in this.config && value !== undefined) {
      this.config[setting] = value

      switch (setting) {
        case 'GRAVITY':
        case 'MIN_JUMP_HEIGHT':
        case 'SPEED_DROP_COEFFICIENT':
          this.tRex.config[setting] = value
          break
        case 'INITIAL_JUMP_VELOCITY':
          this.tRex.setJumpVelocity(value)
          break
        case 'SPEED':
          this.setSpeed(/** @type {number} */ (value))
          break
      }
    }
  },

  /**
   * Creates an on page image element from the base 64 encoded string source.
   * @param {string} resourceName Name in data object,
   * @return {HTMLImageElement} The created element.
   */
  createImageElement (resourceName) {
    const imgSrc = load_time_data_deprecated_loadTimeData && load_time_data_deprecated_loadTimeData.valueExists(resourceName)
      ? load_time_data_deprecated_loadTimeData.getString(resourceName)
      : null

    if (imgSrc) {
      const el =
        /** @type {HTMLImageElement} */ (document.createElement('img'))
      el.id = resourceName
      el.src = imgSrc
      document.getElementById('offline-resources').appendChild(el)
      return el
    }
    return null
  },

  /**
   * Cache the appropriate image sprite from the page and get the sprite sheet
   * definition.
   */
  loadImages () {
    let scale = '1x'
    this.spriteDef = Runner.spriteDefinition.LDPI
    if (IS_HIDPI) {
      scale = '2x'
      this.spriteDef = Runner.spriteDefinition.HDPI
    }

    Runner.imageSprite = /** @type {HTMLImageElement} */
      (document.getElementById(RESOURCE_POSTFIX + scale))

    if (this.gameType) {
      Runner.altGameImageSprite = /** @type {HTMLImageElement} */
        (this.createImageElement('altGameSpecificImage' + scale))
      Runner.altCommonImageSprite = /** @type {HTMLImageElement} */
        (this.createImageElement('altGameCommonImage' + scale))
    }
    Runner.origImageSprite = Runner.imageSprite

    // Disable the alt game mode if the sprites can't be loaded.
    if (!Runner.altGameImageSprite || !Runner.altCommonImageSprite) {
      Runner.isAltGameModeEnabled = () => false
      this.altGameModeActive = false
    }

    if (Runner.imageSprite.complete) {
      this.init()
    } else {
      // If the images are not yet loaded, add a listener.
      Runner.imageSprite.addEventListener(Runner.events.LOAD,
        this.init.bind(this))
    }
  },

  /**
   * Load and decode base 64 encoded sounds.
   */
  loadSounds () {
    if (!IS_IOS) {
      this.audioContext = new AudioContext()

      const resourceTemplate =
        document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content

      for (const sound in Runner.sounds) {
        let soundSrc =
          resourceTemplate.getElementById(Runner.sounds[sound]).src
        soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1)
        const buffer = decodeBase64ToArrayBuffer(soundSrc)

        // Async, so no guarantee of order in array.
        this.audioContext.decodeAudioData(buffer, function (index, audioData) {
          this.soundFx[index] = audioData
        }.bind(this, sound))
      }
    }
  },

  /**
   * Sets the game speed. Adjust the speed accordingly if on a smaller screen.
   * @param {number=} optSpeed
   */
  setSpeed (optSpeed) {
    const speed = optSpeed || this.currentSpeed

    // Reduce the speed on smaller mobile screens.
    if (this.dimensions.WIDTH < DEFAULT_WIDTH) {
      const mobileSpeed = Runner.slowDown
        ? speed
        : speed * this.dimensions.WIDTH /
        DEFAULT_WIDTH * this.config.MOBILE_SPEED_COEFFICIENT
      this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed
    } else if (optSpeed) {
      this.currentSpeed = optSpeed
    }
  },

  /**
   * Game initialiser.
   */
  init () {
    // Hide the static icon.
    document.querySelector('.' + Runner.classes.ICON).style.visibility =
      'hidden'

    this.adjustDimensions()
    this.setSpeed()

    const ariaLabel = getA11yString(A11Y_STRINGS.ariaLabel)
    this.containerEl = document.createElement('div')
    this.containerEl.setAttribute('role', IS_MOBILE ? 'button' : 'application')
    this.containerEl.setAttribute('tabindex', '0')
    this.containerEl.setAttribute('title', ariaLabel)

    this.containerEl.className = Runner.classes.CONTAINER

    // Player canvas container.
    this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,
      this.dimensions.HEIGHT)

    // Live region for game status updates.
    this.a11yStatusEl = document.createElement('span')
    this.a11yStatusEl.className = 'offline-runner-live-region'
    this.a11yStatusEl.setAttribute('aria-live', 'assertive')
    this.a11yStatusEl.textContent = ''
    Runner.a11yStatusEl = this.a11yStatusEl

    // Add checkbox to slow down the game.
    this.slowSpeedCheckboxLabel = document.createElement('label')
    this.slowSpeedCheckboxLabel.className = 'slow-speed-option hidden'
    this.slowSpeedCheckboxLabel.textContent =
      getA11yString(A11Y_STRINGS.speedLabel)

    this.slowSpeedCheckbox = document.createElement('input')
    this.slowSpeedCheckbox.setAttribute('type', 'checkbox')
    this.slowSpeedCheckbox.setAttribute(
      'title', getA11yString(A11Y_STRINGS.speedLabel))
    this.slowSpeedCheckbox.setAttribute('tabindex', '0')
    this.slowSpeedCheckbox.setAttribute('checked', 'checked')

    this.slowSpeedToggleEl = document.createElement('span')
    this.slowSpeedToggleEl.className = 'slow-speed-toggle'

    this.slowSpeedCheckboxLabel.appendChild(this.slowSpeedCheckbox)
    this.slowSpeedCheckboxLabel.appendChild(this.slowSpeedToggleEl)

    if (IS_IOS) {
      this.outerContainerEl.appendChild(this.a11yStatusEl)
    } else {
      this.containerEl.appendChild(this.a11yStatusEl)
    }

    announcePhrase(getA11yString(A11Y_STRINGS.description))

    this.generatedSoundFx = new GeneratedSoundFx()

    this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'))
    this.canvasCtx.fillStyle = '#f7f7f7'
    this.canvasCtx.fill()
    Runner.updateCanvasScaling(this.canvas)

    // Horizon contains clouds, obstacles and the ground.
    this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,
      this.config.GAP_COEFFICIENT)

    // Distance meter
    this.distanceMeter = new DistanceMeter(this.canvas,
      this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH)

    // Draw t-rex
    this.tRex = new Trex(this.canvas, this.spriteDef.TREX)

    this.outerContainerEl.appendChild(this.containerEl)
    this.outerContainerEl.appendChild(this.slowSpeedCheckboxLabel)

    this.startListening()
    this.update()

    window.addEventListener(Runner.events.RESIZE,
      this.debounceResize.bind(this))

    // Handle dark mode
    const darkModeMediaQuery =
      window.matchMedia('(prefers-color-scheme: dark)')
    this.isDarkMode = darkModeMediaQuery && darkModeMediaQuery.matches
    darkModeMediaQuery.addListener((e) => {
      this.isDarkMode = e.matches
    })
  },

  /**
   * Create the touch controller. A div that covers whole screen.
   */
  createTouchController () {
    this.touchController = document.createElement('div')
    this.touchController.className = Runner.classes.TOUCH_CONTROLLER
    this.touchController.addEventListener(Runner.events.TOUCHSTART, this)
    this.touchController.addEventListener(Runner.events.TOUCHEND, this)
    this.outerContainerEl.appendChild(this.touchController)
  },

  /**
   * Debounce the resize event.
   */
  debounceResize () {
    if (!this.resizeTimerId_) {
      this.resizeTimerId_ =
        setInterval(this.adjustDimensions.bind(this), 250)
    }
  },

  /**
   * Adjust game space dimensions on resize.
   */
  adjustDimensions () {
    clearInterval(this.resizeTimerId_)
    this.resizeTimerId_ = null

    const boxStyles = window.getComputedStyle(this.outerContainerEl)
    const padding = Number(boxStyles.paddingLeft.substr(0,
      boxStyles.paddingLeft.length - 2))

    this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2
    if (this.isArcadeMode()) {
      this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH)
      if (this.activated) {
        this.setArcadeModeContainerScale()
      }
    }

    // Redraw the elements back onto the canvas.
    if (this.canvas) {
      this.canvas.width = this.dimensions.WIDTH
      this.canvas.height = this.dimensions.HEIGHT

      Runner.updateCanvasScaling(this.canvas)

      this.distanceMeter.calcXPos(this.dimensions.WIDTH)
      this.clearCanvas()
      this.horizon.update(0, 0, true)
      this.tRex.update(0)

      // Outer container and distance meter.
      if (this.playing || this.crashed || this.paused) {
        this.containerEl.style.width = this.dimensions.WIDTH + 'px'
        this.containerEl.style.height = this.dimensions.HEIGHT + 'px'
        this.distanceMeter.update(0, Math.ceil(this.distanceRan))
        this.stop()
      } else {
        this.tRex.draw(0, 0)
      }

      // Game over panel.
      if (this.crashed && this.gameOverPanel) {
        this.gameOverPanel.updateDimensions(this.dimensions.WIDTH)
        this.gameOverPanel.draw(this.altGameModeActive, this.tRex)
      }
    }
  },

  /**
   * Play the game intro.
   * Canvas container width expands out to the full width.
   */
  playIntro () {
    if (!this.activated && !this.crashed) {
      this.playingIntro = true
      this.tRex.playingIntro = true

      // CSS animation definition.
      const keyframes = '@-webkit-keyframes intro { ' +
        'from { width:' + Trex.config.WIDTH + 'px }' +
        'to { width: ' + this.dimensions.WIDTH + 'px }' +
        '}'
      document.styleSheets[0].insertRule(keyframes, 0)

      this.containerEl.addEventListener(Runner.events.ANIM_END,
        this.startGame.bind(this))

      this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both'
      this.containerEl.style.width = this.dimensions.WIDTH + 'px'

      this.setPlayStatus(true)
      this.activated = true
    } else if (this.crashed) {
      this.restart()
    }
  },

  /**
   * Update the game status to started.
   */
  startGame () {
    if (this.isArcadeMode()) {
      this.setArcadeMode()
    }
    this.toggleSpeed()
    this.runningTime = 0
    this.playingIntro = false
    this.tRex.playingIntro = false
    this.containerEl.style.webkitAnimation = ''
    this.playCount++
    this.generatedSoundFx.background()
    announcePhrase(getA11yString(A11Y_STRINGS.started))

    if (Runner.audioCues) {
      this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump))
    }

    // Handle tabbing off the page. Pause the current game.
    document.addEventListener(Runner.events.VISIBILITY,
      this.onVisibilityChange.bind(this))

    window.addEventListener(Runner.events.BLUR,
      this.onVisibilityChange.bind(this))

    window.addEventListener(Runner.events.FOCUS,
      this.onVisibilityChange.bind(this))
  },

  clearCanvas () {
    this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,
      this.dimensions.HEIGHT)
  },

  /**
   * Checks whether the canvas area is in the viewport of the browser
   * through the current scroll position.
   * @return boolean.
   */
  isCanvasInView () {
    return this.containerEl.getBoundingClientRect().top >
      Runner.config.CANVAS_IN_VIEW_OFFSET
  },

  /**
   * Enable the alt game mode. Switching out the sprites.
   */
  enableAltGameMode () {
    Runner.imageSprite = Runner.altGameImageSprite
    Runner.spriteDefinition = Runner.spriteDefinitionByType[Runner.gameType]

    if (IS_HIDPI) {
      this.spriteDef = Runner.spriteDefinition.HDPI
    } else {
      this.spriteDef = Runner.spriteDefinition.LDPI
    }

    this.altGameModeActive = true
    this.tRex.enableAltGameMode(this.spriteDef.TREX)
    this.horizon.enableAltGameMode(this.spriteDef)
    this.generatedSoundFx.background()
  },

  /**
   * Update the game frame and schedules the next one.
   */
  update () {
    this.updatePending = false

    const now = getTimeStamp()
    let deltaTime = now - (this.time || now)

    // Flashing when switching game modes.
    if (this.altGameModeFlashTimer < 0 || this.altGameModeFlashTimer === 0) {
      this.altGameModeFlashTimer = null
      this.tRex.setFlashing(false)
      this.enableAltGameMode()
    } else if (this.altGameModeFlashTimer > 0) {
      this.altGameModeFlashTimer -= deltaTime
      this.tRex.update(deltaTime)
      deltaTime = 0
    }

    this.time = now

    if (this.playing) {
      this.clearCanvas()

      // Additional fade in - Prevents jump when switching sprites
      if (this.altGameModeActive &&
        this.fadeInTimer <= this.config.FADE_DURATION) {
        this.fadeInTimer += deltaTime / 1000
        this.canvasCtx.globalAlpha = this.fadeInTimer
      } else {
        this.canvasCtx.globalAlpha = 1
      }

      if (this.tRex.jumping) {
        this.tRex.updateJump(deltaTime)
      }

      this.runningTime += deltaTime
      const hasObstacles = this.runningTime > this.config.CLEAR_TIME

      // First jump triggers the intro.
      if (this.tRex.jumpCount === 1 && !this.playingIntro) {
        this.playIntro()
      }

      // The horizon doesn't move until the intro is over.
      if (this.playingIntro) {
        this.horizon.update(0, this.currentSpeed, hasObstacles)
      } else if (!this.crashed) {
        const showNightMode = this.isDarkMode ^ this.inverted
        deltaTime = !this.activated ? 0 : deltaTime
        this.horizon.update(
          deltaTime, this.currentSpeed, hasObstacles, showNightMode)
      }

      // Check for collisions.
      let collision = hasObstacles &&
        checkForCollision(this.horizon.obstacles[0], this.tRex)

      // For a11y, audio cues.
      if (Runner.audioCues && hasObstacles) {
        const jumpObstacle =
          this.horizon.obstacles[0].typeConfig.type !== 'COLLECTABLE'

        if (!this.horizon.obstacles[0].jumpAlerted) {
          const threshold = Runner.isMobileMouseInput
            ? Runner.config.AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y
            : Runner.config.AUDIOCUE_PROXIMITY_THRESHOLD
          const adjProximityThreshold = threshold +
            (threshold * Math.log10(this.currentSpeed / Runner.config.SPEED))

          if (this.horizon.obstacles[0].xPos < adjProximityThreshold) {
            if (jumpObstacle) {
              this.generatedSoundFx.jump()
            }
            this.horizon.obstacles[0].jumpAlerted = true
          }
        }
      }

      // Activated alt game mode.
      if (Runner.isAltGameModeEnabled() && collision &&
        this.horizon.obstacles[0].typeConfig.type === 'COLLECTABLE') {
        this.horizon.removeFirstObstacle()
        this.tRex.setFlashing(true)
        collision = false
        this.altGameModeFlashTimer = this.config.FLASH_DURATION
        this.runningTime = 0
        this.generatedSoundFx.collect()
      }

      if (!collision) {
        this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame

        if (this.currentSpeed < this.config.MAX_SPEED) {
          this.currentSpeed += this.config.ACCELERATION
        }
      } else {
        this.gameOver()
      }

      const playAchievementSound = this.distanceMeter.update(deltaTime,
        Math.ceil(this.distanceRan))

      if (!Runner.audioCues && playAchievementSound) {
        this.playSound(this.soundFx.SCORE)
      }

      // Night mode.
      if (!Runner.isAltGameModeEnabled()) {
        if (this.invertTimer > this.config.INVERT_FADE_DURATION) {
          this.invertTimer = 0
          this.invertTrigger = false
          this.invert(false)
        } else if (this.invertTimer) {
          this.invertTimer += deltaTime
        } else {
          const actualDistance =
            this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan))

          if (actualDistance > 0) {
            this.invertTrigger =
              !(actualDistance % this.config.INVERT_DISTANCE)

            if (this.invertTrigger && this.invertTimer === 0) {
              this.invertTimer += deltaTime
              this.invert(false)
            }
          }
        }
      }
    }

    if (this.playing || (!this.activated &&
      this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {
      this.tRex.update(deltaTime)
      this.scheduleNextUpdate()
    }
  },

  /**
   * Event handler.
   * @param {Event} e
   */
  handleEvent (e) {
    return (function (evtType, events) {
      switch (evtType) {
        case events.KEYDOWN:
        case events.TOUCHSTART:
        case events.POINTERDOWN:
          this.onKeyDown(e)
          break
        case events.KEYUP:
        case events.TOUCHEND:
        case events.POINTERUP:
          this.onKeyUp(e)
          break
        case events.GAMEPADCONNECTED:
          this.onGamepadConnected(e)
          break
      }
    }.bind(this))(e.type, Runner.events)
  },

  /**
   * Initialize audio cues if activated by focus on the canvas element.
   * @param {Event} e
   */
  handleCanvasKeyPress (e) {
    if (!this.activated && !Runner.audioCues) {
      this.toggleSpeed()
      Runner.audioCues = true
      this.generatedSoundFx.init()
      Runner.generatedSoundFx = this.generatedSoundFx
      Runner.config.CLEAR_TIME *= 1.2
    } else if (e.keyCode && Runner.keycodes.JUMP[e.keyCode]) {
      this.onKeyDown(e)
    }
  },

  /**
   * Prevent space key press from scrolling.
   * @param {Event} e
   */
  preventScrolling (e) {
    if (e.keyCode === 32) {
      e.preventDefault()
    }
  },

  /**
   * Toggle speed setting if toggle is shown.
   */
  toggleSpeed () {
    if (Runner.audioCues) {
      const speedChange = Runner.slowDown != this.slowSpeedCheckbox.checked

      if (speedChange) {
        Runner.slowDown = this.slowSpeedCheckbox.checked
        const updatedConfig =
          Runner.slowDown ? Runner.slowConfig : Runner.normalConfig

        Runner.config = Object.assign(Runner.config, updatedConfig)
        this.currentSpeed = updatedConfig.SPEED
        this.tRex.enableSlowConfig()
        this.horizon.adjustObstacleSpeed()
      }
      if (this.playing) {
        this.disableSpeedToggle(true)
      }
    }
  },

  /**
   * Show the speed toggle.
   * From focus event or when audio cues are activated.
   * @param {Event=} e
   */
  showSpeedToggle (e) {
    const isFocusEvent = e && e.type == 'focus'
    if (Runner.audioCues || isFocusEvent) {
      this.slowSpeedCheckboxLabel.classList.toggle(
        offline_sprite_definitions_HIDDEN_CLASS, isFocusEvent ? false : !this.crashed)
    }
  },

  /**
   * Disable the speed toggle.
   * @param {boolean} disable
   */
  disableSpeedToggle (disable) {
    if (disable) {
      this.slowSpeedCheckbox.setAttribute('disabled', 'disabled')
    } else {
      this.slowSpeedCheckbox.removeAttribute('disabled')
    }
  },

  /**
   * Bind relevant key / mouse / touch listeners.
   */
  startListening () {
    // A11y keyboard / screen reader activation.
    this.containerEl.addEventListener(
      Runner.events.KEYDOWN, this.handleCanvasKeyPress.bind(this))
    if (!IS_MOBILE) {
      this.containerEl.addEventListener(
        Runner.events.FOCUS, this.showSpeedToggle.bind(this))
    }
    this.canvas.addEventListener(
      Runner.events.KEYDOWN, this.preventScrolling.bind(this))
    this.canvas.addEventListener(
      Runner.events.KEYUP, this.preventScrolling.bind(this))

    // Keys.
    document.addEventListener(Runner.events.KEYDOWN, this)
    document.addEventListener(Runner.events.KEYUP, this)

    // Touch / pointer.
    this.containerEl.addEventListener(Runner.events.TOUCHSTART, this)
    document.addEventListener(Runner.events.POINTERDOWN, this)
    document.addEventListener(Runner.events.POINTERUP, this)

    if (this.isArcadeMode()) {
      // Gamepad
      window.addEventListener(Runner.events.GAMEPADCONNECTED, this)
    }
  },

  /**
   * Remove all listeners.
   */
  stopListening () {
    document.removeEventListener(Runner.events.KEYDOWN, this)
    document.removeEventListener(Runner.events.KEYUP, this)

    if (this.touchController) {
      this.touchController.removeEventListener(Runner.events.TOUCHSTART, this)
      this.touchController.removeEventListener(Runner.events.TOUCHEND, this)
    }

    this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this)
    document.removeEventListener(Runner.events.POINTERDOWN, this)
    document.removeEventListener(Runner.events.POINTERUP, this)

    if (this.isArcadeMode()) {
      window.removeEventListener(Runner.events.GAMEPADCONNECTED, this)
    }
  },

  /**
   * Process keydown.
   * @param {Event} e
   */
  onKeyDown (e) {
    // Prevent native page scrolling whilst tapping on mobile.
    if (IS_MOBILE && this.playing) {
      e.preventDefault()
    }

    if (this.isCanvasInView()) {
      // Allow toggling of speed toggle.
      if (Runner.keycodes.JUMP[e.keyCode] &&
        e.target == this.slowSpeedCheckbox) {
        return
      }

      if (!this.crashed && !this.paused) {
        // For a11y, screen reader activation.
        const isMobileMouseInput = IS_MOBILE &&
          e.type === Runner.events.POINTERDOWN &&
          e.pointerType == 'mouse' && e.target == this.containerEl ||
          (IS_IOS && e.pointerType == 'touch' &&
            document.activeElement == this.containerEl)

        if (Runner.keycodes.JUMP[e.keyCode] ||
          e.type === Runner.events.TOUCHSTART || isMobileMouseInput ||
          (Runner.keycodes.DUCK[e.keyCode] && this.altGameModeActive)) {
          e.preventDefault()
          // Starting the game for the first time.
          if (!this.playing) {
            // Started by touch so create a touch controller.
            if (!this.touchController && e.type === Runner.events.TOUCHSTART) {
              this.createTouchController()
            }

            if (isMobileMouseInput) {
              this.handleCanvasKeyPress(e)
            }
            this.loadSounds()
            this.setPlayStatus(true)
            this.update()
            if (window.errorPageController) {
              errorPageController.trackEasterEgg()
            }
          }
          // Start jump.
          if (!this.tRex.jumping && !this.tRex.ducking) {
            if (Runner.audioCues) {
              this.generatedSoundFx.cancelFootSteps()
            } else {
              this.playSound(this.soundFx.BUTTON_PRESS)
            }
            this.tRex.startJump(this.currentSpeed)
          }
          // Ducking is disabled on alt game modes.
        } else if (
          !this.altGameModeActive && this.playing &&
          Runner.keycodes.DUCK[e.keyCode]) {
          e.preventDefault()
          if (this.tRex.jumping) {
            // Speed drop, activated only when jump key is not pressed.
            this.tRex.setSpeedDrop()
          } else if (!this.tRex.jumping && !this.tRex.ducking) {
            // Duck.
            this.tRex.setDuck(true)
          }
        }
      }
    }
  },

  /**
   * Process key up.
   * @param {Event} e
   */
  onKeyUp (e) {
    const keyCode = String(e.keyCode)
    const isjumpKey = Runner.keycodes.JUMP[keyCode] ||
      e.type === Runner.events.TOUCHEND || e.type === Runner.events.POINTERUP

    if (this.isRunning() && isjumpKey) {
      this.tRex.endJump()
    } else if (Runner.keycodes.DUCK[keyCode]) {
      this.tRex.speedDrop = false
      this.tRex.setDuck(false)
    } else if (this.crashed) {
      // Check that enough time has elapsed before allowing jump key to restart.
      const deltaTime = getTimeStamp() - this.time

      if (this.isCanvasInView() &&
        (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||
          (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&
            Runner.keycodes.JUMP[keyCode]))) {
        this.handleGameOverClicks(e)
      }
    } else if (this.paused && isjumpKey) {
      // Reset the jump state
      this.tRex.reset()
      this.play()
    }
  },

  /**
   * Process gamepad connected event.
   * @param {Event} e
   */
  onGamepadConnected (e) {
    if (!this.pollingGamepads) {
      this.pollGamepadState()
    }
  },

  /**
   * rAF loop for gamepad polling.
   */
  pollGamepadState () {
    const gamepads = navigator.getGamepads()
    this.pollActiveGamepad(gamepads)

    this.pollingGamepads = true
    requestAnimationFrame(this.pollGamepadState.bind(this))
  },

  /**
   * Polls for a gamepad with the jump button pressed. If one is found this
   * becomes the "active" gamepad and all others are ignored.
   * @param {!Array<Gamepad>} gamepads
   */
  pollForActiveGamepad (gamepads) {
    for (let i = 0; i < gamepads.length; ++i) {
      if (gamepads[i] && gamepads[i].buttons.length > 0 &&
        gamepads[i].buttons[0].pressed) {
        this.gamepadIndex = i
        this.pollActiveGamepad(gamepads)
        return
      }
    }
  },

  /**
   * Polls the chosen gamepad for button presses and generates KeyboardEvents
   * to integrate with the rest of the game logic.
   * @param {!Array<Gamepad>} gamepads
   */
  pollActiveGamepad (gamepads) {
    if (this.gamepadIndex === undefined) {
      this.pollForActiveGamepad(gamepads)
      return
    }

    const gamepad = gamepads[this.gamepadIndex]
    if (!gamepad) {
      this.gamepadIndex = undefined
      this.pollForActiveGamepad(gamepads)
      return
    }

    // The gamepad specification defines the typical mapping of physical buttons
    // to button indicies: https://w3c.github.io/gamepad/#remapping
    this.pollGamepadButton(gamepad, 0, 38) // Jump
    if (gamepad.buttons.length >= 2) {
      this.pollGamepadButton(gamepad, 1, 40) // Duck
    }
    if (gamepad.buttons.length >= 10) {
      this.pollGamepadButton(gamepad, 9, 13) // Restart
    }

    this.previousGamepad = gamepad
  },

  /**
   * Generates a key event based on a gamepad button.
   * @param {!Gamepad} gamepad
   * @param {number} buttonIndex
   * @param {number} keyCode
   */
  pollGamepadButton (gamepad, buttonIndex, keyCode) {
    const state = gamepad.buttons[buttonIndex].pressed
    let previousState = false
    if (this.previousGamepad) {
      previousState = this.previousGamepad.buttons[buttonIndex].pressed
    }
    // Generate key events on the rising and falling edge of a button press.
    if (state !== previousState) {
      const e = new KeyboardEvent(state
        ? Runner.events.KEYDOWN
        : Runner.events.KEYUP,
      { keyCode })
      document.dispatchEvent(e)
    }
  },

  /**
   * Handle interactions on the game over screen state.
   * A user is able to tap the high score twice to reset it.
   * @param {Event} e
   */
  handleGameOverClicks (e) {
    if (e.target != this.slowSpeedCheckbox) {
      e.preventDefault()
      if (this.distanceMeter.hasClickedOnHighScore(e) && this.highestScore) {
        if (this.distanceMeter.isHighScoreFlashing()) {
          // Subsequent click, reset the high score.
          this.saveHighScore(0, true)
          this.distanceMeter.resetHighScore()
        } else {
          // First click, flash the high score.
          this.distanceMeter.startHighScoreFlashing()
        }
      } else {
        this.distanceMeter.cancelHighScoreFlashing()
        this.restart()
      }
    }
  },

  /**
   * Returns whether the event was a left click on canvas.
   * On Windows right click is registered as a click.
   * @param {Event} e
   * @return {boolean}
   */
  isLeftClickOnCanvas (e) {
    return e.button != null && e.button < 2 &&
      e.type === Runner.events.POINTERUP &&
      (e.target === this.canvas ||
        (IS_MOBILE && Runner.audioCues && e.target === this.containerEl))
  },

  /**
   * RequestAnimationFrame wrapper.
   */
  scheduleNextUpdate () {
    if (!this.updatePending) {
      this.updatePending = true
      this.raqId = requestAnimationFrame(this.update.bind(this))
    }
  },

  /**
   * Whether the game is running.
   * @return {boolean}
   */
  isRunning () {
    return !!this.raqId
  },

  /**
   * Set the initial high score as stored in the user's profile.
   * @param {number} highScore
   */
  initializeHighScore (highScore) {
    this.syncHighestScore = true
    highScore = Math.ceil(highScore)
    if (highScore < this.highestScore) {
      if (window.errorPageController) {
        errorPageController.updateEasterEggHighScore(this.highestScore)
      }
      return
    }
    this.highestScore = highScore
    this.distanceMeter.setHighScore(this.highestScore)
  },

  /**
   * Sets the current high score and saves to the profile if available.
   * @param {number} distanceRan Total distance ran.
   * @param {boolean=} optResetScore Whether to reset the score.
   */
  saveHighScore (distanceRan, optResetScore) {
    this.highestScore = Math.ceil(distanceRan)
    this.distanceMeter.setHighScore(this.highestScore)

    // Store the new high score in the profile.
    if (this.syncHighestScore && window.errorPageController) {
      if (optResetScore) {
        errorPageController.resetEasterEggHighScore()
      } else {
        errorPageController.updateEasterEggHighScore(this.highestScore)
      }
    }
  },

  /**
   * Game over state.
   */
  gameOver () {
    this.playSound(this.soundFx.HIT)
    vibrate(200)

    this.stop()
    this.crashed = true
    this.distanceMeter.achievement = false

    this.tRex.update(100, Trex.status.CRASHED)

    // Game over panel.
    if (!this.gameOverPanel) {
      const origSpriteDef = IS_HIDPI
        ? Runner.spriteDefinitionByType.original.HDPI
        : Runner.spriteDefinitionByType.original.LDPI

      if (this.canvas) {
        if (Runner.isAltGameModeEnabled) {
          this.gameOverPanel = new GameOverPanel(
            this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART,
            this.dimensions, origSpriteDef.ALT_GAME_END,
            this.altGameModeActive)
        } else {
          this.gameOverPanel = new GameOverPanel(
            this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART,
            this.dimensions)
        }
      }
    }

    this.gameOverPanel.draw(this.altGameModeActive, this.tRex)

    // Update the high score.
    if (this.distanceRan > this.highestScore) {
      this.saveHighScore(this.distanceRan)
    }

    // Reset the time clock.
    this.time = getTimeStamp()

    if (Runner.audioCues) {
      this.generatedSoundFx.stopAll()
      announcePhrase(
        getA11yString(A11Y_STRINGS.gameOver)
          .replace(
            '$1',
            this.distanceMeter.getActualDistance(this.distanceRan)
              .toString()) +
        ' ' +
        getA11yString(A11Y_STRINGS.highScore)
          .replace(
            '$1',

            this.distanceMeter.getActualDistance(this.highestScore)
              .toString()))
      this.containerEl.setAttribute(
        'title', getA11yString(A11Y_STRINGS.ariaLabel))
    }
    this.showSpeedToggle()
    this.disableSpeedToggle(false)
  },

  stop () {
    this.setPlayStatus(false)
    this.paused = true
    cancelAnimationFrame(this.raqId)
    this.raqId = 0
    this.generatedSoundFx.stopAll()
  },

  play () {
    if (!this.crashed) {
      this.setPlayStatus(true)
      this.paused = false
      this.tRex.update(0, Trex.status.RUNNING)
      this.time = getTimeStamp()
      this.update()
      this.generatedSoundFx.background()
    }
  },

  restart () {
    if (!this.raqId) {
      this.playCount++
      this.runningTime = 0
      this.setPlayStatus(true)
      this.toggleSpeed()
      this.paused = false
      this.crashed = false
      this.distanceRan = 0
      this.setSpeed(this.config.SPEED)
      this.time = getTimeStamp()
      this.containerEl.classList.remove(Runner.classes.CRASHED)
      this.clearCanvas()
      this.distanceMeter.reset()
      this.horizon.reset()
      this.tRex.reset()
      this.playSound(this.soundFx.BUTTON_PRESS)
      this.invert(true)
      this.flashTimer = null
      this.update()
      this.gameOverPanel.reset()
      this.generatedSoundFx.background()
      this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump))
      announcePhrase(getA11yString(A11Y_STRINGS.started))
    }
  },

  setPlayStatus (isPlaying) {
    if (this.touchController) {
      this.touchController.classList.toggle(offline_sprite_definitions_HIDDEN_CLASS, !isPlaying)
    }
    this.playing = isPlaying
  },

  /**
   * Whether the game should go into arcade mode.
   * @return {boolean}
   */
  isArcadeMode () {
    // In RTL languages the title is wrapped with the left to right mark
    // control characters &#x202A; and &#x202C but are invisible.
    return IS_RTL
      ? document.title.indexOf(ARCADE_MODE_URL) == 1
      : document.title === ARCADE_MODE_URL
  },

  /**
   * Hides offline messaging for a fullscreen game only experience.
   */
  setArcadeMode () {
    document.body.classList.add(Runner.classes.ARCADE_MODE)
    this.setArcadeModeContainerScale()
  },

  /**
   * Sets the scaling for arcade mode.
   */
  setArcadeModeContainerScale () {
    const windowHeight = window.innerHeight
    const scaleHeight = windowHeight / this.dimensions.HEIGHT
    const scaleWidth = window.innerWidth / this.dimensions.WIDTH
    const scale = Math.max(1, Math.min(scaleHeight, scaleWidth))
    const scaledCanvasHeight = this.dimensions.HEIGHT * scale
    // Positions the game container at 10% of the available vertical window
    // height minus the game container height.
    const translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -
          Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *
        Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *
      window.devicePixelRatio

    const cssScale = IS_RTL ? -scale + ',' + scale : scale
    this.containerEl.style.transform =
      'scale(' + cssScale + ') translateY(' + translateY + 'px)'
  },

  /**
   * Pause the game if the tab is not in focus.
   */
  onVisibilityChange (e) {
    if (document.hidden || document.webkitHidden || e.type === 'blur' ||
      document.visibilityState !== 'visible') {
      this.stop()
    } else if (!this.crashed) {
      this.tRex.reset()
      this.play()
    }
  },

  /**
   * Play a sound.
   * @param {AudioBuffer} soundBuffer
   */
  playSound (soundBuffer) {
    if (soundBuffer) {
      const sourceNode = this.audioContext.createBufferSource()
      sourceNode.buffer = soundBuffer
      sourceNode.connect(this.audioContext.destination)
      sourceNode.start(0)
    }
  },

  /**
   * Inverts the current page / canvas colors.
   * @param {boolean} reset Whether to reset colors.
   */
  invert (reset) {
    const htmlEl = document.firstElementChild

    if (reset) {
      htmlEl.classList.toggle(Runner.classes.INVERTED,
        false)
      this.invertTimer = 0
      this.inverted = false
    } else {
      this.inverted = htmlEl.classList.toggle(
        Runner.classes.INVERTED, this.invertTrigger)
    }
  }
}

/**
 * Updates the canvas size taking into
 * account the backing store pixel ratio and
 * the device pixel ratio.
 *
 * See article by Paul Lewis:
 * http://www.html5rocks.com/en/tutorials/canvas/hidpi/
 *
 * @param {HTMLCanvasElement} canvas
 * @param {number=} opt_width
 * @param {number=} opt_height
 * @return {boolean} Whether the canvas was scaled.
 */
Runner.updateCanvasScaling = function (canvas, opt_width, opt_height) {
  const context =
    /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'))

  // Query the various pixel ratios
  const devicePixelRatio = Math.floor(window.devicePixelRatio) || 1
  /** @suppress {missingProperties} */
  const backingStoreRatio =
    Math.floor(context.webkitBackingStorePixelRatio) || 1
  const ratio = devicePixelRatio / backingStoreRatio

  // Upscale the canvas if the two ratios don't match
  if (devicePixelRatio !== backingStoreRatio) {
    const oldWidth = opt_width || canvas.width
    const oldHeight = opt_height || canvas.height

    canvas.width = oldWidth * ratio
    canvas.height = oldHeight * ratio

    canvas.style.width = oldWidth + 'px'
    canvas.style.height = oldHeight + 'px'

    // Scale the context to counter the fact that we've manually scaled
    // our canvas element.
    context.scale(ratio, ratio)
    return true
  } else if (devicePixelRatio === 1) {
    // Reset the canvas width / height. Fixes scaling bug when the page is
    // zoomed and the devicePixelRatio changes accordingly.
    canvas.style.width = canvas.width + 'px'
    canvas.style.height = canvas.height + 'px'
  }
  return false
}

/**
 * Whether events are enabled.
 * @return {boolean}
 */
Runner.isAltGameModeEnabled = function () {
  return load_time_data_deprecated_loadTimeData && load_time_data_deprecated_loadTimeData.valueExists('enableAltGameMode')
}

/**
 * Generated sound FX class for audio cues.
 * @constructor
 */
function GeneratedSoundFx () {
  this.audioCues = false
  this.context = null
  this.panner = null
}

GeneratedSoundFx.prototype = {
  init () {
    this.audioCues = true
    if (!this.context) {
      // iOS only supports the webkit version.
      this.context = window.webkitAudioContext
        ? new webkitAudioContext()
        : new AudioContext()
      if (IS_IOS) {
        this.context.onstatechange = function () {
          if (this.context.state != 'running') {
            this.context.resume()
          }
        }.bind(this)
        this.context.resume()
      }
      this.panner = this.context.createStereoPanner
        ? this.context.createStereoPanner()
        : null
    }
  },

  stopAll () {
    this.cancelFootSteps()
  },

  /**
   * Play oscillators at certain frequency and for a certain time.
   * @param {number} frequency
   * @param {number} startTime
   * @param {number} duration
   * @param {?number=} opt_vol
   * @param {number=} opt_pan
   */
  playNote (frequency, startTime, duration, opt_vol, opt_pan) {
    const osc1 = this.context.createOscillator()
    const osc2 = this.context.createOscillator()
    const volume = this.context.createGain()

    // Set oscillator wave type
    osc1.type = 'triangle'
    osc2.type = 'triangle'
    volume.gain.value = 0.1

    // Set up node routing
    if (this.panner) {
      this.panner.pan.value = opt_pan || 0
      osc1.connect(volume).connect(this.panner)
      osc2.connect(volume).connect(this.panner)
      this.panner.connect(this.context.destination)
    } else {
      osc1.connect(volume)
      osc2.connect(volume)
      volume.connect(this.context.destination)
    }

    // Detune oscillators for chorus effect
    osc1.frequency.value = frequency + 1
    osc2.frequency.value = frequency - 2

    // Fade out
    volume.gain.setValueAtTime(opt_vol || 0.01, startTime + duration - 0.05)
    volume.gain.linearRampToValueAtTime(0.00001, startTime + duration)

    // Start oscillators
    osc1.start(startTime)
    osc2.start(startTime)
    // Stop oscillators
    osc1.stop(startTime + duration)
    osc2.stop(startTime + duration)
  },

  background () {
    if (this.audioCues) {
      const now = this.context.currentTime
      this.playNote(493.883, now, 0.116)
      this.playNote(659.255, now + 0.116, 0.232)
      this.loopFootSteps()
    }
  },

  loopFootSteps () {
    if (this.audioCues && !this.bgSoundIntervalId) {
      this.bgSoundIntervalId = setInterval(function () {
        this.playNote(73.42, this.context.currentTime, 0.05, 0.16)
        this.playNote(69.30, this.context.currentTime + 0.116, 0.116, 0.16)
      }.bind(this), 280)
    }
  },

  cancelFootSteps () {
    if (this.audioCues && this.bgSoundIntervalId) {
      clearInterval(this.bgSoundIntervalId)
      this.bgSoundIntervalId = null
      this.playNote(103.83, this.context.currentTime, 0.232, 0.02)
      this.playNote(116.54, this.context.currentTime + 0.116, 0.232, 0.02)
    }
  },

  collect () {
    if (this.audioCues) {
      this.cancelFootSteps()
      const now = this.context.currentTime
      this.playNote(830.61, now, 0.116)
      this.playNote(1318.51, now + 0.116, 0.232)
    }
  },

  jump () {
    if (this.audioCues) {
      const now = this.context.currentTime
      this.playNote(659.25, now, 0.116, 0.3, -0.6)
      this.playNote(880, now + 0.116, 0.232, 0.3, -0.6)
    }
  }
}

/**
 * Speak a phrase using Speech Synthesis API for a11y.
 * @param {string} phrase Sentence to speak.
 */
function speakPhrase (phrase) {
  if ('speechSynthesis' in window) {
    const msg = new SpeechSynthesisUtterance(phrase)
    const voices = window.speechSynthesis.getVoices()
    msg.text = phrase
    speechSynthesis.speak(msg)
  }
}

/**
 * For screen readers make an announcement to the live region.
 * @param {string} phrase Sentence to speak.
 */
function announcePhrase (phrase) {
  if (Runner.a11yStatusEl) {
    Runner.a11yStatusEl.textContent = ''
    Runner.a11yStatusEl.textContent = phrase
  }
}

/**
 * Returns a string from loadTimeData data object.
 * @param {string} stringName
 * @return {string}
 */
function getA11yString (stringName) {
  return load_time_data_deprecated_loadTimeData && load_time_data_deprecated_loadTimeData.valueExists(stringName)
    ? load_time_data_deprecated_loadTimeData.getString(stringName)
    : ''
}

/**
 * Get random number.
 * @param {number} min
 * @param {number} max
 */
function getRandomNum (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

/**
 * Vibrate on mobile devices.
 * @param {number} duration Duration of the vibration in milliseconds.
 */
function vibrate (duration) {
  if (IS_MOBILE && window.navigator.vibrate) {
    window.navigator.vibrate(duration)
  }
}

/**
 * Create canvas element.
 * @param {Element} container Element to append canvas to.
 * @param {number} width
 * @param {number} height
 * @param {string=} opt_classname
 * @return {HTMLCanvasElement}
 */
function createCanvas (container, width, height, opt_classname) {
  const canvas =
    /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'))
  canvas.className = opt_classname
    ? Runner.classes.CANVAS + ' ' +
    opt_classname
    : Runner.classes.CANVAS
  canvas.width = width
  canvas.height = height
  container.appendChild(canvas)

  return canvas
}

/**
 * Decodes the base 64 audio to ArrayBuffer used by Web Audio.
 * @param {string} base64String
 */
function decodeBase64ToArrayBuffer (base64String) {
  const len = (base64String.length / 4) * 3
  const str = atob(base64String)
  const arrayBuffer = new ArrayBuffer(len)
  const bytes = new Uint8Array(arrayBuffer)

  for (let i = 0; i < len; i++) {
    bytes[i] = str.charCodeAt(i)
  }
  return bytes.buffer
}

/**
 * Return the current timestamp.
 * @return {number}
 */
function getTimeStamp () {
  return IS_IOS ? new Date().getTime() : performance.now()
}

//* *****************************************************************************

/**
 * Game over panel.
 * @param {!HTMLCanvasElement} canvas
 * @param {Object} textImgPos
 * @param {Object} restartImgPos
 * @param {!Object} dimensions Canvas dimensions.
 * @param {Object=} opt_altGameEndImgPos
 * @param {boolean=} opt_altGameActive
 * @constructor
 */
function GameOverPanel (
  canvas, textImgPos, restartImgPos, dimensions, opt_altGameEndImgPos,
  opt_altGameActive) {
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'))
  this.canvasDimensions = dimensions
  this.textImgPos = textImgPos
  this.restartImgPos = restartImgPos
  this.altGameEndImgPos = opt_altGameEndImgPos
  this.altGameModeActive = opt_altGameActive

  // Retry animation.
  this.frameTimeStamp = 0
  this.animTimer = 0
  this.currentFrame = 0

  this.gameOverRafId = null

  this.flashTimer = 0
  this.flashCounter = 0
  this.originalText = true
}

GameOverPanel.RESTART_ANIM_DURATION = 875
GameOverPanel.LOGO_PAUSE_DURATION = 875
GameOverPanel.FLASH_ITERATIONS = 5

/**
 * Animation frames spec.
 */
GameOverPanel.animConfig = {
  frames: [0, 36, 72, 108, 144, 180, 216, 252],
  msPerFrame: GameOverPanel.RESTART_ANIM_DURATION / 8
}

/**
 * Dimensions used in the panel.
 * @enum {number}
 */
GameOverPanel.dimensions = {
  TEXT_X: 0,
  TEXT_Y: 13,
  TEXT_WIDTH: 191,
  TEXT_HEIGHT: 11,
  RESTART_WIDTH: 36,
  RESTART_HEIGHT: 32
}

GameOverPanel.prototype = {
  /**
   * Update the panel dimensions.
   * @param {number} width New canvas width.
   * @param {number} opt_height Optional new canvas height.
   */
  updateDimensions (width, opt_height) {
    this.canvasDimensions.WIDTH = width
    if (opt_height) {
      this.canvasDimensions.HEIGHT = opt_height
    }
    this.currentFrame = GameOverPanel.animConfig.frames.length - 1
  },

  drawGameOverText (dimensions, opt_useAltText) {
    const centerX = this.canvasDimensions.WIDTH / 2
    let textSourceX = dimensions.TEXT_X
    let textSourceY = dimensions.TEXT_Y
    let textSourceWidth = dimensions.TEXT_WIDTH
    let textSourceHeight = dimensions.TEXT_HEIGHT

    const textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2))
    const textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3)
    const textTargetWidth = dimensions.TEXT_WIDTH
    const textTargetHeight = dimensions.TEXT_HEIGHT

    if (IS_HIDPI) {
      textSourceY *= 2
      textSourceX *= 2
      textSourceWidth *= 2
      textSourceHeight *= 2
    }

    if (!opt_useAltText) {
      textSourceX += this.textImgPos.x
      textSourceY += this.textImgPos.y
    }

    const spriteSource =
      opt_useAltText ? Runner.altCommonImageSprite : Runner.origImageSprite

    this.canvasCtx.save()

    if (IS_RTL) {
      this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0)
      this.canvasCtx.scale(-1, 1)
    }

    // Game over text from sprite.
    this.canvasCtx.drawImage(
      spriteSource, textSourceX, textSourceY, textSourceWidth,
      textSourceHeight, textTargetX, textTargetY, textTargetWidth,
      textTargetHeight)

    this.canvasCtx.restore()
  },

  /**
   * Draw additional adornments for alternative game types.
   */
  drawAltGameElements (tRex) {
    // Additional adornments.
    if (this.altGameModeActive && Runner.spriteDefinition.ALT_GAME_END_CONFIG) {
      const altGameEndConfig = Runner.spriteDefinition.ALT_GAME_END_CONFIG

      let altGameEndSourceWidth = altGameEndConfig.WIDTH
      let altGameEndSourceHeight = altGameEndConfig.HEIGHT
      const altGameEndTargetX = tRex.xPos + altGameEndConfig.X_OFFSET
      const altGameEndTargetY = tRex.yPos + altGameEndConfig.Y_OFFSET

      if (IS_HIDPI) {
        altGameEndSourceWidth *= 2
        altGameEndSourceHeight *= 2
      }

      this.canvasCtx.drawImage(
        Runner.altCommonImageSprite, this.altGameEndImgPos.x,
        this.altGameEndImgPos.y, altGameEndSourceWidth,
        altGameEndSourceHeight, altGameEndTargetX, altGameEndTargetY,
        altGameEndConfig.WIDTH, altGameEndConfig.HEIGHT)
    }
  },

  /**
   * Draw restart button.
   */
  drawRestartButton () {
    const dimensions = GameOverPanel.dimensions
    let framePosX = GameOverPanel.animConfig.frames[this.currentFrame]
    let restartSourceWidth = dimensions.RESTART_WIDTH
    let restartSourceHeight = dimensions.RESTART_HEIGHT
    const restartTargetX =
      (this.canvasDimensions.WIDTH / 2) - (dimensions.RESTART_WIDTH / 2)
    const restartTargetY = this.canvasDimensions.HEIGHT / 2

    if (IS_HIDPI) {
      restartSourceWidth *= 2
      restartSourceHeight *= 2
      framePosX *= 2
    }

    this.canvasCtx.save()

    if (IS_RTL) {
      this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0)
      this.canvasCtx.scale(-1, 1)
    }

    this.canvasCtx.drawImage(
      Runner.origImageSprite, this.restartImgPos.x + framePosX,
      this.restartImgPos.y, restartSourceWidth, restartSourceHeight,
      restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,
      dimensions.RESTART_HEIGHT)
    this.canvasCtx.restore()
  },

  /**
   * Draw the panel.
   * @param {boolean} opt_altGameModeActive
   * @param {!Trex} opt_tRex
   */
  draw (opt_altGameModeActive, opt_tRex) {
    if (opt_altGameModeActive) {
      this.altGameModeActive = opt_altGameModeActive
    }

    this.drawGameOverText(GameOverPanel.dimensions, false)
    this.drawRestartButton()
    this.drawAltGameElements(opt_tRex)
    this.update()
  },

  /**
   * Update animation frames.
   */
  update () {
    const now = getTimeStamp()
    const deltaTime = now - (this.frameTimeStamp || now)

    this.frameTimeStamp = now
    this.animTimer += deltaTime
    this.flashTimer += deltaTime

    // Restart Button
    if (this.currentFrame == 0 &&
      this.animTimer > GameOverPanel.LOGO_PAUSE_DURATION) {
      this.animTimer = 0
      this.currentFrame++
      this.drawRestartButton()
    } else if (
      this.currentFrame > 0 &&
      this.currentFrame < GameOverPanel.animConfig.frames.length) {
      if (this.animTimer >= GameOverPanel.animConfig.msPerFrame) {
        this.currentFrame++
        this.drawRestartButton()
      }
    } else if (
      !this.altGameModeActive &&
      this.currentFrame == GameOverPanel.animConfig.frames.length) {
      this.reset()
      return
    }

    // Game over text
    if (this.altGameModeActive &&
      Runner.spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG) {
      const altTextConfig =
        Runner.spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG

      if (this.flashCounter < GameOverPanel.FLASH_ITERATIONS &&
        this.flashTimer > altTextConfig.FLASH_DURATION) {
        this.flashTimer = 0
        this.originalText = !this.originalText

        this.clearGameOverTextBounds()
        if (this.originalText) {
          this.drawGameOverText(GameOverPanel.dimensions, false)
          this.flashCounter++
        } else {
          this.drawGameOverText(altTextConfig, true)
        }
      } else if (this.flashCounter >= GameOverPanel.FLASH_ITERATIONS) {
        this.reset()
        return
      }
    }

    this.gameOverRafId = requestAnimationFrame(this.update.bind(this))
  },

  /**
   * Clear game over text.
   */
  clearGameOverTextBounds () {
    this.canvasCtx.save()

    this.canvasCtx.clearRect(
      Math.round(
        this.canvasDimensions.WIDTH / 2 -
        (GameOverPanel.dimensions.TEXT_WIDTH / 2)),
      Math.round((this.canvasDimensions.HEIGHT - 25) / 3),
      GameOverPanel.dimensions.TEXT_WIDTH,
      GameOverPanel.dimensions.TEXT_HEIGHT + 4)
    this.canvasCtx.restore()
  },

  reset () {
    if (this.gameOverRafId) {
      cancelAnimationFrame(this.gameOverRafId)
      this.gameOverRafId = null
    }
    this.animTimer = 0
    this.frameTimeStamp = 0
    this.currentFrame = 0
    this.flashTimer = 0
    this.flashCounter = 0
    this.originalText = true
  }
}

//* *****************************************************************************

/**
 * Check for a collision.
 * @param {!Obstacle} obstacle
 * @param {!Trex} tRex T-rex object.
 * @param {CanvasRenderingContext2D=} opt_canvasCtx Optional canvas context for
 *    drawing collision boxes.
 * @return {Array<CollisionBox>|undefined}
 */
function checkForCollision (obstacle, tRex, opt_canvasCtx) {
  const obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos

  // Adjustments are made to the bounding box as there is a 1 pixel white
  // border around the t-rex and obstacles.
  const tRexBox = new CollisionBox(
    tRex.xPos + 1,
    tRex.yPos + 1,
    tRex.config.WIDTH - 2,
    tRex.config.HEIGHT - 2)

  const obstacleBox = new CollisionBox(
    obstacle.xPos + 1,
    obstacle.yPos + 1,
    obstacle.typeConfig.width * obstacle.size - 2,
    obstacle.typeConfig.height - 2)

  // Debug outer box
  if (opt_canvasCtx) {
    drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox)
  }

  // Simple outer bounds check.
  if (boxCompare(tRexBox, obstacleBox)) {
    const collisionBoxes = obstacle.collisionBoxes
    let tRexCollisionBoxes = []

    if (Runner.isAltGameModeEnabled()) {
      tRexCollisionBoxes = Runner.spriteDefinition.TREX.COLLISION_BOXES
    } else {
      tRexCollisionBoxes = tRex.ducking
        ? Trex.collisionBoxes.DUCKING
        : Trex.collisionBoxes.RUNNING
    }

    // Detailed axis aligned box check.
    for (let t = 0; t < tRexCollisionBoxes.length; t++) {
      for (let i = 0; i < collisionBoxes.length; i++) {
        // Adjust the box to actual positions.
        const adjTrexBox =
          createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox)
        const adjObstacleBox =
          createAdjustedCollisionBox(collisionBoxes[i], obstacleBox)
        const crashed = boxCompare(adjTrexBox, adjObstacleBox)

        // Draw boxes for debug.
        if (opt_canvasCtx) {
          drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox)
        }

        if (crashed) {
          return [adjTrexBox, adjObstacleBox]
        }
      }
    }
  }
}

/**
 * Adjust the collision box.
 * @param {!CollisionBox} box The original box.
 * @param {!CollisionBox} adjustment Adjustment box.
 * @return {CollisionBox} The adjusted collision box object.
 */
function createAdjustedCollisionBox (box, adjustment) {
  return new CollisionBox(
    box.x + adjustment.x,
    box.y + adjustment.y,
    box.width,
    box.height)
}

/**
 * Draw the collision boxes for debug.
 */
function drawCollisionBoxes (canvasCtx, tRexBox, obstacleBox) {
  canvasCtx.save()
  canvasCtx.strokeStyle = '#f00'
  canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height)

  canvasCtx.strokeStyle = '#0f0'
  canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,
    obstacleBox.width, obstacleBox.height)
  canvasCtx.restore()
}

/**
 * Compare two collision boxes for a collision.
 * @param {CollisionBox} tRexBox
 * @param {CollisionBox} obstacleBox
 * @return {boolean} Whether the boxes intersected.
 */
function boxCompare (tRexBox, obstacleBox) {
  let crashed = false
  const tRexBoxX = tRexBox.x
  const tRexBoxY = tRexBox.y

  const obstacleBoxX = obstacleBox.x
  const obstacleBoxY = obstacleBox.y

  // Axis-Aligned Bounding Box method.
  if (tRexBox.x < obstacleBoxX + obstacleBox.width &&
    tRexBox.x + tRexBox.width > obstacleBoxX &&
    tRexBox.y < obstacleBox.y + obstacleBox.height &&
    tRexBox.height + tRexBox.y > obstacleBox.y) {
    crashed = true
  }

  return crashed
}

//* *****************************************************************************

/**
 * Collision box object.
 * @param {number} x X position.
 * @param {number} y Y Position.
 * @param {number} w Width.
 * @param {number} h Height.
 * @constructor
 */
function CollisionBox (x, y, w, h) {
  this.x = x
  this.y = y
  this.width = w
  this.height = h
}

//* *****************************************************************************

/**
 * Obstacle.
 * @param {CanvasRenderingContext2D} canvasCtx
 * @param {ObstacleType} type
 * @param {Object} spriteImgPos Obstacle position in sprite.
 * @param {Object} dimensions
 * @param {number} gapCoefficient Mutipler in determining the gap.
 * @param {number} speed
 * @param {number=} opt_xOffset
 * @param {boolean=} opt_isAltGameMode
 * @constructor
 */
function Obstacle (
  canvasCtx, type, spriteImgPos, dimensions, gapCoefficient, speed,
  opt_xOffset, opt_isAltGameMode) {
  this.canvasCtx = canvasCtx
  this.spritePos = spriteImgPos
  this.typeConfig = type
  this.gapCoefficient = Runner.slowDown ? gapCoefficient * 2 : gapCoefficient
  this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH)
  this.dimensions = dimensions
  this.remove = false
  this.xPos = dimensions.WIDTH + (opt_xOffset || 0)
  this.yPos = 0
  this.width = 0
  this.collisionBoxes = []
  this.gap = 0
  this.speedOffset = 0
  this.altGameModeActive = opt_isAltGameMode
  this.imageSprite = this.typeConfig.type == 'COLLECTABLE'
    ? Runner.altCommonImageSprite
    : this.altGameModeActive ? Runner.altGameImageSprite : Runner.imageSprite

  // For animated obstacles.
  this.currentFrame = 0
  this.timer = 0

  this.init(speed)
}

/**
 * Coefficient for calculating the maximum gap.
 */
Obstacle.MAX_GAP_COEFFICIENT = 1.5

/**
 * Maximum obstacle grouping count.
 */
Obstacle.MAX_OBSTACLE_LENGTH = 3

Obstacle.prototype = {
  /**
   * Initialise the DOM for the obstacle.
   * @param {number} speed
   */
  init (speed) {
    this.cloneCollisionBoxes()

    // Only allow sizing if we're at the right speed.
    if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {
      this.size = 1
    }

    this.width = this.typeConfig.width * this.size

    // Check if obstacle can be positioned at various heights.
    if (Array.isArray(this.typeConfig.yPos)) {
      const yPosConfig =
        IS_MOBILE ? this.typeConfig.yPosMobile : this.typeConfig.yPos
      this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)]
    } else {
      this.yPos = this.typeConfig.yPos
    }

    this.draw()

    // Make collision box adjustments,
    // Central box is adjusted to the size as one box.
    //      ____        ______        ________
    //    _|   |-|    _|     |-|    _|       |-|
    //   | |<->| |   | |<--->| |   | |<----->| |
    //   | | 1 | |   | |  2  | |   | |   3   | |
    //   |_|___|_|   |_|_____|_|   |_|_______|_|
    //
    if (this.size > 1) {
      this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -
        this.collisionBoxes[2].width
      this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width
    }

    // For obstacles that go at a different speed from the horizon.
    if (this.typeConfig.speedOffset) {
      this.speedOffset = Math.random() > 0.5
        ? this.typeConfig.speedOffset
        : -this.typeConfig.speedOffset
    }

    this.gap = this.getGap(this.gapCoefficient, speed)

    // Increase gap for audio cues enabled.
    if (Runner.audioCues) {
      this.gap *= 2
    }
  },

  /**
   * Draw and crop based on size.
   */
  draw () {
    let sourceWidth = this.typeConfig.width
    let sourceHeight = this.typeConfig.height

    if (IS_HIDPI) {
      sourceWidth = sourceWidth * 2
      sourceHeight = sourceHeight * 2
    }

    // X position in sprite.
    let sourceX =
      (sourceWidth * this.size) * (0.5 * (this.size - 1)) + this.spritePos.x

    // Animation frames.
    if (this.currentFrame > 0) {
      sourceX += sourceWidth * this.currentFrame
    }

    this.canvasCtx.drawImage(
      this.imageSprite, sourceX, this.spritePos.y, sourceWidth * this.size,
      sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size,
      this.typeConfig.height)
  },

  /**
   * Obstacle frame update.
   * @param {number} deltaTime
   * @param {number} speed
   */
  update (deltaTime, speed) {
    if (!this.remove) {
      if (this.typeConfig.speedOffset) {
        speed += this.speedOffset
      }
      this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime)

      // Update frame
      if (this.typeConfig.numFrames) {
        this.timer += deltaTime
        if (this.timer >= this.typeConfig.frameRate) {
          this.currentFrame =
            this.currentFrame === this.typeConfig.numFrames - 1
              ? 0
              : this.currentFrame + 1
          this.timer = 0
        }
      }
      this.draw()

      if (!this.isVisible()) {
        this.remove = true
      }
    }
  },

  /**
   * Calculate a random gap size.
   * - Minimum gap gets wider as speed increses
   * @param {number} gapCoefficient
   * @param {number} speed
   * @return {number} The gap size.
   */
  getGap (gapCoefficient, speed) {
    const minGap = Math.round(
      this.width * speed + this.typeConfig.minGap * gapCoefficient)
    const maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT)
    return getRandomNum(minGap, maxGap)
  },

  /**
   * Check if obstacle is visible.
   * @return {boolean} Whether the obstacle is in the game area.
   */
  isVisible () {
    return this.xPos + this.width > 0
  },

  /**
   * Make a copy of the collision boxes, since these will change based on
   * obstacle type and size.
   */
  cloneCollisionBoxes () {
    const collisionBoxes = this.typeConfig.collisionBoxes

    for (let i = collisionBoxes.length - 1; i >= 0; i--) {
      this.collisionBoxes[i] = new CollisionBox(
        collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width,
        collisionBoxes[i].height)
    }
  }
}

//* *****************************************************************************
/**
 * T-rex game character.
 * @param {HTMLCanvasElement} canvas
 * @param {Object} spritePos Positioning within image sprite.
 * @constructor
 */
function Trex (canvas, spritePos) {
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'))
  this.spritePos = spritePos
  this.xPos = 0
  this.yPos = 0
  this.xInitialPos = 0
  // Position when on the ground.
  this.groundYPos = 0
  this.currentFrame = 0
  this.currentAnimFrames = []
  this.blinkDelay = 0
  this.blinkCount = 0
  this.animStartTime = 0
  this.timer = 0
  this.msPerFrame = 1000 / FPS
  this.config = Object.assign(Trex.config, Trex.normalJumpConfig)
  // Current status.
  this.status = Trex.status.WAITING
  this.jumping = false
  this.ducking = false
  this.jumpVelocity = 0
  this.reachedMinHeight = false
  this.speedDrop = false
  this.jumpCount = 0
  this.jumpspotX = 0
  this.altGameModeEnabled = false
  this.flashing = false

  this.init()
}

/**
 * T-rex player config.
 */
Trex.config = {
  DROP_VELOCITY: -5,
  FLASH_OFF: 175,
  FLASH_ON: 100,
  HEIGHT: 47,
  HEIGHT_DUCK: 25,
  INTRO_DURATION: 1500,
  SPEED_DROP_COEFFICIENT: 3,
  SPRITE_WIDTH: 262,
  START_X_POS: 50,
  WIDTH: 44,
  WIDTH_DUCK: 59
}

Trex.slowJumpConfig = {
  GRAVITY: 0.25,
  MAX_JUMP_HEIGHT: 50,
  MIN_JUMP_HEIGHT: 45,
  INITIAL_JUMP_VELOCITY: -20
}

Trex.normalJumpConfig = {
  GRAVITY: 0.6,
  MAX_JUMP_HEIGHT: 30,
  MIN_JUMP_HEIGHT: 30,
  INITIAL_JUMP_VELOCITY: -10
}

/**
 * Used in collision detection.
 * @enum {Array<CollisionBox>}
 */
Trex.collisionBoxes = {
  DUCKING: [new CollisionBox(1, 18, 55, 25)],
  RUNNING: [
    new CollisionBox(22, 0, 17, 16),
    new CollisionBox(1, 18, 30, 9),
    new CollisionBox(10, 35, 14, 8),
    new CollisionBox(1, 24, 29, 5),
    new CollisionBox(5, 30, 21, 4),
    new CollisionBox(9, 34, 15, 4)
  ]
}

/**
 * Animation states.
 * @enum {string}
 */
Trex.status = {
  CRASHED: 'CRASHED',
  DUCKING: 'DUCKING',
  JUMPING: 'JUMPING',
  RUNNING: 'RUNNING',
  WAITING: 'WAITING'
}

/**
 * Blinking coefficient.
 * @const
 */
Trex.BLINK_TIMING = 7000

/**
 * Animation config for different states.
 * @enum {Object}
 */
Trex.animFrames = {
  WAITING: {
    frames: [44, 0],
    msPerFrame: 1000 / 3
  },
  RUNNING: {
    frames: [88, 132],
    msPerFrame: 1000 / 12
  },
  CRASHED: {
    frames: [220],
    msPerFrame: 1000 / 60
  },
  JUMPING: {
    frames: [0],
    msPerFrame: 1000 / 60
  },
  DUCKING: {
    frames: [264, 323],
    msPerFrame: 1000 / 8
  }
}

Trex.prototype = {
  /**
   * T-rex player initaliser.
   * Sets the t-rex to blink at random intervals.
   */
  init () {
    this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
      Runner.config.BOTTOM_PAD
    this.yPos = this.groundYPos
    this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT

    this.draw(0, 0)
    this.update(0, Trex.status.WAITING)
  },

  /**
   * Assign the appropriate jump parameters based on the game speed.
   */
  enableSlowConfig: function () {
    const jumpConfig =
      Runner.slowDown ? Trex.slowJumpConfig : Trex.normalJumpConfig
    Trex.config = Object.assign(Trex.config, jumpConfig)

    this.adjustAltGameConfigForSlowSpeed()
  },

  /**
   * Enables the alternative game. Redefines the dino config.
   * @param {Object} spritePos New positioning within image sprite.
   */
  enableAltGameMode: function (spritePos) {
    this.altGameModeEnabled = true
    this.spritePos = spritePos
    const spriteDefinition = Runner.spriteDefinition.TREX

    // Update animation frames.
    Trex.animFrames.RUNNING.frames =
      [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x]
    Trex.animFrames.CRASHED.frames = [spriteDefinition.CRASHED.x]

    if (typeof spriteDefinition.JUMPING.x === 'object') {
      Trex.animFrames.JUMPING.frames = spriteDefinition.JUMPING.x
    } else {
      Trex.animFrames.JUMPING.frames = [spriteDefinition.JUMPING.x]
    }

    Trex.animFrames.DUCKING.frames =
      [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x]

    // Update Trex config
    Trex.config.GRAVITY = spriteDefinition.GRAVITY || Trex.config.GRAVITY
    Trex.config.HEIGHT = spriteDefinition.RUNNING_1.h,
    Trex.config.INITIAL_JUMP_VELOCITY = spriteDefinition.INITIAL_JUMP_VELOCITY
    Trex.config.MAX_JUMP_HEIGHT = spriteDefinition.MAX_JUMP_HEIGHT
    Trex.config.MIN_JUMP_HEIGHT = spriteDefinition.MIN_JUMP_HEIGHT
    Trex.config.WIDTH = spriteDefinition.RUNNING_1.w
    Trex.config.WIDTH_JUMP = spriteDefinition.JUMPING.w
    Trex.config.INVERT_JUMP = spriteDefinition.INVERT_JUMP

    this.adjustAltGameConfigForSlowSpeed(spriteDefinition.GRAVITY)
    this.config = Trex.config

    // Adjust bottom horizon placement.
    this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
      Runner.spriteDefinition.BOTTOM_PAD
    this.yPos = this.groundYPos
    this.reset()
  },

  /**
   * Slow speeds adjustments for the alt game modes.
   * @param {number=} opt_gravityValue
   */
  adjustAltGameConfigForSlowSpeed: function (opt_gravityValue) {
    if (Runner.slowDown) {
      if (opt_gravityValue) {
        Trex.config.GRAVITY = opt_gravityValue / 1.5
      }
      Trex.config.MIN_JUMP_HEIGHT *= 1.5
      Trex.config.MAX_JUMP_HEIGHT *= 1.5
      Trex.config.INITIAL_JUMP_VELOCITY =
        Trex.config.INITIAL_JUMP_VELOCITY * 1.5
    }
  },

  /**
   * Setter whether dino is flashing.
   * @param {boolean} status
   */
  setFlashing: function (status) {
    this.flashing = status
  },

  /**
   * Setter for the jump velocity.
   * The approriate drop velocity is also set.
   * @param {number} setting
   */
  setJumpVelocity (setting) {
    this.config.INITIAL_JUMP_VELOCITY = -setting
    this.config.DROP_VELOCITY = -setting / 2
  },

  /**
   * Set the animation status.
   * @param {!number} deltaTime
   * @param {Trex.status=} opt_status Optional status to switch to.
   */
  update (deltaTime, opt_status) {
    this.timer += deltaTime

    // Update the status.
    if (opt_status) {
      this.status = opt_status
      this.currentFrame = 0
      this.msPerFrame = Trex.animFrames[opt_status].msPerFrame
      this.currentAnimFrames = Trex.animFrames[opt_status].frames

      if (opt_status === Trex.status.WAITING) {
        this.animStartTime = getTimeStamp()
        this.setBlinkDelay()
      }
    }
    // Game intro animation, T-rex moves in from the left.
    if (this.playingIntro && this.xPos < this.config.START_X_POS) {
      this.xPos += Math.round((this.config.START_X_POS /
        this.config.INTRO_DURATION) * deltaTime)
      this.xInitialPos = this.xPos
    }

    if (this.status === Trex.status.WAITING) {
      this.blink(getTimeStamp())
    } else {
      this.draw(this.currentAnimFrames[this.currentFrame], 0)
    }

    // Update the frame position.
    if (!this.flashing && this.timer >= this.msPerFrame) {
      this.currentFrame = this.currentFrame ==
      this.currentAnimFrames.length - 1
        ? 0
        : this.currentFrame + 1
      this.timer = 0
    }

    if (!this.altGameModeEnabled) {
      // Speed drop becomes duck if the down key is still being pressed.
      if (this.speedDrop && this.yPos === this.groundYPos) {
        this.speedDrop = false
        this.setDuck(true)
      }
    }
  },

  /**
   * Draw the t-rex to a particular position.
   * @param {number} x
   * @param {number} y
   */
  draw (x, y) {
    let sourceX = x
    let sourceY = y
    let sourceWidth = this.ducking && this.status !== Trex.status.CRASHED
      ? this.config.WIDTH_DUCK
      : this.config.WIDTH
    let sourceHeight = this.config.HEIGHT
    const outputHeight = sourceHeight

    let jumpOffset = Runner.spriteDefinition.TREX.JUMPING.xOffset

    // Width of sprite changes on jump.
    if (this.altGameModeEnabled && this.jumping &&
      this.status !== Trex.status.CRASHED) {
      sourceWidth = this.config.WIDTH_JUMP
    }

    if (IS_HIDPI) {
      sourceX *= 2
      sourceY *= 2
      sourceWidth *= 2
      sourceHeight *= 2
      jumpOffset *= 2
    }

    // Adjustments for sprite sheet position.
    sourceX += this.spritePos.x
    sourceY += this.spritePos.y

    // Flashing.
    if (this.flashing) {
      if (this.timer < this.config.FLASH_ON) {
        this.canvasCtx.globalAlpha = 0.5
      } else if (this.timer > this.config.FLASH_OFF) {
        this.timer = 0
      }
    }

    // Ducking.
    if (!this.altGameModeEnabled && this.ducking &&
      this.status !== Trex.status.CRASHED) {
      this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
        sourceWidth, sourceHeight,
        this.xPos, this.yPos,
        this.config.WIDTH_DUCK, outputHeight)
    } else if (
      this.altGameModeEnabled && this.jumping &&
      this.status !== Trex.status.CRASHED) {
      // Jumping with adjustments.
      this.canvasCtx.drawImage(
        Runner.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight,
        this.xPos - jumpOffset, this.yPos, this.config.WIDTH_JUMP,
        outputHeight)
    } else {
      // Crashed whilst ducking. Trex is standing up so needs adjustment.
      if (this.ducking && this.status === Trex.status.CRASHED) {
        this.xPos++
      }
      // Standing / running
      this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
        sourceWidth, sourceHeight,
        this.xPos, this.yPos,
        this.config.WIDTH, outputHeight)
    }
    this.canvasCtx.globalAlpha = 1
  },

  /**
   * Sets a random time for the blink to happen.
   */
  setBlinkDelay () {
    this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING)
  },

  /**
   * Make t-rex blink at random intervals.
   * @param {number} time Current time in milliseconds.
   */
  blink (time) {
    const deltaTime = time - this.animStartTime

    if (deltaTime >= this.blinkDelay) {
      this.draw(this.currentAnimFrames[this.currentFrame], 0)

      if (this.currentFrame === 1) {
        // Set new random delay to blink.
        this.setBlinkDelay()
        this.animStartTime = time
        this.blinkCount++
      }
    }
  },

  /**
   * Initialise a jump.
   * @param {number} speed
   */
  startJump (speed) {
    if (!this.jumping) {
      this.update(0, Trex.status.JUMPING)
      // Tweak the jump velocity based on the speed.
      this.jumpVelocity = this.config.INITIAL_JUMP_VELOCITY - (speed / 10)
      this.jumping = true
      this.reachedMinHeight = false
      this.speedDrop = false

      if (this.config.INVERT_JUMP) {
        this.minJumpHeight = this.groundYPos + this.config.MIN_JUMP_HEIGHT
      }
    }
  },

  /**
   * Jump is complete, falling down.
   */
  endJump () {
    if (this.reachedMinHeight &&
      this.jumpVelocity < this.config.DROP_VELOCITY) {
      this.jumpVelocity = this.config.DROP_VELOCITY
    }
  },

  /**
   * Update frame for a jump.
   * @param {number} deltaTime
   */
  updateJump (deltaTime) {
    const msPerFrame = Trex.animFrames[this.status].msPerFrame
    const framesElapsed = deltaTime / msPerFrame

    // Speed drop makes Trex fall faster.
    if (this.speedDrop) {
      this.yPos += Math.round(this.jumpVelocity *
        this.config.SPEED_DROP_COEFFICIENT * framesElapsed)
    } else if (this.config.INVERT_JUMP) {
      this.yPos -= Math.round(this.jumpVelocity * framesElapsed)
    } else {
      this.yPos += Math.round(this.jumpVelocity * framesElapsed)
    }

    this.jumpVelocity += this.config.GRAVITY * framesElapsed

    // Minimum height has been reached.
    if (this.config.INVERT_JUMP && (this.yPos > this.minJumpHeight) ||
      !this.config.INVERT_JUMP && (this.yPos < this.minJumpHeight) ||
      this.speedDrop) {
      this.reachedMinHeight = true
    }

    // Reached max height.
    if (this.config.INVERT_JUMP && (this.yPos > -this.config.MAX_JUMP_HEIGHT) ||
      !this.config.INVERT_JUMP && (this.yPos < this.config.MAX_JUMP_HEIGHT) ||
      this.speedDrop) {
      this.endJump()
    }

    // Back down at ground level. Jump completed.
    if ((this.config.INVERT_JUMP && this.yPos) < this.groundYPos ||
      (!this.config.INVERT_JUMP && this.yPos) > this.groundYPos) {
      this.reset()
      this.jumpCount++

      if (Runner.audioCues) {
        Runner.generatedSoundFx.loopFootSteps()
      }
    }
  },

  /**
   * Set the speed drop. Immediately cancels the current jump.
   */
  setSpeedDrop () {
    this.speedDrop = true
    this.jumpVelocity = 1
  },

  /**
   * @param {boolean} isDucking
   */
  setDuck (isDucking) {
    if (isDucking && this.status !== Trex.status.DUCKING) {
      this.update(0, Trex.status.DUCKING)
      this.ducking = true
    } else if (this.status === Trex.status.DUCKING) {
      this.update(0, Trex.status.RUNNING)
      this.ducking = false
    }
  },

  /**
   * Reset the t-rex to running at start of game.
   */
  reset () {
    this.xPos = this.xInitialPos
    this.yPos = this.groundYPos
    this.jumpVelocity = 0
    this.jumping = false
    this.ducking = false
    this.update(0, Trex.status.RUNNING)
    this.midair = false
    this.speedDrop = false
    this.jumpCount = 0
  }
}

//* *****************************************************************************

/**
 * Handles displaying the distance meter.
 * @param {!HTMLCanvasElement} canvas
 * @param {Object} spritePos Image position in sprite.
 * @param {number} canvasWidth
 * @constructor
 */
function DistanceMeter (canvas, spritePos, canvasWidth) {
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'))
  this.image = Runner.imageSprite
  this.spritePos = spritePos
  this.x = 0
  this.y = 5

  this.currentDistance = 0
  this.maxScore = 0
  this.highScore = '0'
  this.container = null

  this.digits = []
  this.achievement = false
  this.defaultString = ''
  this.flashTimer = 0
  this.flashIterations = 0
  this.invertTrigger = false
  this.flashingRafId = null
  this.highScoreBounds = {}
  this.highScoreFlashing = false

  this.config = DistanceMeter.config
  this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS
  this.canvasWidth = canvasWidth
  this.init(canvasWidth)
}

/**
 * @enum {number}
 */
DistanceMeter.dimensions = {
  WIDTH: 10,
  HEIGHT: 13,
  DEST_WIDTH: 11
}

/**
 * Y positioning of the digits in the sprite sheet.
 * X position is always 0.
 * @type {Array<number>}
 */
DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120]

/**
 * Distance meter config.
 * @enum {number}
 */
DistanceMeter.config = {
  // Number of digits.
  MAX_DISTANCE_UNITS: 5,

  // Distance that causes achievement animation.
  ACHIEVEMENT_DISTANCE: 100,

  // Used for conversion from pixel distance to a scaled unit.
  COEFFICIENT: 0.025,

  // Flash duration in milliseconds.
  FLASH_DURATION: 1000 / 4,

  // Flash iterations for achievement animation.
  FLASH_ITERATIONS: 3,

  // Padding around the high score hit area.
  HIGH_SCORE_HIT_AREA_PADDING: 4
}

DistanceMeter.prototype = {
  /**
   * Initialise the distance meter to '00000'.
   * @param {number} width Canvas width in px.
   */
  init (width) {
    let maxDistanceStr = ''

    this.calcXPos(width)
    this.maxScore = this.maxScoreUnits
    for (let i = 0; i < this.maxScoreUnits; i++) {
      this.draw(i, 0)
      this.defaultString += '0'
      maxDistanceStr += '9'
    }

    this.maxScore = parseInt(maxDistanceStr, 10)
  },

  /**
   * Calculate the xPos in the canvas.
   * @param {number} canvasWidth
   */
  calcXPos (canvasWidth) {
    this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *
      (this.maxScoreUnits + 1))
  },

  /**
   * Draw a digit to canvas.
   * @param {number} digitPos Position of the digit.
   * @param {number} value Digit value 0-9.
   * @param {boolean=} opt_highScore Whether drawing the high score.
   */
  draw (digitPos, value, opt_highScore) {
    let sourceWidth = DistanceMeter.dimensions.WIDTH
    let sourceHeight = DistanceMeter.dimensions.HEIGHT
    let sourceX = DistanceMeter.dimensions.WIDTH * value
    let sourceY = 0

    const targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH
    const targetY = this.y
    const targetWidth = DistanceMeter.dimensions.WIDTH
    const targetHeight = DistanceMeter.dimensions.HEIGHT

    // For high DPI we 2x source values.
    if (IS_HIDPI) {
      sourceWidth *= 2
      sourceHeight *= 2
      sourceX *= 2
    }

    sourceX += this.spritePos.x
    sourceY += this.spritePos.y

    this.canvasCtx.save()

    if (IS_RTL) {
      if (opt_highScore) {
        this.canvasCtx.translate(
          this.canvasWidth -
          (DistanceMeter.dimensions.WIDTH * (this.maxScoreUnits + 3)),
          this.y)
      } else {
        this.canvasCtx.translate(
          this.canvasWidth - DistanceMeter.dimensions.WIDTH, this.y)
      }
      this.canvasCtx.scale(-1, 1)
    } else {
      const highScoreX =
        this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH
      if (opt_highScore) {
        this.canvasCtx.translate(highScoreX, this.y)
      } else {
        this.canvasCtx.translate(this.x, this.y)
      }
    }

    this.canvasCtx.drawImage(
      this.image,
      sourceX,
      sourceY,
      sourceWidth,
      sourceHeight,
      targetX,
      targetY,
      targetWidth,
      targetHeight
    )

    this.canvasCtx.restore()
  },

  /**
   * Covert pixel distance to a 'real' distance.
   * @param {number} distance Pixel distance ran.
   * @return {number} The 'real' distance ran.
   */
  getActualDistance (distance) {
    return distance ? Math.round(distance * this.config.COEFFICIENT) : 0
  },

  /**
   * Update the distance meter.
   * @param {number} distance
   * @param {number} deltaTime
   * @return {boolean} Whether the acheivement sound fx should be played.
   */
  update (deltaTime, distance) {
    let paint = true
    let playSound = false

    if (!this.achievement) {
      distance = this.getActualDistance(distance)
      // Score has gone beyond the initial digit count.
      if (distance > this.maxScore && this.maxScoreUnits ==
        this.config.MAX_DISTANCE_UNITS) {
        this.maxScoreUnits++
        this.maxScore = parseInt(this.maxScore + '9', 10)
      } else {
        this.distance = 0
      }

      if (distance > 0) {
        // Achievement unlocked.
        if (distance % this.config.ACHIEVEMENT_DISTANCE === 0) {
          // Flash score and play sound.
          this.achievement = true
          this.flashTimer = 0
          playSound = true
        }

        // Create a string representation of the distance with leading 0.
        const distanceStr = (this.defaultString +
          distance).substr(-this.maxScoreUnits)
        this.digits = distanceStr.split('')
      } else {
        this.digits = this.defaultString.split('')
      }
    } else {
      // Control flashing of the score on reaching acheivement.
      if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
        this.flashTimer += deltaTime

        if (this.flashTimer < this.config.FLASH_DURATION) {
          paint = false
        } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
          this.flashTimer = 0
          this.flashIterations++
        }
      } else {
        this.achievement = false
        this.flashIterations = 0
        this.flashTimer = 0
      }
    }

    // Draw the digits if not flashing.
    if (paint) {
      for (let i = this.digits.length - 1; i >= 0; i--) {
        this.draw(i, parseInt(this.digits[i], 10))
      }
    }

    this.drawHighScore()
    return playSound
  },

  /**
   * Draw the high score.
   */
  drawHighScore () {
    if (parseInt(this.highScore, 10) > 0) {
      this.canvasCtx.save()
      this.canvasCtx.globalAlpha = 0.8
      for (let i = this.highScore.length - 1; i >= 0; i--) {
        this.draw(i, parseInt(this.highScore[i], 10), true)
      }
      this.canvasCtx.restore()
    }
  },

  /**
   * Set the highscore as a array string.
   * Position of char in the sprite: H - 10, I - 11.
   * @param {number} distance Distance ran in pixels.
   */
  setHighScore (distance) {
    distance = this.getActualDistance(distance)
    const highScoreStr = (this.defaultString +
      distance).substr(-this.maxScoreUnits)

    this.highScore = ['10', '11', ''].concat(highScoreStr.split(''))
  },

  /**
   * Whether a clicked is in the high score area.
   * @param {Event} e Event object.
   * @return {boolean} Whether the click was in the high score bounds.
   */
  hasClickedOnHighScore (e) {
    let x = 0
    let y = 0

    if (e.touches) {
      // Bounds for touch differ from pointer.
      const canvasBounds = this.canvas.getBoundingClientRect()
      x = e.touches[0].clientX - canvasBounds.left
      y = e.touches[0].clientY - canvasBounds.top
    } else {
      x = e.offsetX
      y = e.offsetY
    }

    this.highScoreBounds = this.getHighScoreBounds()
    return x >= this.highScoreBounds.x && x <=
      this.highScoreBounds.x + this.highScoreBounds.width &&
      y >= this.highScoreBounds.y && y <=
      this.highScoreBounds.y + this.highScoreBounds.height
  },

  /**
   * Get the bounding box for the high score.
   * @return {Object} Object with x, y, width and height properties.
   */
  getHighScoreBounds () {
    return {
      x: (this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH) -
        DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
      y: this.y,
      width: DistanceMeter.dimensions.WIDTH * (this.highScore.length + 1) +
        DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
      height: DistanceMeter.dimensions.HEIGHT +
        (DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING * 2)
    }
  },

  /**
   * Animate flashing the high score to indicate ready for resetting.
   * The flashing stops following this.config.FLASH_ITERATIONS x 2 flashes.
   */
  flashHighScore () {
    const now = getTimeStamp()
    const deltaTime = now - (this.frameTimeStamp || now)
    let paint = true
    this.frameTimeStamp = now

    // Reached the max number of flashes.
    if (this.flashIterations > this.config.FLASH_ITERATIONS * 2) {
      this.cancelHighScoreFlashing()
      return
    }

    this.flashTimer += deltaTime

    if (this.flashTimer < this.config.FLASH_DURATION) {
      paint = false
    } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
      this.flashTimer = 0
      this.flashIterations++
    }

    if (paint) {
      this.drawHighScore()
    } else {
      this.clearHighScoreBounds()
    }
    // Frame update.
    this.flashingRafId =
      requestAnimationFrame(this.flashHighScore.bind(this))
  },

  /**
   * Draw empty rectangle over high score.
   */
  clearHighScoreBounds () {
    this.canvasCtx.save()
    this.canvasCtx.fillStyle = '#fff'
    this.canvasCtx.rect(this.highScoreBounds.x, this.highScoreBounds.y,
      this.highScoreBounds.width, this.highScoreBounds.height)
    this.canvasCtx.fill()
    this.canvasCtx.restore()
  },

  /**
   * Starts the flashing of the high score.
   */
  startHighScoreFlashing () {
    this.highScoreFlashing = true
    this.flashHighScore()
  },

  /**
   * Whether high score is flashing.
   * @return {boolean}
   */
  isHighScoreFlashing () {
    return this.highScoreFlashing
  },

  /**
   * Stop flashing the high score.
   */
  cancelHighScoreFlashing () {
    if (this.flashingRafId) {
      cancelAnimationFrame(this.flashingRafId)
    }
    this.flashIterations = 0
    this.flashTimer = 0
    this.highScoreFlashing = false
    this.clearHighScoreBounds()
    this.drawHighScore()
  },

  /**
   * Clear the high score.
   */
  resetHighScore () {
    this.setHighScore(0)
    this.cancelHighScoreFlashing()
  },

  /**
   * Reset the distance meter back to '00000'.
   */
  reset () {
    this.update(0, 0)
    this.achievement = false
  }
}

//* *****************************************************************************

/**
 * Cloud background item.
 * Similar to an obstacle object but without collision boxes.
 * @param {HTMLCanvasElement} canvas Canvas element.
 * @param {Object} spritePos Position of image in sprite.
 * @param {number} containerWidth
 * @constructor
 */
function Cloud (canvas, spritePos, containerWidth) {
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'))
  this.spritePos = spritePos
  this.containerWidth = containerWidth
  this.xPos = containerWidth
  this.yPos = 0
  this.remove = false
  this.gap =
    getRandomNum(Cloud.config.MIN_CLOUD_GAP, Cloud.config.MAX_CLOUD_GAP)

  this.init()
}

/**
 * Cloud object config.
 * @enum {number}
 */
Cloud.config = {
  HEIGHT: 14,
  MAX_CLOUD_GAP: 400,
  MAX_SKY_LEVEL: 30,
  MIN_CLOUD_GAP: 100,
  MIN_SKY_LEVEL: 71,
  WIDTH: 46
}

Cloud.prototype = {
  /**
   * Initialise the cloud. Sets the Cloud height.
   */
  init () {
    this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,
      Cloud.config.MIN_SKY_LEVEL)
    this.draw()
  },

  /**
   * Draw the cloud.
   */
  draw () {
    this.canvasCtx.save()
    let sourceWidth = Cloud.config.WIDTH
    let sourceHeight = Cloud.config.HEIGHT
    const outputWidth = sourceWidth
    const outputHeight = sourceHeight
    if (IS_HIDPI) {
      sourceWidth = sourceWidth * 2
      sourceHeight = sourceHeight * 2
    }

    this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,
      this.spritePos.y,
      sourceWidth, sourceHeight,
      this.xPos, this.yPos,
      outputWidth, outputHeight)

    this.canvasCtx.restore()
  },

  /**
   * Update the cloud position.
   * @param {number} speed
   */
  update (speed) {
    if (!this.remove) {
      this.xPos -= Math.ceil(speed)
      this.draw()

      // Mark as removeable if no longer in the canvas.
      if (!this.isVisible()) {
        this.remove = true
      }
    }
  },

  /**
   * Check if the cloud is visible on the stage.
   * @return {boolean}
   */
  isVisible () {
    return this.xPos + Cloud.config.WIDTH > 0
  }
}

/**
 * Background item.
 * Similar to cloud, without random y position.
 * @param {HTMLCanvasElement} canvas Canvas element.
 * @param {Object} spritePos Position of image in sprite.
 * @param {number} containerWidth
 * @param {string} type Element type.
 * @constructor
 */
function BackgroundEl (canvas, spritePos, containerWidth, type) {
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'))
  this.spritePos = spritePos
  this.containerWidth = containerWidth
  this.xPos = containerWidth
  this.yPos = 0
  this.remove = false
  this.type = type
  this.gap =
    getRandomNum(BackgroundEl.config.MIN_GAP, BackgroundEl.config.MAX_GAP)
  this.animTimer = 0
  this.switchFrames = false

  this.spriteConfig = {}
  this.init()
}

/**
 * Background element object config.
 * Real values assigned when game type changes.
 * @enum {number}
 */
BackgroundEl.config = {
  MAX_BG_ELS: 0,
  MAX_GAP: 0,
  MIN_GAP: 0,
  POS: 0,
  SPEED: 0,
  Y_POS: 0,
  MS_PER_FRAME: 0 // only needed when BACKGROUND_EL.FIXED is true
}

BackgroundEl.prototype = {
  /**
   * Initialise the element setting the y position.
   */
  init () {
    this.spriteConfig = Runner.spriteDefinition.BACKGROUND_EL[this.type]
    if (this.spriteConfig.FIXED) {
      this.xPos = this.spriteConfig.FIXED_X_POS
    }
    this.yPos = BackgroundEl.config.Y_POS - this.spriteConfig.HEIGHT +
      this.spriteConfig.OFFSET
    this.draw()
  },

  /**
   * Draw the element.
   */
  draw () {
    this.canvasCtx.save()
    let sourceWidth = this.spriteConfig.WIDTH
    let sourceHeight = this.spriteConfig.HEIGHT
    let sourceX = this.spriteConfig.X_POS
    const outputWidth = sourceWidth
    const outputHeight = sourceHeight

    if (IS_HIDPI) {
      sourceWidth *= 2
      sourceHeight *= 2
      sourceX *= 2
    }

    this.canvasCtx.drawImage(
      Runner.imageSprite, sourceX, this.spritePos.y, sourceWidth,
      sourceHeight, this.xPos, this.yPos, outputWidth, outputHeight)

    this.canvasCtx.restore()
  },

  /**
   * Update the background element position.
   * @param {number} speed
   */
  update (speed) {
    if (!this.remove) {
      if (this.spriteConfig.FIXED) {
        this.animTimer += speed
        if (this.animTimer > BackgroundEl.config.MS_PER_FRAME) {
          this.animTimer = 0
          this.switchFrames = !this.switchFrames
        }

        if (this.spriteConfig.FIXED_Y_POS_1 &&
          this.spriteConfig.FIXED_Y_POS_2) {
          this.yPos = this.switchFrames
            ? this.spriteConfig.FIXED_Y_POS_1
            : this.spriteConfig.FIXED_Y_POS_2
        }
      } else {
        // Fixed speed, regardless of actual game speed.
        this.xPos -= BackgroundEl.config.SPEED
      }
      this.draw()

      // Mark as removable if no longer in the canvas.
      if (!this.isVisible()) {
        this.remove = true
      }
    }
  },

  /**
   * Check if the element is visible on the stage.
   * @return {boolean}
   */
  isVisible () {
    return this.xPos + this.spriteConfig.WIDTH > 0
  }
}

//* *****************************************************************************

/**
 * Nightmode shows a moon and stars on the horizon.
 * @param {HTMLCanvasElement} canvas
 * @param {number} spritePos
 * @param {number} containerWidth
 * @constructor
 */
function NightMode (canvas, spritePos, containerWidth) {
  this.spritePos = spritePos
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'))
  this.xPos = containerWidth - 50
  this.yPos = 30
  this.currentPhase = 0
  this.opacity = 0
  this.containerWidth = containerWidth
  this.stars = []
  this.drawStars = false
  this.placeStars()
}

/**
 * @enum {number}
 */
NightMode.config = {
  FADE_SPEED: 0.035,
  HEIGHT: 40,
  MOON_SPEED: 0.25,
  NUM_STARS: 2,
  STAR_SIZE: 9,
  STAR_SPEED: 0.3,
  STAR_MAX_Y: 70,
  WIDTH: 20
}

NightMode.phases = [140, 120, 100, 60, 40, 20, 0]

NightMode.prototype = {
  /**
   * Update moving moon, changing phases.
   * @param {boolean} activated Whether night mode is activated.
   */
  update (activated) {
    // Moon phase.
    if (activated && this.opacity === 0) {
      this.currentPhase++

      if (this.currentPhase >= NightMode.phases.length) {
        this.currentPhase = 0
      }
    }

    // Fade in / out.
    if (activated && (this.opacity < 1 || this.opacity === 0)) {
      this.opacity += NightMode.config.FADE_SPEED
    } else if (this.opacity > 0) {
      this.opacity -= NightMode.config.FADE_SPEED
    }

    // Set moon positioning.
    if (this.opacity > 0) {
      this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED)

      // Update stars.
      if (this.drawStars) {
        for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
          this.stars[i].x =
            this.updateXPos(this.stars[i].x, NightMode.config.STAR_SPEED)
        }
      }
      this.draw()
    } else {
      this.opacity = 0
      this.placeStars()
    }
    this.drawStars = true
  },

  updateXPos (currentPos, speed) {
    if (currentPos < -NightMode.config.WIDTH) {
      currentPos = this.containerWidth
    } else {
      currentPos -= speed
    }
    return currentPos
  },

  draw () {
    let moonSourceWidth = this.currentPhase === 3
      ? NightMode.config.WIDTH * 2
      : NightMode.config.WIDTH
    let moonSourceHeight = NightMode.config.HEIGHT
    let moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase]
    const moonOutputWidth = moonSourceWidth
    let starSize = NightMode.config.STAR_SIZE
    let starSourceX = Runner.spriteDefinitionByType.original.LDPI.STAR.x

    if (IS_HIDPI) {
      moonSourceWidth *= 2
      moonSourceHeight *= 2
      moonSourceX = this.spritePos.x +
        (NightMode.phases[this.currentPhase] * 2)
      starSize *= 2
      starSourceX = Runner.spriteDefinitionByType.original.HDPI.STAR.x
    }

    this.canvasCtx.save()
    this.canvasCtx.globalAlpha = this.opacity

    // Stars.
    if (this.drawStars) {
      for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
        this.canvasCtx.drawImage(
          Runner.origImageSprite, starSourceX, this.stars[i].sourceY,
          starSize, starSize, Math.round(this.stars[i].x), this.stars[i].y,
          NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE)
      }
    }

    // Moon.
    this.canvasCtx.drawImage(
      Runner.origImageSprite, moonSourceX, this.spritePos.y, moonSourceWidth,
      moonSourceHeight, Math.round(this.xPos), this.yPos, moonOutputWidth,
      NightMode.config.HEIGHT)

    this.canvasCtx.globalAlpha = 1
    this.canvasCtx.restore()
  },

  // Do star placement.
  placeStars () {
    const segmentSize = Math.round(this.containerWidth /
      NightMode.config.NUM_STARS)

    for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
      this.stars[i] = {}
      this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1))
      this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y)

      if (IS_HIDPI) {
        this.stars[i].sourceY =
          Runner.spriteDefinitionByType.original.HDPI.STAR.y +
          NightMode.config.STAR_SIZE * 2 * i
      } else {
        this.stars[i].sourceY =
          Runner.spriteDefinitionByType.original.LDPI.STAR.y +
          NightMode.config.STAR_SIZE * i
      }
    }
  },

  reset () {
    this.currentPhase = 0
    this.opacity = 0
    this.update(false)
  }

}

//* *****************************************************************************

/**
 * Horizon Line.
 * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.
 * @param {HTMLCanvasElement} canvas
 * @param {Object} lineConfig Configuration object.
 * @constructor
 */
function HorizonLine (canvas, lineConfig) {
  let sourceX = lineConfig.SOURCE_X
  let sourceY = lineConfig.SOURCE_Y

  if (IS_HIDPI) {
    sourceX *= 2
    sourceY *= 2
  }

  this.spritePos = { x: sourceX, y: sourceY }
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'))
  this.sourceDimensions = {}
  this.dimensions = lineConfig

  this.sourceXPos = [this.spritePos.x, this.spritePos.x +
  this.dimensions.WIDTH]
  this.xPos = []
  this.yPos = 0
  this.bumpThreshold = 0.5

  this.setSourceDimensions(lineConfig)
  this.draw()
}

/**
 * Horizon line dimensions.
 * @enum {number}
 */
HorizonLine.dimensions = {
  WIDTH: 600,
  HEIGHT: 12,
  YPOS: 127
}

HorizonLine.prototype = {
  /**
   * Set the source dimensions of the horizon line.
   */
  setSourceDimensions (newDimensions) {
    for (const dimension in newDimensions) {
      if (dimension !== 'SOURCE_X' && dimension !== 'SOURCE_Y') {
        if (IS_HIDPI) {
          if (dimension !== 'YPOS') {
            this.sourceDimensions[dimension] = newDimensions[dimension] * 2
          }
        } else {
          this.sourceDimensions[dimension] = newDimensions[dimension]
        }
        this.dimensions[dimension] = newDimensions[dimension]
      }
    }

    this.xPos = [0, newDimensions.WIDTH]
    this.yPos = newDimensions.YPOS
  },

  /**
   * Return the crop x position of a type.
   */
  getRandomType () {
    return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0
  },

  /**
   * Draw the horizon line.
   */
  draw () {
    this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],
      this.spritePos.y,
      this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
      this.xPos[0], this.yPos,
      this.dimensions.WIDTH, this.dimensions.HEIGHT)

    this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],
      this.spritePos.y,
      this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
      this.xPos[1], this.yPos,
      this.dimensions.WIDTH, this.dimensions.HEIGHT)
  },

  /**
   * Update the x position of an indivdual piece of the line.
   * @param {number} pos Line position.
   * @param {number} increment
   */
  updateXPos (pos, increment) {
    const line1 = pos
    const line2 = pos === 0 ? 1 : 0

    this.xPos[line1] -= increment
    this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH

    if (this.xPos[line1] <= -this.dimensions.WIDTH) {
      this.xPos[line1] += this.dimensions.WIDTH * 2
      this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH
      this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x
    }
  },

  /**
   * Update the horizon line.
   * @param {number} deltaTime
   * @param {number} speed
   */
  update (deltaTime, speed) {
    const increment = Math.floor(speed * (FPS / 1000) * deltaTime)

    if (this.xPos[0] <= 0) {
      this.updateXPos(0, increment)
    } else {
      this.updateXPos(1, increment)
    }
    this.draw()
  },

  /**
   * Reset horizon to the starting position.
   */
  reset () {
    this.xPos[0] = 0
    this.xPos[1] = this.dimensions.WIDTH
  }
}

//* *****************************************************************************

/**
 * Horizon background class.
 * @param {HTMLCanvasElement} canvas
 * @param {Object} spritePos Sprite positioning.
 * @param {Object} dimensions Canvas dimensions.
 * @param {number} gapCoefficient
 * @constructor
 */
function Horizon (canvas, spritePos, dimensions, gapCoefficient) {
  this.canvas = canvas
  this.canvasCtx =
    /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'))
  this.config = Horizon.config
  this.dimensions = dimensions
  this.gapCoefficient = gapCoefficient
  this.obstacles = []
  this.obstacleHistory = []
  this.horizonOffsets = [0, 0]
  this.cloudFrequency = this.config.CLOUD_FREQUENCY
  this.spritePos = spritePos
  this.nightMode = null
  this.altGameModeActive = false

  // Cloud
  this.clouds = []
  this.cloudSpeed = this.config.BG_CLOUD_SPEED

  // Background elements
  this.backgroundEls = []
  this.lastEl = null
  this.backgroundSpeed = this.config.BG_CLOUD_SPEED

  // Horizon
  this.horizonLine = null
  this.horizonLines = []
  this.init()
}

/**
 * Horizon config.
 * @enum {number}
 */
Horizon.config = {
  BG_CLOUD_SPEED: 0.2,
  BUMPY_THRESHOLD: 0.3,
  CLOUD_FREQUENCY: 0.5,
  HORIZON_HEIGHT: 16,
  MAX_CLOUDS: 6
}

Horizon.prototype = {
  /**
   * Initialise the horizon. Just add the line and a cloud. No obstacles.
   */
  init () {
    Obstacle.types = Runner.spriteDefinitionByType.original.OBSTACLES
    this.addCloud()
    // Multiple Horizon lines
    for (let i = 0; i < Runner.spriteDefinition.LINES.length; i++) {
      this.horizonLines.push(
        new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]))
    }

    this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,
      this.dimensions.WIDTH)
  },

  /**
   * Update obstacle definitions based on the speed of the game.
   */
  adjustObstacleSpeed: function () {
    for (let i = 0; i < Obstacle.types.length; i++) {
      if (Runner.slowDown) {
        Obstacle.types[i].multipleSpeed = Obstacle.types[i].multipleSpeed / 2
        Obstacle.types[i].minGap *= 1.5
        Obstacle.types[i].minSpeed = Obstacle.types[i].minSpeed / 2

        // Convert variable y position obstacles to fixed.
        if (typeof (Obstacle.types[i].yPos) === 'object') {
          Obstacle.types[i].yPos = Obstacle.types[i].yPos[0]
          Obstacle.types[i].yPosMobile = Obstacle.types[i].yPos[0]
        }
      }
    }
  },

  /**
   * Update sprites to correspond to change in sprite sheet.
   * @param {number} spritePos
   */
  enableAltGameMode: function (spritePos) {
    // Clear existing horizon objects.
    this.clouds = []
    this.backgroundEls = []

    this.altGameModeActive = true
    this.spritePos = spritePos

    Obstacle.types = Runner.spriteDefinition.OBSTACLES
    this.adjustObstacleSpeed()

    Obstacle.MAX_GAP_COEFFICIENT = Runner.spriteDefinition.MAX_GAP_COEFFICIENT
    Obstacle.MAX_OBSTACLE_LENGTH = Runner.spriteDefinition.MAX_OBSTACLE_LENGTH

    BackgroundEl.config = Runner.spriteDefinition.BACKGROUND_EL_CONFIG

    this.horizonLines = []
    for (let i = 0; i < Runner.spriteDefinition.LINES.length; i++) {
      this.horizonLines.push(
        new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]))
    }
    this.reset()
  },

  /**
   * @param {number} deltaTime
   * @param {number} currentSpeed
   * @param {boolean} updateObstacles Used as an override to prevent
   *     the obstacles from being updated / added. This happens in the
   *     ease in section.
   * @param {boolean} showNightMode Night mode activated.
   */
  update (deltaTime, currentSpeed, updateObstacles, showNightMode) {
    this.runningTime += deltaTime

    if (this.altGameModeActive) {
      this.updateBackgroundEls(deltaTime, currentSpeed)
    }

    for (let i = 0; i < this.horizonLines.length; i++) {
      this.horizonLines[i].update(deltaTime, currentSpeed)
    }

    if (!this.altGameModeActive || Runner.spriteDefinition.HAS_CLOUDS) {
      this.nightMode.update(showNightMode)
      this.updateClouds(deltaTime, currentSpeed)
    }

    if (updateObstacles) {
      this.updateObstacles(deltaTime, currentSpeed)
    }
  },

  /**
   * Update background element positions. Also handles creating new elements.
   * @param {number} elSpeed
   * @param {Array<Object>} bgElArray
   * @param {number} maxBgEl
   * @param {Function} bgElAddFunction
   * @param {number} frequency
   */
  updateBackgroundEl (elSpeed, bgElArray, maxBgEl, bgElAddFunction, frequency) {
    const numElements = bgElArray.length

    if (numElements) {
      for (let i = numElements - 1; i >= 0; i--) {
        bgElArray[i].update(elSpeed)
      }

      const lastEl = bgElArray[numElements - 1]

      // Check for adding a new element.
      if (numElements < maxBgEl &&
        (this.dimensions.WIDTH - lastEl.xPos) > lastEl.gap &&
        frequency > Math.random()) {
        bgElAddFunction()
      }
    } else {
      bgElAddFunction()
    }
  },

  /**
   * Update the cloud positions.
   * @param {number} deltaTime
   * @param {number} speed
   */
  updateClouds (deltaTime, speed) {
    const elSpeed = this.cloudSpeed / 1000 * deltaTime * speed
    this.updateBackgroundEl(
      elSpeed, this.clouds, this.config.MAX_CLOUDS, this.addCloud.bind(this),
      this.cloudFrequency)

    // Remove expired elements.
    this.clouds = this.clouds.filter((obj) => !obj.remove)
  },

  /**
   * Update the background element positions.
   * @param {number} deltaTime
   * @param {number} speed
   */
  updateBackgroundEls (deltaTime, speed) {
    this.updateBackgroundEl(
      deltaTime, this.backgroundEls, BackgroundEl.config.MAX_BG_ELS,
      this.addBackgroundEl.bind(this), this.cloudFrequency)

    // Remove expired elements.
    this.backgroundEls = this.backgroundEls.filter((obj) => !obj.remove)
  },

  /**
   * Update the obstacle positions.
   * @param {number} deltaTime
   * @param {number} currentSpeed
   */
  updateObstacles (deltaTime, currentSpeed) {
    const updatedObstacles = this.obstacles.slice(0)

    for (let i = 0; i < this.obstacles.length; i++) {
      const obstacle = this.obstacles[i]
      obstacle.update(deltaTime, currentSpeed)

      // Clean up existing obstacles.
      if (obstacle.remove) {
        updatedObstacles.shift()
      }
    }
    this.obstacles = updatedObstacles

    if (this.obstacles.length > 0) {
      const lastObstacle = this.obstacles[this.obstacles.length - 1]

      if (lastObstacle && !lastObstacle.followingObstacleCreated &&
        lastObstacle.isVisible() &&
        (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <
        this.dimensions.WIDTH) {
        this.addNewObstacle(currentSpeed)
        lastObstacle.followingObstacleCreated = true
      }
    } else {
      // Create new obstacles.
      this.addNewObstacle(currentSpeed)
    }
  },

  removeFirstObstacle () {
    this.obstacles.shift()
  },

  /**
   * Add a new obstacle.
   * @param {number} currentSpeed
   */
  addNewObstacle (currentSpeed) {
    const obstacleCount =
      Obstacle.types[Obstacle.types.length - 1].type != 'COLLECTABLE' ||
      (Runner.isAltGameModeEnabled() && !this.altGameModeActive ||
        this.altGameModeActive)
        ? Obstacle.types.length - 1
        : Obstacle.types.length - 2
    const obstacleTypeIndex =
      obstacleCount > 0 ? getRandomNum(0, obstacleCount) : 0
    const obstacleType = Obstacle.types[obstacleTypeIndex]

    // Check for multiples of the same type of obstacle.
    // Also check obstacle is available at current speed.
    if ((obstacleCount > 0 && this.duplicateObstacleCheck(obstacleType.type)) ||
      currentSpeed < obstacleType.minSpeed) {
      this.addNewObstacle(currentSpeed)
    } else {
      const obstacleSpritePos = this.spritePos[obstacleType.type]

      this.obstacles.push(new Obstacle(
        this.canvasCtx, obstacleType, obstacleSpritePos, this.dimensions,
        this.gapCoefficient, currentSpeed, obstacleType.width,
        this.altGameModeActive))

      this.obstacleHistory.unshift(obstacleType.type)

      if (this.obstacleHistory.length > 1) {
        this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION)
      }
    }
  },

  /**
   * Returns whether the previous two obstacles are the same as the next one.
   * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.
   * @return {boolean}
   */
  duplicateObstacleCheck (nextObstacleType) {
    let duplicateCount = 0

    for (let i = 0; i < this.obstacleHistory.length; i++) {
      duplicateCount =
        this.obstacleHistory[i] === nextObstacleType ? duplicateCount + 1 : 0
    }
    return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION
  },

  /**
   * Reset the horizon layer.
   * Remove existing obstacles and reposition the horizon line.
   */
  reset () {
    this.obstacles = []
    for (let l = 0; l < this.horizonLines.length; l++) {
      this.horizonLines[l].reset()
    }

    this.nightMode.reset()
  },

  /**
   * Update the canvas width and scaling.
   * @param {number} width Canvas width.
   * @param {number} height Canvas height.
   */
  resize (width, height) {
    this.canvas.width = width
    this.canvas.height = height
  },

  /**
   * Add a new cloud to the horizon.
   */
  addCloud () {
    this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,
      this.dimensions.WIDTH))
  },

  /**
   * Add a random background element to the horizon.
   */
  addBackgroundEl () {
    const backgroundElTypes =
      Object.keys(Runner.spriteDefinition.BACKGROUND_EL)

    if (backgroundElTypes.length > 0) {
      let index = getRandomNum(0, backgroundElTypes.length - 1)
      let type = backgroundElTypes[index]

      // Add variation if available.
      while (type == this.lastEl && backgroundElTypes.length > 1) {
        index = getRandomNum(0, backgroundElTypes.length - 1)
        type = backgroundElTypes[index]
      }

      this.lastEl = type
      this.backgroundEls.push(new BackgroundEl(
        this.canvas, this.spritePos.BACKGROUND_EL, this.dimensions.WIDTH,
        type))
    }
  }
}

;// CONCATENATED MODULE: ./src/scripts/offline-sprite-definitions.js


// Copyright 2021 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* @const
 * Add matching sprite definition and config to Runner.spriteDefinitionByType.
 */
const GAME_TYPE = []

/**
 * Obstacle definitions.
 * minGap: minimum pixel space between obstacles.
 * multipleSpeed: Speed at which multiples are allowed.
 * speedOffset: speed faster / slower than the horizon.
 * minSpeed: Minimum speed which the obstacle can make an appearance.
 *
 * @typedef {{
 *   type: string,
 *   width: number,
 *   height: number,
 *   yPos: number,
 *   multipleSpeed: number,
 *   minGap: number,
 *   minSpeed: number,
 *   collisionBoxes: Array<CollisionBox>,
 * }}
 */
let ObstacleType

/**
 * T-Rex runner sprite definitions.
 */
const spriteDefinitionByType = {
  original: {
    LDPI: {
      BACKGROUND_EL: { x: 86, y: 2 },
      CACTUS_LARGE: { x: 332, y: 2 },
      CACTUS_SMALL: { x: 228, y: 2 },
      OBSTACLE_2: { x: 332, y: 2 },
      OBSTACLE: { x: 228, y: 2 },
      CLOUD: { x: 86, y: 2 },
      HORIZON: { x: 2, y: 54 },
      MOON: { x: 484, y: 2 },
      PTERODACTYL: { x: 134, y: 2 },
      RESTART: { x: 2, y: 68 },
      TEXT_SPRITE: { x: 655, y: 2 },
      TREX: { x: 848, y: 2 },
      STAR: { x: 645, y: 2 },
      COLLECTABLE: { x: 2, y: 2 },
      ALT_GAME_END: { x: 121, y: 2 }
    },
    HDPI: {
      BACKGROUND_EL: { x: 166, y: 2 },
      CACTUS_LARGE: { x: 652, y: 2 },
      CACTUS_SMALL: { x: 446, y: 2 },
      OBSTACLE_2: { x: 652, y: 2 },
      OBSTACLE: { x: 446, y: 2 },
      CLOUD: { x: 166, y: 2 },
      HORIZON: { x: 2, y: 104 },
      MOON: { x: 954, y: 2 },
      PTERODACTYL: { x: 260, y: 2 },
      RESTART: { x: 2, y: 130 },
      TEXT_SPRITE: { x: 1294, y: 2 },
      TREX: { x: 1678, y: 2 },
      STAR: { x: 1276, y: 2 },
      COLLECTABLE: { x: 4, y: 4 },
      ALT_GAME_END: { x: 242, y: 4 }
    },
    MAX_GAP_COEFFICIENT: 1.5,
    MAX_OBSTACLE_LENGTH: 3,
    HAS_CLOUDS: 1,
    BOTTOM_PAD: 10,
    TREX: {
      WAITING_1: { x: 44, w: 44, h: 47, xOffset: 0 },
      WAITING_2: { x: 0, w: 44, h: 47, xOffset: 0 },
      RUNNING_1: { x: 88, w: 44, h: 47, xOffset: 0 },
      RUNNING_2: { x: 132, w: 44, h: 47, xOffset: 0 },
      JUMPING: { x: 0, w: 44, h: 47, xOffset: 0 },
      CRASHED: { x: 220, w: 44, h: 47, xOffset: 0 },
      COLLISION_BOXES: [
        new CollisionBox(22, 0, 17, 16),
        new CollisionBox(1, 18, 30, 9),
        new CollisionBox(10, 35, 14, 8),
        new CollisionBox(1, 24, 29, 5),
        new CollisionBox(5, 30, 21, 4),
        new CollisionBox(9, 34, 15, 4)
      ]
    },
    /** @type {Array<ObstacleType>} */
    OBSTACLES: [
      {
        type: 'CACTUS_SMALL',
        width: 17,
        height: 35,
        yPos: 105,
        multipleSpeed: 4,
        minGap: 120,
        minSpeed: 0,
        collisionBoxes: [
          new CollisionBox(0, 7, 5, 27),
          new CollisionBox(4, 0, 6, 34),
          new CollisionBox(10, 4, 7, 14)
        ]
      },
      {
        type: 'CACTUS_LARGE',
        width: 25,
        height: 50,
        yPos: 90,
        multipleSpeed: 7,
        minGap: 120,
        minSpeed: 0,
        collisionBoxes: [
          new CollisionBox(0, 12, 7, 38),
          new CollisionBox(8, 0, 7, 49),
          new CollisionBox(13, 10, 10, 38)
        ]
      },
      {
        type: 'PTERODACTYL',
        width: 46,
        height: 40,
        yPos: [100, 75, 50], // Variable height.
        yPosMobile: [100, 50], // Variable height mobile.
        multipleSpeed: 999,
        minSpeed: 8.5,
        minGap: 150,
        collisionBoxes: [
          new CollisionBox(15, 15, 16, 5),
          new CollisionBox(18, 21, 24, 6),
          new CollisionBox(2, 14, 4, 3),
          new CollisionBox(6, 10, 4, 7),
          new CollisionBox(10, 8, 6, 9)
        ],
        numFrames: 2,
        frameRate: 1000 / 6,
        speedOffset: 0.8
      }
    ],
    BACKGROUND_EL: {
      CLOUD: {
        HEIGHT: 14,
        MAX_CLOUD_GAP: 400,
        MAX_SKY_LEVEL: 30,
        MIN_CLOUD_GAP: 100,
        MIN_SKY_LEVEL: 71,
        OFFSET: 4,
        WIDTH: 46,
        X_POS: 1,
        Y_POS: 120
      }
    },
    BACKGROUND_EL_CONFIG: {
      MAX_BG_ELS: 1,
      MAX_GAP: 400,
      MIN_GAP: 100,
      POS: 0,
      SPEED: 0.5,
      Y_POS: 125
    },
    LINES: [
      { SOURCE_X: 2, SOURCE_Y: 52, WIDTH: 600, HEIGHT: 12, YPOS: 127 }
    ]
  }
}

/**
 * @typedef {{
 *   downloadButtonClick: function(),
 *   reloadButtonClick: function(string),
 *   detailsButtonClick: function(),
 *   diagnoseErrorsButtonClick: function(),
 *   trackEasterEgg: function(),
 *   updateEasterEggHighScore: function(number),
 *   resetEasterEggHighScore: function(),
 *   launchOfflineItem: function(string, string),
 *   savePageForLater: function(),
 *   cancelSavePage: function(),
 *   listVisibilityChange: function(boolean),
 * }}
 */
let offline_sprite_definitions_errorPageController

const offline_sprite_definitions_HIDDEN_CLASS = 'hidden'

;// CONCATENATED MODULE: ./src/scripts/interstitial_mobile_nav.js
// Copyright 2015 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


let interstitial_mobile_nav_mobileNav = false

/**
 * For small screen mobile the navigation buttons are moved
 * below the advanced text.
 */
function onResize () {
  const helpOuterBox = document.querySelector('#details')
  const mainContent = document.querySelector('#main-content')
  const mediaQuery = '(min-width: 240px) and (max-width: 420px) and ' +
    '(min-height: 401px), ' +
    '(max-height: 560px) and (min-height: 240px) and ' +
    '(min-width: 421px)'

  const detailsHidden = helpOuterBox.classList.contains(offline_sprite_definitions_HIDDEN_CLASS)
  const runnerContainer = document.querySelector('.runner-container')

  // Check for change in nav status.
  if (interstitial_mobile_nav_mobileNav !== window.matchMedia(mediaQuery).matches) {
    interstitial_mobile_nav_mobileNav = !interstitial_mobile_nav_mobileNav

    // Handle showing the top content / details sections according to state.
    if (interstitial_mobile_nav_mobileNav) {
      mainContent.classList.toggle(offline_sprite_definitions_HIDDEN_CLASS, !detailsHidden)
      helpOuterBox.classList.toggle(offline_sprite_definitions_HIDDEN_CLASS, detailsHidden)
      if (runnerContainer) {
        runnerContainer.classList.toggle(offline_sprite_definitions_HIDDEN_CLASS, !detailsHidden)
      }
    } else if (!detailsHidden) {
      // Non-mobile nav with visible details.
      mainContent.classList.remove(offline_sprite_definitions_HIDDEN_CLASS)
      helpOuterBox.classList.remove(offline_sprite_definitions_HIDDEN_CLASS)
      if (runnerContainer) {
        runnerContainer.classList.remove(offline_sprite_definitions_HIDDEN_CLASS)
      }
    }
  }
}

function setupMobileNav () {
  window.addEventListener('resize', onResize)
  onResize()
}

document.addEventListener('DOMContentLoaded', setupMobileNav)

;// CONCATENATED MODULE: ./src/scripts/error_page_controller_ios.js
// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

const error_page_controller_ios_errorPageController = {
  // Execute a button click to download page later.
  downloadButtonClick: function () {},

  // Execute a click on the reload button.
  reloadButtonClick: function (url) {
    window.location = url
  },

  // Execute a "Details" button click.
  detailsButtonClick: function () {},

  // Execute a "Diagnose Errors" button click.
  diagnoseErrorsButtonClick: function () {},

  // ???
  launchOfflineItem: function () {},
  savePageForLater: function () {},
  cancelSavePage: function () {},
  listVisibilityChange: function () {},

  // Track easter egg plays and high scores.
  trackEasterEgg: function () {
    __gCrWeb.message.invokeOnHost(
      { command: 'errorPageController.trackEasterEgg' })
  },

  updateEasterEggHighScore: function (highScore) {
    __gCrWeb.message.invokeOnHost({
      command: 'errorPageController.updateEasterEggHighScore',
      highScore: highScore.toString()
    })
  },

  resetEasterEggHighScore: function () {
    __gCrWeb.message.invokeOnHost(
      { command: 'errorPageController.resetEasterEggHighScore' })
  }
}

// Create a __gCrWeb binding of initializeEasterEggHighScore so it can be
// called using JS messaging.
const __gCrWeb = {}
__gCrWeb.errorPageController = error_page_controller_ios_errorPageController
__gCrWeb.errorPageController.initializeEasterEggHighScore = function (highscore) {
  window.initializeEasterEggHighScore(highscore)
}

;// CONCATENATED MODULE: ./src/scripts/neterror.js





// Decodes a UTF16 string that is encoded as base64.
function decodeUTF16Base64ToString (encodedText) {
  const data = atob(encodedText)
  let result = ''
  for (let i = 0; i < data.length; i += 2) {
    result +=
      String.fromCharCode(data.charCodeAt(i) * 256 + data.charCodeAt(i + 1))
  }
  return result
}

function toggleHelpBox () {
  const helpBoxOuter = document.getElementById('details')
  helpBoxOuter.classList.toggle(HIDDEN_CLASS)
  const detailsButton = document.getElementById('details-button')
  if (helpBoxOuter.classList.contains(HIDDEN_CLASS)) {
    /** @suppress {missingProperties} */
    detailsButton.innerText = detailsButton.detailsText
  } else {
    /** @suppress {missingProperties} */
    detailsButton.innerText = detailsButton.hideDetailsText
  }

  // Details appears over the main content on small screens.
  if (mobileNav) {
    document.getElementById('main-content').classList.toggle(HIDDEN_CLASS)
    const runnerContainer = document.querySelector('.runner-container')
    if (runnerContainer) {
      runnerContainer.classList.toggle(HIDDEN_CLASS)
    }
  }
}

function diagnoseErrors () {
  if (window.errorPageController) {
    errorPageController.diagnoseErrorsButtonClick()
  }
}

// Subframes use a different layout but the same html file.  This is to make it
// easier to support platforms that load the error page via different
// mechanisms (Currently just iOS). We also use the subframe style for portals
// as they are embedded like subframes and can't be interacted with by the user.
let isSubFrame = false
if (window.top.location !== window.location || window.portalHost) {
  document.documentElement.setAttribute('subframe', '')
  isSubFrame = true
}

// Adds an icon class to the list and removes classes previously set.
function updateIconClass (newClass) {
  const frameSelector = isSubFrame ? '#sub-frame-error' : '#main-frame-error'
  const iconEl = document.querySelector(frameSelector + ' .icon')

  if (iconEl.classList.contains(newClass)) {
    return
  }

  iconEl.className = 'icon ' + newClass
}

// Implements button clicks.  This function is needed during the transition
// between implementing these in trunk chromium and implementing them in iOS.
function reloadButtonClick (url) {
  if (window.errorPageController) {
    // <if expr="is_ios">
    errorPageController.reloadButtonClick(url)
    // </if>

    // <if expr="not is_ios">
    errorPageController.reloadButtonClick()
    // </if>
  } else {
    window.location = url
  }
}

function downloadButtonClick () {
  if (window.errorPageController) {
    errorPageController.downloadButtonClick()
    const downloadButton = document.getElementById('download-button')
    downloadButton.disabled = true
    /** @suppress {missingProperties} */
    downloadButton.textContent = downloadButton.disabledText

    document.getElementById('download-link-wrapper')
      .classList.add(HIDDEN_CLASS)
    document.getElementById('download-link-clicked-wrapper')
      .classList.remove(HIDDEN_CLASS)
  }
}

function detailsButtonClick () {
  if (window.errorPageController) {
    errorPageController.detailsButtonClick()
  }
}

let primaryControlOnLeft = true
// clang-format off
// <if expr="is_macosx or is_ios or is_linux or is_chromeos or is_android">
// clang-format on
primaryControlOnLeft = false
// </if>

function setAutoFetchState (scheduled, canSchedule) {
  document.getElementById('cancel-save-page-button')
    .classList.toggle(HIDDEN_CLASS, !scheduled)
  document.getElementById('save-page-for-later-button')
    .classList.toggle(HIDDEN_CLASS, scheduled || !canSchedule)
}

function savePageLaterClick () {
  errorPageController.savePageForLater()
  // savePageForLater will eventually trigger a call to setAutoFetchState() when
  // it completes.
}

function cancelSavePageClick () {
  errorPageController.cancelSavePage()
  // setAutoFetchState is not called in response to cancelSavePage(), so do it
  // now.
  setAutoFetchState(false, true)
}

function toggleErrorInformationPopup () {
  document.getElementById('error-information-popup-container')
    .classList.toggle(HIDDEN_CLASS)
}

function launchOfflineItem (itemID, nameSpace) {
  errorPageController.launchOfflineItem(itemID, nameSpace)
}

function launchDownloadsPage () {
  errorPageController.launchDownloadsPage()
}

function getIconForSuggestedItem (item) {
  // Note: |item.content_type| contains the enum values from
  // chrome::mojom::AvailableContentType.
  switch (item.content_type) {
    case 1: // kVideo
      return 'image-video'
    case 2: // kAudio
      return 'image-music-note'
    case 0: // kPrefetchedPage
    case 3: // kOtherPage
      return 'image-earth'
  }
  return 'image-file'
}

function getSuggestedContentDiv (item, index) {
  // Note: See AvailableContentToValue in available_offline_content_helper.cc
  // for the data contained in an |item|.
  // TODO(carlosk): Present |snippet_base64| when that content becomes
  // available.
  let thumbnail = ''
  const extraContainerClasses = []
  // html_inline.py will try to replace src attributes with data URIs using a
  // simple regex. The following is obfuscated slightly to avoid that.
  const source = 'src'
  if (item.thumbnail_data_uri) {
    extraContainerClasses.push('suggestion-with-image')
    thumbnail = `<img ${source}="${item.thumbnail_data_uri}">`
  } else {
    extraContainerClasses.push('suggestion-with-icon')
    const iconClass = getIconForSuggestedItem(item)
    thumbnail = `<div><img class="${iconClass}"></div>`
  }

  let favicon = ''
  if (item.favicon_data_uri) {
    favicon = `<img ${source}="${item.favicon_data_uri}">`
  } else {
    extraContainerClasses.push('no-favicon')
  }

  if (!item.attribution_base64) {
    extraContainerClasses.push('no-attribution')
  }

  return `
  <div class="offline-content-suggestion ${extraContainerClasses.join(' ')}"
    onclick="launchOfflineItem('${item.ID}', '${item.name_space}')">
      <div class="offline-content-suggestion-texts">
        <div id="offline-content-suggestion-title-${index}"
             class="offline-content-suggestion-title">
        </div>
        <div class="offline-content-suggestion-attribution-freshness">
          <div id="offline-content-suggestion-favicon-${index}"
               class="offline-content-suggestion-favicon">
            ${favicon}
          </div>
          <div id="offline-content-suggestion-attribution-${index}"
               class="offline-content-suggestion-attribution">
          </div>
          <div class="offline-content-suggestion-freshness">
            ${item.date_modified}
          </div>
          <div class="offline-content-suggestion-pin-spacer"></div>
          <div class="offline-content-suggestion-pin"></div>
        </div>
      </div>
      <div class="offline-content-suggestion-thumbnail">
        ${thumbnail}
      </div>
  </div>`
}

/**
 * @typedef {{
 *   ID: string,
 *   name_space: string,
 *   title_base64: string,
 *   snippet_base64: string,
 *   date_modified: string,
 *   attribution_base64: string,
 *   thumbnail_data_uri: string,
 *   favicon_data_uri: string,
 *   content_type: number,
 * }}
 */
let AvailableOfflineContent

// Populates a list of suggested offline content.
// Note: For security reasons all content downloaded from the web is considered
// unsafe and must be securely handled to be presented on the dino page. Images
// have already been safely re-encoded but textual content -- like title and
// attribution -- must be properly handled here.
// @param {boolean} isShown
// @param {Array<AvailableOfflineContent>} suggestions
function offlineContentAvailable (isShown, suggestions) {
  if (!suggestions || !loadTimeData.valueExists('offlineContentList')) {
    return
  }

  const suggestionsHTML = []
  for (let index = 0; index < suggestions.length; index++) {
    suggestionsHTML.push(getSuggestedContentDiv(suggestions[index], index))
  }

  document.getElementById('offline-content-suggestions').innerHTML =
    suggestionsHTML.join('\n')

  // Sets textual web content using |textContent| to make sure it's handled as
  // plain text.
  for (let index = 0; index < suggestions.length; index++) {
    document.getElementById(`offline-content-suggestion-title-${index}`)
      .textContent =
      decodeUTF16Base64ToString(suggestions[index].title_base64)
    document.getElementById(`offline-content-suggestion-attribution-${index}`)
      .textContent =
      decodeUTF16Base64ToString(suggestions[index].attribution_base64)
  }

  const contentListElement = document.getElementById('offline-content-list')
  if (document.dir === 'rtl') {
    contentListElement.classList.add('is-rtl')
  }
  contentListElement.hidden = false
  // The list is configured as hidden by default. Show it if needed.
  if (isShown) {
    toggleOfflineContentListVisibility(false)
  }
}

function toggleOfflineContentListVisibility (updatePref) {
  if (!loadTimeData.valueExists('offlineContentList')) {
    return
  }

  const contentListElement = document.getElementById('offline-content-list')
  const isVisible = !contentListElement.classList.toggle('list-hidden')

  if (updatePref && window.errorPageController) {
    errorPageController.listVisibilityChanged(isVisible)
  }
}

// Called on document load, and from updateForDnsProbe().
function onDocumentLoadOrUpdate () {
  const downloadButtonVisible = load_time_data_deprecated_loadTimeData.valueExists('downloadButton') &&
    load_time_data_deprecated_loadTimeData.getValue('downloadButton').msg
  const detailsButton = document.getElementById('details-button')

  // If offline content suggestions will be visible, the usual buttons will not
  // be presented.
  const offlineContentVisible =
    load_time_data_deprecated_loadTimeData.valueExists('suggestedOfflineContentPresentation')
  if (offlineContentVisible) {
    document.querySelector('.nav-wrapper').classList.add(offline_sprite_definitions_HIDDEN_CLASS)
    detailsButton.classList.add(offline_sprite_definitions_HIDDEN_CLASS)

    document.getElementById('download-link').hidden = !downloadButtonVisible
    document.getElementById('download-links-wrapper')
      .classList.remove(offline_sprite_definitions_HIDDEN_CLASS)
    document.getElementById('error-information-popup-container')
      .classList.add('use-popup-container', offline_sprite_definitions_HIDDEN_CLASS)
    document.getElementById('error-information-button')
      .classList.remove(offline_sprite_definitions_HIDDEN_CLASS)
  }

  const attemptAutoFetch = load_time_data_deprecated_loadTimeData.valueExists('attemptAutoFetch') &&
    load_time_data_deprecated_loadTimeData.getValue('attemptAutoFetch')

  const reloadButtonVisible = load_time_data_deprecated_loadTimeData.valueExists('reloadButton') &&
    load_time_data_deprecated_loadTimeData.getValue('reloadButton').msg

  const reloadButton = document.getElementById('reload-button')
  const downloadButton = document.getElementById('download-button')
  if (reloadButton.style.display === 'none' &&
    downloadButton.style.display === 'none') {
    detailsButton.classList.add('singular')
  }

  // Show or hide control buttons.
  const controlButtonDiv = document.getElementById('control-buttons')
  controlButtonDiv.hidden =
    offlineContentVisible || !(reloadButtonVisible || downloadButtonVisible)

  const iconClass = load_time_data_deprecated_loadTimeData.valueExists('iconClass') &&
    load_time_data_deprecated_loadTimeData.getValue('iconClass')

  updateIconClass(iconClass)

  if (!isSubFrame && iconClass === 'icon-offline') {
    document.documentElement.classList.add('offline')
    return new Runner('.interstitial-wrapper')
  }
}

;// CONCATENATED MODULE: ./src/main.js
/**
 * @copyright 2013 The Chromium Authors
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */













function onDocumentLoad() {
  // set sprites img element src
  document.getElementById('offline-resources-1x').src = _100_offline_sprite_namespaceObject;
  document.getElementById('offline-resources-2x').src = _200_offline_sprite_namespaceObject;

  // set sounds audio element src
  var resourceTemplate = document.getElementById('audio-resources').content;
  resourceTemplate.getElementById('offline-sound-press').src = button_press_namespaceObject;
  resourceTemplate.getElementById('offline-sound-hit').src = hit_namespaceObject;
  resourceTemplate.getElementById('offline-sound-reached').src = score_reached_namespaceObject;

  // Sets up the proper button layout for the current platform.
  var buttonsDiv = document.getElementById('buttons');
  if (primaryControlOnLeft) {
    buttonsDiv.classList.add('suggested-left');
  } else {
    buttonsDiv.classList.add('suggested-right');
  }
  onDocumentLoadOrUpdate();
  var tp = document.getElementById('t');
  window.jstProcess(new window.JsEvalContext(pageData), tp);
}
document.addEventListener('DOMContentLoaded', onDocumentLoad);
console.log('load');
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxPQUFPO0FBQ2pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEIsc0JBQXNCLHNDQUFZLElBQUksa0RBQXdCO0FBQzlELFVBQVUsU0FBUyxVQUFVLCtDQUFxQjtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVyxzQ0FBWSxJQUFJLGtEQUF3QjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CLHNDQUFZLElBQUksa0RBQXdCO0FBQzNELFFBQVEsZ0RBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELGdCQUFnQixtQ0FBbUM7QUFDbkQsY0FBYyx3Q0FBd0M7QUFDdEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQVk7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RVEsUUFBUSxDQUFDQyxjQUFjLENBQUMsc0JBQXNCLENBQUMsQ0FBQ0MsR0FBRyxHQUFHVCxtQ0FBZ0I7O0VBRXRFO0VBQ0EsSUFBTVUsZ0JBQWdCLEdBQ3BCSCxRQUFRLENBQUNDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDRyxPQUFPO0VBRXBERCxnQkFBZ0IsQ0FBQ0YsY0FBYyxDQUFDLHFCQUFxQixDQUFDLENBQUNDLEdBQUcsR0FBR1IsNEJBQVc7RUFDeEVTLGdCQUFnQixDQUFDRixjQUFjLENBQUMsbUJBQW1CLENBQUMsQ0FBQ0MsR0FBRyxHQUFHUCxtQkFBRztFQUM5RFEsZ0JBQWdCLENBQUNGLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDQyxHQUFHLEdBQUdOLDZCQUFZOztFQUUzRTtFQUNBLElBQU1TLFVBQVUsR0FBR0wsUUFBUSxDQUFDQyxjQUFjLENBQUMsU0FBUyxDQUFDO0VBQ3JELElBQUlKLG9CQUFvQixFQUFFO0lBQ3hCUSxVQUFVLENBQUNDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLGdCQUFnQixDQUFDO0VBQzVDLENBQUMsTUFBTTtJQUNMRixVQUFVLENBQUNDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLGlCQUFpQixDQUFDO0VBQzdDO0VBRUFULHNCQUFzQixFQUFFO0VBRXhCLElBQU1VLEVBQUUsR0FBR1IsUUFBUSxDQUFDQyxjQUFjLENBQUMsR0FBRyxDQUFDO0VBQ3ZDUSxNQUFNLENBQUNDLFVBQVUsQ0FBQyxJQUFJRCxNQUFNLENBQUNFLGFBQWEsQ0FBQ0MsUUFBUSxDQUFDLEVBQUVKLEVBQUUsQ0FBQztBQUMzRDtBQUNBUixRQUFRLENBQUNhLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFZCxjQUFjLENBQUM7QUFFN0RlLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FudGEtcnVubmVyLy4vc3JjL3NjcmlwdHMvanN0ZW1wbGF0ZV9jb21waWxlZC5qcyIsIndlYnBhY2s6Ly9zYW50YS1ydW5uZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2FudGEtcnVubmVyLy4vc3JjL3NjcmlwdHMvbG9hZF90aW1lX2RhdGFfZGVwcmVjYXRlZC5qcyIsIndlYnBhY2s6Ly9zYW50YS1ydW5uZXIvLi9zcmMvc2NyaXB0cy9vZmZsaW5lLmpzIiwid2VicGFjazovL3NhbnRhLXJ1bm5lci8uL3NyYy9zY3JpcHRzL29mZmxpbmUtc3ByaXRlLWRlZmluaXRpb25zLmpzIiwid2VicGFjazovL3NhbnRhLXJ1bm5lci8uL3NyYy9zY3JpcHRzL2ludGVyc3RpdGlhbF9tb2JpbGVfbmF2LmpzIiwid2VicGFjazovL3NhbnRhLXJ1bm5lci8uL3NyYy9zY3JpcHRzL2Vycm9yX3BhZ2VfY29udHJvbGxlcl9pb3MuanMiLCJ3ZWJwYWNrOi8vc2FudGEtcnVubmVyLy4vc3JjL3NjcmlwdHMvbmV0ZXJyb3IuanMiLCJ3ZWJwYWNrOi8vc2FudGEtcnVubmVyLy4vc3JjL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbChhLGIsYyl7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KEFycmF5LnByb3RvdHlwZS5zbGljZSxhcmd1bWVudHMpfWZ1bmN0aW9uIG0oYSxiLGMpe3ZhciBlPWwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBiLmFwcGx5KGEsZSl9fWZ1bmN0aW9uIG4oYSxiKXt2YXIgYz1uZXcgcChiKTtmb3IoYy5oPVthXTtjLmgubGVuZ3RoOyl7dmFyIGU9YyxkPWMuaC5zaGlmdCgpO2UuaShkKTtmb3IoZD1kLmZpcnN0Q2hpbGQ7ZDtkPWQubmV4dFNpYmxpbmcpMT09ZC5ub2RlVHlwZSYmZS5oLnB1c2goZCl9fWZ1bmN0aW9uIHAoYSl7dGhpcy5pPWF9ZnVuY3Rpb24gcShhKXthLnN0eWxlLmRpc3BsYXk9XCJcIn1mdW5jdGlvbiByKGEpe2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIn07dmFyIHQ9L1xccyo7XFxzKi87ZnVuY3Rpb24gdShhLGIpe3RoaXMubC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dS5wcm90b3R5cGUubD1mdW5jdGlvbihhLGIpe3RoaXMuYXx8KHRoaXMuYT17fSk7aWYoYil7dmFyIGM9dGhpcy5hLGU9Yi5hO2ZvcihkIGluIGUpY1tkXT1lW2RdfWVsc2V7dmFyIGQ9dGhpcy5hO2U9djtmb3IoYyBpbiBlKWRbY109ZVtjXX10aGlzLmEuJHRoaXM9YTt0aGlzLmEuJGNvbnRleHQ9dGhpczt0aGlzLmY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEmJm51bGwhPWE/YTpcIlwiO2J8fCh0aGlzLmEuJHRvcD10aGlzLmYpfTt2YXIgdj17JGRlZmF1bHQ6bnVsbH0sdz1bXTtmdW5jdGlvbiB4KGEpe2Zvcih2YXIgYiBpbiBhLmEpZGVsZXRlIGEuYVtiXTthLmY9bnVsbDt3LnB1c2goYSl9ZnVuY3Rpb24geShhLGIsYyl7dHJ5e3JldHVybiBiLmNhbGwoYyxhLmEsYS5mKX1jYXRjaChlKXtyZXR1cm4gdi4kZGVmYXVsdH19XHJcbiAgdS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYSxiLGMpe2lmKDA8dy5sZW5ndGgpe3ZhciBlPXcucG9wKCk7dS5jYWxsKGUsYSx0aGlzKTthPWV9ZWxzZSBhPW5ldyB1KGEsdGhpcyk7YS5hLiRpbmRleD1iO2EuYS4kY291bnQ9YztyZXR1cm4gYX07dmFyIHo7d2luZG93LnRydXN0ZWRUeXBlcyYmKHo9dHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcImpzdGVtcGxhdGVcIix7Y3JlYXRlU2NyaXB0OmZ1bmN0aW9uKGEpe3JldHVybiBhfX0pKTt2YXIgQT17fTtmdW5jdGlvbiBCKGEpe2lmKCFBW2FdKXRyeXt2YXIgYj1cIihmdW5jdGlvbihhXywgYl8pIHsgd2l0aCAoYV8pIHdpdGggKGJfKSByZXR1cm4gXCIrYStcIiB9KVwiLGM9d2luZG93LnRydXN0ZWRUeXBlcz96LmNyZWF0ZVNjcmlwdChiKTpiO0FbYV09d2luZG93LmV2YWwoYyl9Y2F0Y2goZSl7fXJldHVybiBBW2FdfVxyXG4gIGZ1bmN0aW9uIEUoYSl7dmFyIGI9W107YT1hLnNwbGl0KHQpO2Zvcih2YXIgYz0wLGU9YS5sZW5ndGg7YzxlOysrYyl7dmFyIGQ9YVtjXS5pbmRleE9mKFwiOlwiKTtpZighKDA+ZCkpe3ZhciBnPWFbY10uc3Vic3RyKDAsZCkucmVwbGFjZSgvXlxccysvLFwiXCIpLnJlcGxhY2UoL1xccyskLyxcIlwiKTtkPUIoYVtjXS5zdWJzdHIoZCsxKSk7Yi5wdXNoKGcsZCl9fXJldHVybiBifTtmdW5jdGlvbiBGKCl7fXZhciBHPTAsSD17MDp7fX0sST17fSxKPXt9LEs9W107ZnVuY3Rpb24gTChhKXthLl9fanN0Y2FjaGV8fG4oYSxmdW5jdGlvbihiKXtNKGIpfSl9dmFyIE49W1tcImpzc2VsZWN0XCIsQl0sW1wianNkaXNwbGF5XCIsQl0sW1wianN2YWx1ZXNcIixFXSxbXCJqc3ZhcnNcIixFXSxbXCJqc2V2YWxcIixmdW5jdGlvbihhKXt2YXIgYj1bXTthPWEuc3BsaXQodCk7Zm9yKHZhciBjPTAsZT1hLmxlbmd0aDtjPGU7KytjKWlmKGFbY10pe3ZhciBkPUIoYVtjXSk7Yi5wdXNoKGQpfXJldHVybiBifV0sW1widHJhbnNjbHVkZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhfV0sW1wianNjb250ZW50XCIsQl0sW1wianNza2lwXCIsQl1dO1xyXG4gIGZ1bmN0aW9uIE0oYSl7aWYoYS5fX2pzdGNhY2hlKXJldHVybiBhLl9fanN0Y2FjaGU7dmFyIGI9YS5nZXRBdHRyaWJ1dGUoXCJqc3RjYWNoZVwiKTtpZihudWxsIT1iKXJldHVybiBhLl9fanN0Y2FjaGU9SFtiXTtiPUsubGVuZ3RoPTA7Zm9yKHZhciBjPU4ubGVuZ3RoO2I8YzsrK2Ipe3ZhciBlPU5bYl1bMF0sZD1hLmdldEF0dHJpYnV0ZShlKTtKW2VdPWQ7bnVsbCE9ZCYmSy5wdXNoKGUrXCI9XCIrZCl9aWYoMD09Sy5sZW5ndGgpcmV0dXJuIGEuc2V0QXR0cmlidXRlKFwianN0Y2FjaGVcIixcIjBcIiksYS5fX2pzdGNhY2hlPUhbMF07dmFyIGc9Sy5qb2luKFwiJlwiKTtpZihiPUlbZ10pcmV0dXJuIGEuc2V0QXR0cmlidXRlKFwianN0Y2FjaGVcIixiKSxhLl9fanN0Y2FjaGU9SFtiXTt2YXIgaD17fTtiPTA7Zm9yKGM9Ti5sZW5ndGg7YjxjOysrYil7ZD1OW2JdO2U9ZFswXTt2YXIgZj1kWzFdO2Q9SltlXTtudWxsIT1kJiYoaFtlXT1mKGQpKX1iPVwiXCIrICsrRzthLnNldEF0dHJpYnV0ZShcImpzdGNhY2hlXCIsXHJcbiAgICBiKTtIW2JdPWg7SVtnXT1iO3JldHVybiBhLl9fanN0Y2FjaGU9aH1mdW5jdGlvbiBQKGEsYil7YS5qLnB1c2goYik7YS5vLnB1c2goMCl9ZnVuY3Rpb24gUShhKXtyZXR1cm4gYS5jLmxlbmd0aD9hLmMucG9wKCk6W119XHJcbiAgRi5wcm90b3R5cGUuZz1mdW5jdGlvbihhLGIpe3ZhciBjPVIoYiksZT1jLnRyYW5zY2x1ZGU7aWYoZSkoYz1TKGUpKT8oYi5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjLGIpLGU9USh0aGlzKSxlLnB1c2godGhpcy5nLGEsYyksUCh0aGlzLGUpKTpiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7ZWxzZSBpZihjPWMuanNzZWxlY3Qpe2M9eShhLGMsYik7dmFyIGQ9Yi5nZXRBdHRyaWJ1dGUoXCJqc2luc3RhbmNlXCIpO3ZhciBnPSExO2QmJihcIipcIj09ZC5jaGFyQXQoMCk/KGQ9cGFyc2VJbnQoZC5zdWJzdHIoMSksMTApLGc9ITApOmQ9cGFyc2VJbnQoZCwxMCkpO3ZhciBoPW51bGwhPWMmJlwib2JqZWN0XCI9PXR5cGVvZiBjJiZcIm51bWJlclwiPT10eXBlb2YgYy5sZW5ndGg7ZT1oP2MubGVuZ3RoOjE7dmFyIGY9aCYmMD09ZTtpZihoKWlmKGYpZD9iLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik6KGIuc2V0QXR0cmlidXRlKFwianNpbnN0YW5jZVwiLFwiKjBcIikscihiKSk7ZWxzZSBpZihxKGIpLFxyXG4gIG51bGw9PT1kfHxcIlwiPT09ZHx8ZyYmZDxlLTEpe2c9USh0aGlzKTtkPWR8fDA7Zm9yKGg9ZS0xO2Q8aDsrK2Qpe3ZhciBrPWIuY2xvbmVOb2RlKCEwKTtiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGssYik7VChrLGMsZCk7Zj1hLmNsb25lKGNbZF0sZCxlKTtnLnB1c2godGhpcy5iLGYsayx4LGYsbnVsbCl9VChiLGMsZCk7Zj1hLmNsb25lKGNbZF0sZCxlKTtnLnB1c2godGhpcy5iLGYsYix4LGYsbnVsbCk7UCh0aGlzLGcpfWVsc2UgZDxlPyhnPWNbZF0sVChiLGMsZCksZj1hLmNsb25lKGcsZCxlKSxnPVEodGhpcyksZy5wdXNoKHRoaXMuYixmLGIseCxmLG51bGwpLFAodGhpcyxnKSk6Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO2Vsc2UgbnVsbD09Yz9yKGIpOihxKGIpLGY9YS5jbG9uZShjLDAsMSksZz1RKHRoaXMpLGcucHVzaCh0aGlzLmIsZixiLHgsZixudWxsKSxQKHRoaXMsZykpfWVsc2UgdGhpcy5iKGEsYil9O1xyXG4gIEYucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1SKGIpLGU9Yy5qc2Rpc3BsYXk7aWYoZSl7aWYoIXkoYSxlLGIpKXtyKGIpO3JldHVybn1xKGIpfWlmKGU9Yy5qc3ZhcnMpZm9yKHZhciBkPTAsZz1lLmxlbmd0aDtkPGc7ZCs9Mil7dmFyIGg9ZVtkXSxmPXkoYSxlW2QrMV0sYik7YS5hW2hdPWZ9aWYoZT1jLmpzdmFsdWVzKWZvcihkPTAsZz1lLmxlbmd0aDtkPGc7ZCs9MilpZihmPWVbZF0saD15KGEsZVtkKzFdLGIpLFwiJFwiPT1mLmNoYXJBdCgwKSlhLmFbZl09aDtlbHNlIGlmKFwiLlwiPT1mLmNoYXJBdCgwKSl7Zj1mLnN1YnN0cigxKS5zcGxpdChcIi5cIik7Zm9yKHZhciBrPWIsTz1mLmxlbmd0aCxDPTAsVT1PLTE7QzxVOysrQyl7dmFyIEQ9ZltDXTtrW0RdfHwoa1tEXT17fSk7az1rW0RdfWtbZltPLTFdXT1ofWVsc2UgZiYmKFwiYm9vbGVhblwiPT10eXBlb2YgaD9oP2Iuc2V0QXR0cmlidXRlKGYsZik6Yi5yZW1vdmVBdHRyaWJ1dGUoZik6Yi5zZXRBdHRyaWJ1dGUoZixcIlwiK2gpKTtcclxuICAgIGlmKGU9Yy5qc2V2YWwpZm9yKGQ9MCxnPWUubGVuZ3RoO2Q8ZzsrK2QpeShhLGVbZF0sYik7ZT1jLmpzc2tpcDtpZighZXx8IXkoYSxlLGIpKWlmKGM9Yy5qc2NvbnRlbnQpe2lmKGM9XCJcIit5KGEsYyxiKSxiLmlubmVySFRNTCE9Yyl7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWU9Yi5maXJzdENoaWxkLGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTtiLmFwcGVuZENoaWxkKHRoaXMubS5jcmVhdGVUZXh0Tm9kZShjKSl9fWVsc2V7Yz1RKHRoaXMpO2ZvcihlPWIuZmlyc3RDaGlsZDtlO2U9ZS5uZXh0U2libGluZykxPT1lLm5vZGVUeXBlJiZjLnB1c2godGhpcy5nLGEsZSk7Yy5sZW5ndGgmJlAodGhpcyxjKX19O2Z1bmN0aW9uIFIoYSl7aWYoYS5fX2pzdGNhY2hlKXJldHVybiBhLl9fanN0Y2FjaGU7dmFyIGI9YS5nZXRBdHRyaWJ1dGUoXCJqc3RjYWNoZVwiKTtyZXR1cm4gYj9hLl9fanN0Y2FjaGU9SFtiXTpNKGEpfVxyXG4gIGZ1bmN0aW9uIFMoYSxiKXt2YXIgYz1kb2N1bWVudDtpZihiKXt2YXIgZT1jLmdldEVsZW1lbnRCeUlkKGEpO2lmKCFlKXtlPWIoKTt2YXIgZD1jLmdldEVsZW1lbnRCeUlkKFwianN0c1wiKTtkfHwoZD1jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZC5pZD1cImpzdHNcIixyKGQpLGQuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGMuYm9keS5hcHBlbmRDaGlsZChkKSk7dmFyIGc9Yy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2QuYXBwZW5kQ2hpbGQoZyk7Zy5pbm5lckhUTUw9ZTtlPWMuZ2V0RWxlbWVudEJ5SWQoYSl9Yz1lfWVsc2UgYz1jLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjPyhMKGMpLGM9Yy5jbG9uZU5vZGUoITApLGMucmVtb3ZlQXR0cmlidXRlKFwiaWRcIiksYyk6bnVsbH1mdW5jdGlvbiBUKGEsYixjKXtjPT1iLmxlbmd0aC0xP2Euc2V0QXR0cmlidXRlKFwianNpbnN0YW5jZVwiLFwiKlwiK2MpOmEuc2V0QXR0cmlidXRlKFwianNpbnN0YW5jZVwiLFwiXCIrYyl9O3dpbmRvdy5qc3RHZXRUZW1wbGF0ZT1TO3dpbmRvdy5Kc0V2YWxDb250ZXh0PXU7d2luZG93LmpzdFByb2Nlc3M9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgRjtMKGIpO2MubT1iPzk9PWIubm9kZVR5cGU/YjpiLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50OmRvY3VtZW50O3ZhciBlPW0oYyxjLmcsYSxiKSxkPWMuaj1bXSxnPWMubz1bXTtjLmM9W107ZSgpO2Zvcih2YXIgaCxmLGs7ZC5sZW5ndGg7KWg9ZFtkLmxlbmd0aC0xXSxlPWdbZy5sZW5ndGgtMV0sZT49aC5sZW5ndGg/KGU9YyxmPWQucG9wKCksZi5sZW5ndGg9MCxlLmMucHVzaChmKSxnLnBvcCgpKTooZj1oW2UrK10saz1oW2UrK10saD1oW2UrK10sZ1tnLmxlbmd0aC0xXT1lLGYuY2FsbChjLGssaCkpfTtcclxufSkoKVxyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gQ29weXJpZ2h0IDIwMTIgVGhlIENocm9taXVtIEF1dGhvcnNcclxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXdcclxuICogTk9URTogVGhpcyBmaWxlIGlzIGRlcHJlY2F0ZWQsIGFuZCBwcm92aWRlcyBvbmx5IHRoZSBtaW5pbWFsIExvYWRUaW1lRGF0YVxyXG4gKiBmdW5jdGlvbnMgZm9yIHBsYWNlcyBpbiB0aGUgY29kZSBzdGlsbCBub3QgdXNpbmcgSlMgbW9kdWxlcy4gVXNlXHJcbiAqIGxvYWRfdGltZV9kYXRhLnRzIGluIGFsbCBuZXcgY29kZS5cclxuICpcclxuICogVGhpcyBmaWxlIGRlZmluZXMgYSBzaW5nbGV0b24gd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGFsbCBkYXRhXHJcbiAqIHRoYXQgaXMgYXZhaWxhYmxlIGFzIHNvb24gYXMgdGhlIHBhZ2UncyByZXNvdXJjZXMgYXJlIGxvYWRlZCAoYmVmb3JlIERPTVxyXG4gKiBjb250ZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nKS4gVGhpcyBkYXRhIGluY2x1ZGVzIGJvdGggbG9jYWxpemVkIHN0cmluZ3MgYW5kXHJcbiAqIGFueSBkYXRhIHRoYXQgaXMgaW1wb3J0YW50IHRvIGhhdmUgcmVhZHkgZnJvbSBhIHZlcnkgZWFybHkgc3RhZ2UgKGUuZy4gdGhpbmdzXHJcbiAqIHRoYXQgbXVzdCBiZSBkaXNwbGF5ZWQgcmlnaHQgYXdheSkuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBsb2FkVGltZURhdGEgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudCBiZXR3ZWVuIHBhZ2VcclxuICogcmVmcmVzaGVzIChodHRwczovL2NyYnVnLmNvbS83NDA2MjkpIGFuZCBzaG91bGQgbm90IGNvbnRhaW4gdmFsdWVzIHRoYXQgbWlnaHRcclxuICogY2hhbmdlIGlmIHRoZSBwYWdlIGlzIHJlLW9wZW5lZCBsYXRlci5cclxuICovXHJcblxyXG4vKiogQHR5cGUgeyFMb2FkVGltZURhdGF9ICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcclxuZXhwb3J0IGxldCBsb2FkVGltZURhdGFcclxuXHJcbmNsYXNzIExvYWRUaW1lRGF0YSB7XHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgLyoqIEB0eXBlIHs/T2JqZWN0fSAqL1xyXG4gICAgdGhpcy5kYXRhXyA9IG51bGxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGJhY2tpbmcgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIGdldHRlciBmb3IgfGRhdGFffCB0byBkaXNjb3VyYWdlIGFidXNlIG9mIHRoZSBmb3JtOlxyXG4gICAqXHJcbiAgICogICAgIHZhciB2YWx1ZSA9IGxvYWRUaW1lRGF0YS5kYXRhKClbJ2tleSddO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBkZS1zZXJpYWxpemVkIHBhZ2UgZGF0YS5cclxuICAgKi9cclxuICBzZXQgZGF0YSAodmFsdWUpIHtcclxuICAgIGV4cGVjdCghdGhpcy5kYXRhXywgJ1JlLXNldHRpbmcgZGF0YS4nKVxyXG4gICAgdGhpcy5kYXRhXyA9IHZhbHVlXHJcbiAgfVxyXG5cclxuICBnZXQgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhX1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIElEIG9mIGEgdmFsdWUgdGhhdCBtaWdodCBleGlzdC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHxpZHwgaXMgYSBrZXkgaW4gdGhlIGRpY3Rpb25hcnkuXHJcbiAgICovXHJcbiAgdmFsdWVFeGlzdHMgKGlkKSB7XHJcbiAgICByZXR1cm4gaWQgaW4gdGhpcy5kYXRhX1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmV0Y2hlcyBhIHZhbHVlLCBleHBlY3RpbmcgdGhhdCBpdCBleGlzdHMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBkZXNpcmVkIHZhbHVlLlxyXG4gICAqIEByZXR1cm4geyp9IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldFZhbHVlIChpZCkge1xyXG4gICAgZXhwZWN0KHRoaXMuZGF0YV8sICdObyBkYXRhLiBEaWQgeW91IHJlbWVtYmVyIHRvIGluY2x1ZGUgc3RyaW5ncy5qcz8nKVxyXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmRhdGFfW2lkXVxyXG4gICAgZXhwZWN0KHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcsICdDb3VsZCBub3QgZmluZCB2YWx1ZSBmb3IgJyArIGlkKVxyXG4gICAgcmV0dXJuIHZhbHVlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcyBhYm92ZSwgYnV0IGFsc28gbWFrZXMgc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHN0cmluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGRlc2lyZWQgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvcnJlc3BvbmRpbmcgc3RyaW5nIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldFN0cmluZyAoaWQpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZShpZClcclxuICAgIGV4cGVjdElzVHlwZShpZCwgdmFsdWUsICdzdHJpbmcnKVxyXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodmFsdWUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIGxvY2FsaXplZCBzdHJpbmcgd2hlcmUgJDEgdG8gJDkgYXJlIHJlcGxhY2VkIGJ5IHRoZVxyXG4gICAqIHNlY29uZCB0byB0aGUgdGVudGggYXJndW1lbnQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgc3RyaW5nIHdlIHdhbnQuXHJcbiAgICogQHBhcmFtIHsuLi4oc3RyaW5nfG51bWJlcil9IHZhckFyZ3MgVGhlIGV4dHJhIHZhbHVlcyB0byBpbmNsdWRlIGluIHRoZVxyXG4gICAqICAgICBmb3JtYXR0ZWQgb3V0cHV0LlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZ2V0U3RyaW5nRiAoaWQsIHZhckFyZ3MpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRTdHJpbmcoaWQpXHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIHJldHVybiAnJ1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcbiAgICBhcmdzWzBdID0gdmFsdWVcclxuICAgIHJldHVybiB0aGlzLnN1YnN0aXR1dGVTdHJpbmcuYXBwbHkodGhpcywgYXJncylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgbG9jYWxpemVkIHN0cmluZyB3aGVyZSAkMSB0byAkOSBhcmUgcmVwbGFjZWQgYnkgdGhlXHJcbiAgICogc2Vjb25kIHRvIHRoZSB0ZW50aCBhcmd1bWVudC4gQW55IHN0YW5kYWxvbmUgJCBzaWducyBtdXN0IGJlIGVzY2FwZWQgYXNcclxuICAgKiAkJC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgVGhlIGxhYmVsIHRvIHN1YnN0aXR1dGUgdGhyb3VnaC5cclxuICAgKiAgICAgVGhpcyBpcyBub3QgYW4gcmVzb3VyY2UgSUQuXHJcbiAgICogQHBhcmFtIHsuLi4oc3RyaW5nfG51bWJlcil9IHZhckFyZ3MgVGhlIGV4dHJhIHZhbHVlcyB0byBpbmNsdWRlIGluIHRoZVxyXG4gICAqICAgICBmb3JtYXR0ZWQgb3V0cHV0LlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgc3Vic3RpdHV0ZVN0cmluZyAobGFiZWwsIHZhckFyZ3MpIHtcclxuICAgIHJldHVybiBsYWJlbC5yZXBsYWNlKC9cXCQoLnwkfFxcbikvZywgZnVuY3Rpb24gKG0pIHtcclxuICAgICAgZXhwZWN0KG0ubWF0Y2goL1xcJFskMS05XS8pLCAnVW5lc2NhcGVkICQgZm91bmQgaW4gbG9jYWxpemVkIHN0cmluZy4nKVxyXG4gICAgICByZXR1cm4gbSA9PT0gJyQkJyA/ICckJyA6IHZhckFyZ3NbbVsxXV1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcyBhYm92ZSwgYnV0IGFsc28gbWFrZXMgc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBkZXNpcmVkIGJvb2xlYW4uXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGNvcnJlc3BvbmRpbmcgYm9vbGVhbiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRCb29sZWFuIChpZCkge1xyXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGlkKVxyXG4gICAgZXhwZWN0SXNUeXBlKGlkLCB2YWx1ZSwgJ2Jvb2xlYW4nKVxyXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHZhbHVlKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXMgYWJvdmUsIGJ1dCBhbHNvIG1ha2VzIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlci5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGRlc2lyZWQgbnVtYmVyLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldEludGVnZXIgKGlkKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaWQpXHJcbiAgICBleHBlY3RJc1R5cGUoaWQsIHZhbHVlLCAnbnVtYmVyJylcclxuICAgIGV4cGVjdCh2YWx1ZSA9PT0gTWF0aC5mbG9vcih2YWx1ZSksICdOdW1iZXIgaXNuXFwndCBpbnRlZ2VyOiAnICsgdmFsdWUpXHJcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHZhbHVlcyBpbiBsb2FkVGltZURhdGEgd2l0aCB0aGUgdmFsdWVzIGZvdW5kIGluIHxyZXBsYWNlbWVudHN8LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXBsYWNlbWVudHMgVGhlIGRpY3Rpb25hcnkgb2JqZWN0IG9mIGtleXMgdG8gcmVwbGFjZS5cclxuICAgKi9cclxuICBvdmVycmlkZVZhbHVlcyAocmVwbGFjZW1lbnRzKSB7XHJcbiAgICBleHBlY3QoXHJcbiAgICAgIHR5cGVvZiByZXBsYWNlbWVudHMgPT09ICdvYmplY3QnLFxyXG4gICAgICAnUmVwbGFjZW1lbnRzIG11c3QgYmUgYSBkaWN0aW9uYXJ5IG9iamVjdC4nKVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVwbGFjZW1lbnRzKSB7XHJcbiAgICAgIHRoaXMuZGF0YV9ba2V5XSA9IHJlcGxhY2VtZW50c1trZXldXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGNvbmRpdGlvbiwgdGhyb3dzIGVycm9yIG1lc3NhZ2UgaWYgZXhwZWN0YXRpb24gZmFpbHMuXHJcbiAqIEBwYXJhbSB7Kn0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gdG8gY2hlY2sgZm9yIHRydXRoaW5lc3MuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGRpc3BsYXkgaWYgdGhlIGNoZWNrIGZhaWxzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGVjdCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgJ1VuZXhwZWN0ZWQgY29uZGl0aW9uIG9uICcgKyBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJzogJyArIG1lc3NhZ2UpXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGhhcyB0aGUgZ2l2ZW4gdHlwZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgdmFsdWUgKG9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZSkuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrIHRoZSB0eXBlIG9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSB3ZSBleHBlY3QgfHZhbHVlfCB0byBiZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleHBlY3RJc1R5cGUgKGlkLCB2YWx1ZSwgdHlwZSkge1xyXG4gIGV4cGVjdChcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2ZcclxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gdHlwZSwgJ1snICsgdmFsdWUgKyAnXSAoJyArIGlkICsgJykgaXMgbm90IGEgJyArIHR5cGUpXHJcbn1cclxuZXhwZWN0KCFsb2FkVGltZURhdGEsICdzaG91bGQgb25seSBpbmNsdWRlIHRoaXMgZmlsZSBvbmNlJylcclxuXHJcbmxvYWRUaW1lRGF0YSA9IG5ldyBMb2FkVGltZURhdGEoKVxyXG5cclxubG9hZFRpbWVEYXRhLmRhdGEgPSB7XHJcbiAgZGlub0dhbWVBMTF5QXJpYUxhYmVsOiAnRGlubyBnYW1lLCBwbGF5JyxcclxuICBkaW5vR2FtZUExMXlEZXNjcmlwdGlvbjogJ0Rpbm8gZ2FtZS4gQSBwaXhlbGF0ZWQgZGlub3NhdXIgZG9kZ2VzIGNhY3RpIGFuZCBwdGVyb2RhY3R5bHMgYXMgaXQgcnVucyBhY3Jvc3MgYSBkZXNvbGF0ZSBsYW5kc2NhcGUuIFdoZW4geW91IGhlYXIgYW4gYXVkaW8gY3VlLCBwcmVzcyBzcGFjZSB0byBqdW1wIG92ZXIgb2JzdGFjbGVzLicsXHJcbiAgZGlub0dhbWVBMTF5R2FtZU92ZXI6ICdHYW1lIG92ZXIsIHlvdXIgc2NvcmUgaXMgJDEuJyxcclxuICBkaW5vR2FtZUExMXlIaWdoU2NvcmU6ICdZb3VyIGhpZ2hlc3Qgc2NvcmUgaXMgJDEuJyxcclxuICBkaW5vR2FtZUExMXlKdW1wOiAnSnVtcCEnLFxyXG4gIGRpbm9HYW1lQTExeVNwZWVkVG9nZ2xlOiAnU3RhcnQgc2xvd2VyJyxcclxuICBkaW5vR2FtZUExMXlTdGFydEdhbWU6ICdHYW1lIHN0YXJ0ZWQuJyxcclxuICBlcnJvckNvZGU6ICcnLFxyXG4gIGZvbnRmYW1pbHk6IFwiJ1NlZ29lIFVJJywgVGFob21hLCBzYW5zLXNlcmlmXCIsXHJcbiAgZm9udHNpemU6ICc3NSUnLFxyXG4gIGhlYWRpbmc6IHsgaG9zdE5hbWU6ICdkaW5vJywgbXNnOiAnUHJlc3Mgc3BhY2UgdG8gcGxheScgfSxcclxuICBpY29uQ2xhc3M6ICdpY29uLW9mZmxpbmUnLFxyXG4gIGxhbmd1YWdlOiAnZW4nLFxyXG4gIHRleHRkaXJlY3Rpb246ICdsdHInLFxyXG4gIHRpdGxlOiAnY2hyb21lOi8vZGluby8nXHJcbn1cclxuLy8gRXhwb3NlIHxsb2FkVGltZURhdGF8IGRpcmVjdGx5IG9uIHx3aW5kb3d8LCBzaW5jZSB3aXRoaW4gYSBKUyBtb2R1bGUgdGhlXHJcbi8vIHNjb3BlIGlzIGxvY2FsIGFuZCBub3QgYWxsIGZpbGVzIGhhdmUgYmVlbiB1cGRhdGVkIHRvIGltcG9ydCB0aGUgZXhwb3J0ZWRcclxuLy8gfGxvYWRUaW1lRGF0YXwgZXhwbGljaXRseS5cclxud2luZG93LmxvYWRUaW1lRGF0YSA9IGxvYWRUaW1lRGF0YVxyXG4iLCJpbXBvcnQgeyBzcHJpdGVEZWZpbml0aW9uQnlUeXBlLCBHQU1FX1RZUEUsIEhJRERFTl9DTEFTUyB9IGZyb20gJy4vb2ZmbGluZS1zcHJpdGUtZGVmaW5pdGlvbnMnXHJcbmltcG9ydCB7IGxvYWRUaW1lRGF0YSB9IGZyb20gJy4vbG9hZF90aW1lX2RhdGFfZGVwcmVjYXRlZCdcclxuXHJcbi8vIENvcHlyaWdodCAyMDE0IFRoZSBDaHJvbWl1bSBBdXRob3JzXHJcbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cclxuXHJcbi8qKlxyXG4gKiBULVJleCBydW5uZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvdXRlckNvbnRhaW5lcklkIE91dGVyIGNvbnRhaW5pbmcgZWxlbWVudCBpZC5cclxuICogQHBhcmFtIHshT2JqZWN0PX0gb3B0Q29uZmlnXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAaW1wbGVtZW50cyB7RXZlbnRMaXN0ZW5lcn1cclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUnVubmVyIChvdXRlckNvbnRhaW5lcklkLCBvcHRDb25maWcpIHtcclxuICAvLyBTaW5nbGV0b25cclxuICBpZiAoUnVubmVyLmluc3RhbmNlXykge1xyXG4gICAgcmV0dXJuIFJ1bm5lci5pbnN0YW5jZV9cclxuICB9XHJcbiAgUnVubmVyLmluc3RhbmNlXyA9IHRoaXNcclxuICBSdW5uZXIuc3ByaXRlRGVmaW5pdGlvbkJ5VHlwZSA9IHNwcml0ZURlZmluaXRpb25CeVR5cGVcclxuXHJcbiAgdGhpcy5vdXRlckNvbnRhaW5lckVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvdXRlckNvbnRhaW5lcklkKVxyXG4gIHRoaXMuY29udGFpbmVyRWwgPSBudWxsXHJcbiAgdGhpcy5zbmFja2JhckVsID0gbnVsbFxyXG4gIC8vIEEgZGl2IHRvIGludGVyY2VwdCB0b3VjaCBldmVudHMuIE9ubHkgc2V0IHdoaWxlIChwbGF5aW5nICYmIHVzZVRvdWNoKS5cclxuICB0aGlzLnRvdWNoQ29udHJvbGxlciA9IG51bGxcclxuXHJcbiAgdGhpcy5jb25maWcgPSBvcHRDb25maWcgfHwgT2JqZWN0LmFzc2lnbihSdW5uZXIuY29uZmlnLCBSdW5uZXIubm9ybWFsQ29uZmlnKVxyXG4gIC8vIExvZ2ljYWwgZGltZW5zaW9ucyBvZiB0aGUgY29udGFpbmVyLlxyXG4gIHRoaXMuZGltZW5zaW9ucyA9IFJ1bm5lci5kZWZhdWx0RGltZW5zaW9uc1xyXG5cclxuICB0aGlzLmdhbWVUeXBlID0gbnVsbFxyXG4gIFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uID0gUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGUub3JpZ2luYWxcclxuXHJcbiAgdGhpcy5hbHRHYW1lSW1hZ2VTcHJpdGUgPSBudWxsXHJcbiAgdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSA9IGZhbHNlXHJcbiAgdGhpcy5hbHRHYW1lTW9kZUZsYXNoVGltZXIgPSBudWxsXHJcbiAgdGhpcy5mYWRlSW5UaW1lciA9IDBcclxuXHJcbiAgdGhpcy5jYW52YXMgPSBudWxsXHJcbiAgdGhpcy5jYW52YXNDdHggPSBudWxsXHJcblxyXG4gIHRoaXMudFJleCA9IG51bGxcclxuXHJcbiAgdGhpcy5kaXN0YW5jZU1ldGVyID0gbnVsbFxyXG4gIHRoaXMuZGlzdGFuY2VSYW4gPSAwXHJcblxyXG4gIHRoaXMuaGlnaGVzdFNjb3JlID0gMFxyXG4gIHRoaXMuc3luY0hpZ2hlc3RTY29yZSA9IGZhbHNlXHJcblxyXG4gIHRoaXMudGltZSA9IDBcclxuICB0aGlzLnJ1bm5pbmdUaW1lID0gMFxyXG4gIHRoaXMubXNQZXJGcmFtZSA9IDEwMDAgLyBGUFNcclxuICB0aGlzLmN1cnJlbnRTcGVlZCA9IHRoaXMuY29uZmlnLlNQRUVEXHJcbiAgUnVubmVyLnNsb3dEb3duID0gZmFsc2VcclxuXHJcbiAgdGhpcy5vYnN0YWNsZXMgPSBbXVxyXG5cclxuICB0aGlzLmFjdGl2YXRlZCA9IGZhbHNlIC8vIFdoZXRoZXIgdGhlIGVhc3RlciBlZ2cgaGFzIGJlZW4gYWN0aXZhdGVkLlxyXG4gIHRoaXMucGxheWluZyA9IGZhbHNlIC8vIFdoZXRoZXIgdGhlIGdhbWUgaXMgY3VycmVudGx5IGluIHBsYXkgc3RhdGUuXHJcbiAgdGhpcy5jcmFzaGVkID0gZmFsc2VcclxuICB0aGlzLnBhdXNlZCA9IGZhbHNlXHJcbiAgdGhpcy5pbnZlcnRlZCA9IGZhbHNlXHJcbiAgdGhpcy5pbnZlcnRUaW1lciA9IDBcclxuICB0aGlzLnJlc2l6ZVRpbWVySWRfID0gbnVsbFxyXG5cclxuICB0aGlzLnBsYXlDb3VudCA9IDBcclxuXHJcbiAgLy8gU291bmQgRlguXHJcbiAgdGhpcy5hdWRpb0J1ZmZlciA9IG51bGxcclxuXHJcbiAgLyoqIEB0eXBlIHtPYmplY3R9ICovXHJcbiAgdGhpcy5zb3VuZEZ4ID0ge31cclxuICB0aGlzLmdlbmVyYXRlZFNvdW5kRnggPSBudWxsXHJcblxyXG4gIC8vIEdsb2JhbCB3ZWIgYXVkaW8gY29udGV4dCBmb3IgcGxheWluZyBzb3VuZHMuXHJcbiAgdGhpcy5hdWRpb0NvbnRleHQgPSBudWxsXHJcblxyXG4gIC8vIEltYWdlcy5cclxuICB0aGlzLmltYWdlcyA9IHt9XHJcbiAgdGhpcy5pbWFnZXNMb2FkZWQgPSAwXHJcblxyXG4gIC8vIEdhbWVwYWQgc3RhdGUuXHJcbiAgdGhpcy5wb2xsaW5nR2FtZXBhZHMgPSBmYWxzZVxyXG4gIHRoaXMuZ2FtZXBhZEluZGV4ID0gdW5kZWZpbmVkXHJcbiAgdGhpcy5wcmV2aW91c0dhbWVwYWQgPSBudWxsXHJcblxyXG4gIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xyXG4gICAgdGhpcy5zZXR1cERpc2FibGVkUnVubmVyKClcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKFJ1bm5lci5pc0FsdEdhbWVNb2RlRW5hYmxlZCgpKSB7XHJcbiAgICAgIHRoaXMuaW5pdEFsdEdhbWVUeXBlKClcclxuICAgICAgUnVubmVyLmdhbWVUeXBlID0gdGhpcy5nYW1lVHlwZVxyXG4gICAgfVxyXG4gICAgdGhpcy5sb2FkSW1hZ2VzKClcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVFYXN0ZXJFZ2dIaWdoU2NvcmUgPSB0aGlzLmluaXRpYWxpemVIaWdoU2NvcmUuYmluZCh0aGlzKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgZ2FtZSB3aWR0aC5cclxuICogQGNvbnN0XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgREVGQVVMVF9XSURUSCA9IDYwMFxyXG5cclxuLyoqXHJcbiAqIEZyYW1lcyBwZXIgc2Vjb25kLlxyXG4gKiBAY29uc3RcclxuICovXHJcbmV4cG9ydCBjb25zdCBGUFMgPSA2MFxyXG5cclxuLyoqIEBjb25zdCAqL1xyXG5leHBvcnQgY29uc3QgSVNfSElEUEkgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDFcclxuXHJcbi8qKiBAY29uc3QgKi9cclxuZXhwb3J0IGNvbnN0IElTX0lPUyA9IC9DcmlPUy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcclxuXHJcbi8qKiBAY29uc3QgKi9cclxuZXhwb3J0IGNvbnN0IElTX01PQklMRSA9IC9BbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCBJU19JT1NcclxuXHJcbi8qKiBAY29uc3QgKi9cclxuZXhwb3J0IGNvbnN0IElTX1JUTCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwnKS5kaXIgPT09ICdydGwnXHJcblxyXG4vKiogQGNvbnN0ICovXHJcbmV4cG9ydCBjb25zdCBBUkNBREVfTU9ERV9VUkwgPSAnY2hyb21lOi8vZGluby8nXHJcblxyXG4vKiogQGNvbnN0ICovXHJcbmV4cG9ydCBjb25zdCBSRVNPVVJDRV9QT1NURklYID0gJ29mZmxpbmUtcmVzb3VyY2VzLSdcclxuXHJcbi8qKiBAY29uc3QgKi9cclxuZXhwb3J0IGNvbnN0IEExMVlfU1RSSU5HUyA9IHtcclxuICBhcmlhTGFiZWw6ICdkaW5vR2FtZUExMXlBcmlhTGFiZWwnLFxyXG4gIGRlc2NyaXB0aW9uOiAnZGlub0dhbWVBMTF5RGVzY3JpcHRpb24nLFxyXG4gIGdhbWVPdmVyOiAnZGlub0dhbWVBMTF5R2FtZU92ZXInLFxyXG4gIGhpZ2hTY29yZTogJ2Rpbm9HYW1lQTExeUhpZ2hTY29yZScsXHJcbiAganVtcDogJ2Rpbm9HYW1lQTExeUp1bXAnLFxyXG4gIHN0YXJ0ZWQ6ICdkaW5vR2FtZUExMXlTdGFydEdhbWUnLFxyXG4gIHNwZWVkTGFiZWw6ICdkaW5vR2FtZUExMXlTcGVlZFRvZ2dsZSdcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgZ2FtZSBjb25maWd1cmF0aW9uLlxyXG4gKiBTaGFyZWQgY29uZmlnIGZvciBhbGwgIHZlcnNpb25zIG9mIHRoZSBnYW1lLiBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgYXJlXHJcbiAqIGRlZmluZWQgaW4gUnVubmVyLm5vcm1hbENvbmZpZyBhbmQgUnVubmVyLnNsb3dDb25maWcuXHJcbiAqL1xyXG5SdW5uZXIuY29uZmlnID0ge1xyXG4gIEFVRElPQ1VFX1BST1hJTUlUWV9USFJFU0hPTEQ6IDE5MCxcclxuICBBVURJT0NVRV9QUk9YSU1JVFlfVEhSRVNIT0xEX01PQklMRV9BMTFZOiAyNTAsXHJcbiAgQkdfQ0xPVURfU1BFRUQ6IDAuMixcclxuICBCT1RUT01fUEFEOiAxMCxcclxuICAvLyBTY3JvbGwgWSB0aHJlc2hvbGQgYXQgd2hpY2ggdGhlIGdhbWUgY2FuIGJlIGFjdGl2YXRlZC5cclxuICBDQU5WQVNfSU5fVklFV19PRkZTRVQ6IC0xMCxcclxuICBDTEVBUl9USU1FOiAzMDAwLFxyXG4gIENMT1VEX0ZSRVFVRU5DWTogMC41LFxyXG4gIEZBREVfRFVSQVRJT046IDEsXHJcbiAgRkxBU0hfRFVSQVRJT046IDEwMDAsXHJcbiAgR0FNRU9WRVJfQ0xFQVJfVElNRTogMTIwMCxcclxuICBJTklUSUFMX0pVTVBfVkVMT0NJVFk6IDEyLFxyXG4gIElOVkVSVF9GQURFX0RVUkFUSU9OOiAxMjAwMCxcclxuICBNQVhfQkxJTktfQ09VTlQ6IDMsXHJcbiAgTUFYX0NMT1VEUzogNixcclxuICBNQVhfT0JTVEFDTEVfTEVOR1RIOiAzLFxyXG4gIE1BWF9PQlNUQUNMRV9EVVBMSUNBVElPTjogMixcclxuICBSRVNPVVJDRV9URU1QTEFURV9JRDogJ2F1ZGlvLXJlc291cmNlcycsXHJcbiAgU1BFRUQ6IDYsXHJcbiAgU1BFRURfRFJPUF9DT0VGRklDSUVOVDogMyxcclxuICBBUkNBREVfTU9ERV9JTklUSUFMX1RPUF9QT1NJVElPTjogMzUsXHJcbiAgQVJDQURFX01PREVfVE9QX1BPU0lUSU9OX1BFUkNFTlQ6IDAuMVxyXG59XHJcblxyXG5SdW5uZXIubm9ybWFsQ29uZmlnID0ge1xyXG4gIEFDQ0VMRVJBVElPTjogMC4wMDEsXHJcbiAgQVVESU9DVUVfUFJPWElNSVRZX1RIUkVTSE9MRDogMTkwLFxyXG4gIEFVRElPQ1VFX1BST1hJTUlUWV9USFJFU0hPTERfTU9CSUxFX0ExMVk6IDI1MCxcclxuICBHQVBfQ09FRkZJQ0lFTlQ6IDAuNixcclxuICBJTlZFUlRfRElTVEFOQ0U6IDcwMCxcclxuICBNQVhfU1BFRUQ6IDEzLFxyXG4gIE1PQklMRV9TUEVFRF9DT0VGRklDSUVOVDogMS4yLFxyXG4gIFNQRUVEOiA2XHJcbn1cclxuXHJcblJ1bm5lci5zbG93Q29uZmlnID0ge1xyXG4gIEFDQ0VMRVJBVElPTjogMC4wMDA1LFxyXG4gIEFVRElPQ1VFX1BST1hJTUlUWV9USFJFU0hPTEQ6IDE3MCxcclxuICBBVURJT0NVRV9QUk9YSU1JVFlfVEhSRVNIT0xEX01PQklMRV9BMTFZOiAyMjAsXHJcbiAgR0FQX0NPRUZGSUNJRU5UOiAwLjMsXHJcbiAgSU5WRVJUX0RJU1RBTkNFOiAzNTAsXHJcbiAgTUFYX1NQRUVEOiA5LFxyXG4gIE1PQklMRV9TUEVFRF9DT0VGRklDSUVOVDogMS41LFxyXG4gIFNQRUVEOiA0LjJcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgZGltZW5zaW9ucy5cclxuICovXHJcblJ1bm5lci5kZWZhdWx0RGltZW5zaW9ucyA9IHtcclxuICBXSURUSDogREVGQVVMVF9XSURUSCxcclxuICBIRUlHSFQ6IDE1MFxyXG59XHJcblxyXG4vKipcclxuICogQ1NTIGNsYXNzIG5hbWVzLlxyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKi9cclxuUnVubmVyLmNsYXNzZXMgPSB7XHJcbiAgQVJDQURFX01PREU6ICdhcmNhZGUtbW9kZScsXHJcbiAgQ0FOVkFTOiAncnVubmVyLWNhbnZhcycsXHJcbiAgQ09OVEFJTkVSOiAncnVubmVyLWNvbnRhaW5lcicsXHJcbiAgQ1JBU0hFRDogJ2NyYXNoZWQnLFxyXG4gIElDT046ICdpY29uLW9mZmxpbmUnLFxyXG4gIElOVkVSVEVEOiAnaW52ZXJ0ZWQnLFxyXG4gIFNOQUNLQkFSOiAnc25hY2tiYXInLFxyXG4gIFNOQUNLQkFSX1NIT1c6ICdzbmFja2Jhci1zaG93JyxcclxuICBUT1VDSF9DT05UUk9MTEVSOiAnY29udHJvbGxlcidcclxufVxyXG5cclxuLyoqXHJcbiAqIFNvdW5kIEZYLiBSZWZlcmVuY2UgdG8gdGhlIElEIG9mIHRoZSBhdWRpbyB0YWcgb24gaW50ZXJzdGl0aWFsIHBhZ2UuXHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5SdW5uZXIuc291bmRzID0ge1xyXG4gIEJVVFRPTl9QUkVTUzogJ29mZmxpbmUtc291bmQtcHJlc3MnLFxyXG4gIEhJVDogJ29mZmxpbmUtc291bmQtaGl0JyxcclxuICBTQ09SRTogJ29mZmxpbmUtc291bmQtcmVhY2hlZCdcclxufVxyXG5cclxuLyoqXHJcbiAqIEtleSBjb2RlIG1hcHBpbmcuXHJcbiAqIEBlbnVtIHtPYmplY3R9XHJcbiAqL1xyXG5SdW5uZXIua2V5Y29kZXMgPSB7XHJcbiAgSlVNUDogeyAzODogMSwgMzI6IDEgfSwgLy8gVXAsIHNwYWNlYmFyXHJcbiAgRFVDSzogeyA0MDogMSB9LCAvLyBEb3duXHJcbiAgUkVTVEFSVDogeyAxMzogMSB9IC8vIEVudGVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW5uZXIgZXZlbnQgbmFtZXMuXHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5SdW5uZXIuZXZlbnRzID0ge1xyXG4gIEFOSU1fRU5EOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcclxuICBDTElDSzogJ2NsaWNrJyxcclxuICBLRVlET1dOOiAna2V5ZG93bicsXHJcbiAgS0VZVVA6ICdrZXl1cCcsXHJcbiAgUE9JTlRFUkRPV046ICdwb2ludGVyZG93bicsXHJcbiAgUE9JTlRFUlVQOiAncG9pbnRlcnVwJyxcclxuICBSRVNJWkU6ICdyZXNpemUnLFxyXG4gIFRPVUNIRU5EOiAndG91Y2hlbmQnLFxyXG4gIFRPVUNIU1RBUlQ6ICd0b3VjaHN0YXJ0JyxcclxuICBWSVNJQklMSVRZOiAndmlzaWJpbGl0eWNoYW5nZScsXHJcbiAgQkxVUjogJ2JsdXInLFxyXG4gIEZPQ1VTOiAnZm9jdXMnLFxyXG4gIExPQUQ6ICdsb2FkJyxcclxuICBHQU1FUEFEQ09OTkVDVEVEOiAnZ2FtZXBhZGNvbm5lY3RlZCdcclxufVxyXG5cclxuUnVubmVyLnByb3RvdHlwZSA9IHtcclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGFsdGVybmF0aXZlIGdhbWUgdHlwZS5cclxuICAgKi9cclxuICBpbml0QWx0R2FtZVR5cGUgKCkge1xyXG4gICAgaWYgKEdBTUVfVFlQRS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuZ2FtZVR5cGUgPSBsb2FkVGltZURhdGEgJiYgbG9hZFRpbWVEYXRhLnZhbHVlRXhpc3RzKCdhbHRHYW1lVHlwZScpXHJcbiAgICAgICAgPyBHQU1FX1RZUEVbcGFyc2VJbnQobG9hZFRpbWVEYXRhLmdldFZhbHVlKCdhbHRHYW1lVHlwZScpLCAxMCkgLSAxXVxyXG4gICAgICAgIDogJydcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBlYXN0ZXIgZWdnIGhhcyBiZWVuIGRpc2FibGVkLiBDck9TIGVudGVycHJpc2UgZW5yb2xsZWQgZGV2aWNlcy5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGlzRGlzYWJsZWQgKCkge1xyXG4gICAgcmV0dXJuIGxvYWRUaW1lRGF0YSAmJiBsb2FkVGltZURhdGEudmFsdWVFeGlzdHMoJ2Rpc2FibGVkRWFzdGVyRWdnJylcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBGb3IgZGlzYWJsZWQgaW5zdGFuY2VzLCBzZXQgdXAgYSBzbmFja2JhciB3aXRoIHRoZSBkaXNhYmxlZCBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHNldHVwRGlzYWJsZWRSdW5uZXIgKCkge1xyXG4gICAgdGhpcy5jb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICB0aGlzLmNvbnRhaW5lckVsLmNsYXNzTmFtZSA9IFJ1bm5lci5jbGFzc2VzLlNOQUNLQkFSXHJcbiAgICB0aGlzLmNvbnRhaW5lckVsLnRleHRDb250ZW50ID0gbG9hZFRpbWVEYXRhLmdldFZhbHVlKCdkaXNhYmxlZEVhc3RlckVnZycpXHJcbiAgICB0aGlzLm91dGVyQ29udGFpbmVyRWwuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXJFbClcclxuXHJcbiAgICAvLyBTaG93IG5vdGlmaWNhdGlvbiB3aGVuIHRoZSBhY3RpdmF0aW9uIGtleSBpcyBwcmVzc2VkLlxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLktFWURPV04sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmIChSdW5uZXIua2V5Y29kZXMuSlVNUFtlLmtleUNvZGVdKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5jbGFzc0xpc3QuYWRkKFJ1bm5lci5jbGFzc2VzLlNOQUNLQkFSX1NIT1cpXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmljb24nKS5jbGFzc0xpc3QuYWRkKCdpY29uLWRpc2FibGVkJylcclxuICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRpbmcgaW5kaXZpZHVhbCBzZXR0aW5ncyBmb3IgZGVidWdnaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXR0aW5nXHJcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gICAqL1xyXG4gIHVwZGF0ZUNvbmZpZ1NldHRpbmcgKHNldHRpbmcsIHZhbHVlKSB7XHJcbiAgICBpZiAoc2V0dGluZyBpbiB0aGlzLmNvbmZpZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuY29uZmlnW3NldHRpbmddID0gdmFsdWVcclxuXHJcbiAgICAgIHN3aXRjaCAoc2V0dGluZykge1xyXG4gICAgICAgIGNhc2UgJ0dSQVZJVFknOlxyXG4gICAgICAgIGNhc2UgJ01JTl9KVU1QX0hFSUdIVCc6XHJcbiAgICAgICAgY2FzZSAnU1BFRURfRFJPUF9DT0VGRklDSUVOVCc6XHJcbiAgICAgICAgICB0aGlzLnRSZXguY29uZmlnW3NldHRpbmddID0gdmFsdWVcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnSU5JVElBTF9KVU1QX1ZFTE9DSVRZJzpcclxuICAgICAgICAgIHRoaXMudFJleC5zZXRKdW1wVmVsb2NpdHkodmFsdWUpXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ1NQRUVEJzpcclxuICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSkpXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBvbiBwYWdlIGltYWdlIGVsZW1lbnQgZnJvbSB0aGUgYmFzZSA2NCBlbmNvZGVkIHN0cmluZyBzb3VyY2UuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlTmFtZSBOYW1lIGluIGRhdGEgb2JqZWN0LFxyXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IFRoZSBjcmVhdGVkIGVsZW1lbnQuXHJcbiAgICovXHJcbiAgY3JlYXRlSW1hZ2VFbGVtZW50IChyZXNvdXJjZU5hbWUpIHtcclxuICAgIGNvbnN0IGltZ1NyYyA9IGxvYWRUaW1lRGF0YSAmJiBsb2FkVGltZURhdGEudmFsdWVFeGlzdHMocmVzb3VyY2VOYW1lKVxyXG4gICAgICA/IGxvYWRUaW1lRGF0YS5nZXRTdHJpbmcocmVzb3VyY2VOYW1lKVxyXG4gICAgICA6IG51bGxcclxuXHJcbiAgICBpZiAoaW1nU3JjKSB7XHJcbiAgICAgIGNvbnN0IGVsID1cclxuICAgICAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKSlcclxuICAgICAgZWwuaWQgPSByZXNvdXJjZU5hbWVcclxuICAgICAgZWwuc3JjID0gaW1nU3JjXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvZmZsaW5lLXJlc291cmNlcycpLmFwcGVuZENoaWxkKGVsKVxyXG4gICAgICByZXR1cm4gZWxcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FjaGUgdGhlIGFwcHJvcHJpYXRlIGltYWdlIHNwcml0ZSBmcm9tIHRoZSBwYWdlIGFuZCBnZXQgdGhlIHNwcml0ZSBzaGVldFxyXG4gICAqIGRlZmluaXRpb24uXHJcbiAgICovXHJcbiAgbG9hZEltYWdlcyAoKSB7XHJcbiAgICBsZXQgc2NhbGUgPSAnMXgnXHJcbiAgICB0aGlzLnNwcml0ZURlZiA9IFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLkxEUElcclxuICAgIGlmIChJU19ISURQSSkge1xyXG4gICAgICBzY2FsZSA9ICcyeCdcclxuICAgICAgdGhpcy5zcHJpdGVEZWYgPSBSdW5uZXIuc3ByaXRlRGVmaW5pdGlvbi5IRFBJXHJcbiAgICB9XHJcblxyXG4gICAgUnVubmVyLmltYWdlU3ByaXRlID0gLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqL1xyXG4gICAgICAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoUkVTT1VSQ0VfUE9TVEZJWCArIHNjYWxlKSlcclxuXHJcbiAgICBpZiAodGhpcy5nYW1lVHlwZSkge1xyXG4gICAgICBSdW5uZXIuYWx0R2FtZUltYWdlU3ByaXRlID0gLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqL1xyXG4gICAgICAgICh0aGlzLmNyZWF0ZUltYWdlRWxlbWVudCgnYWx0R2FtZVNwZWNpZmljSW1hZ2UnICsgc2NhbGUpKVxyXG4gICAgICBSdW5uZXIuYWx0Q29tbW9uSW1hZ2VTcHJpdGUgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovXHJcbiAgICAgICAgKHRoaXMuY3JlYXRlSW1hZ2VFbGVtZW50KCdhbHRHYW1lQ29tbW9uSW1hZ2UnICsgc2NhbGUpKVxyXG4gICAgfVxyXG4gICAgUnVubmVyLm9yaWdJbWFnZVNwcml0ZSA9IFJ1bm5lci5pbWFnZVNwcml0ZVxyXG5cclxuICAgIC8vIERpc2FibGUgdGhlIGFsdCBnYW1lIG1vZGUgaWYgdGhlIHNwcml0ZXMgY2FuJ3QgYmUgbG9hZGVkLlxyXG4gICAgaWYgKCFSdW5uZXIuYWx0R2FtZUltYWdlU3ByaXRlIHx8ICFSdW5uZXIuYWx0Q29tbW9uSW1hZ2VTcHJpdGUpIHtcclxuICAgICAgUnVubmVyLmlzQWx0R2FtZU1vZGVFbmFibGVkID0gKCkgPT4gZmFsc2VcclxuICAgICAgdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSA9IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFJ1bm5lci5pbWFnZVNwcml0ZS5jb21wbGV0ZSkge1xyXG4gICAgICB0aGlzLmluaXQoKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gSWYgdGhlIGltYWdlcyBhcmUgbm90IHlldCBsb2FkZWQsIGFkZCBhIGxpc3RlbmVyLlxyXG4gICAgICBSdW5uZXIuaW1hZ2VTcHJpdGUuYWRkRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLkxPQUQsXHJcbiAgICAgICAgdGhpcy5pbml0LmJpbmQodGhpcykpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBhbmQgZGVjb2RlIGJhc2UgNjQgZW5jb2RlZCBzb3VuZHMuXHJcbiAgICovXHJcbiAgbG9hZFNvdW5kcyAoKSB7XHJcbiAgICBpZiAoIUlTX0lPUykge1xyXG4gICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKVxyXG5cclxuICAgICAgY29uc3QgcmVzb3VyY2VUZW1wbGF0ZSA9XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb25maWcuUkVTT1VSQ0VfVEVNUExBVEVfSUQpLmNvbnRlbnRcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc291bmQgaW4gUnVubmVyLnNvdW5kcykge1xyXG4gICAgICAgIGxldCBzb3VuZFNyYyA9XHJcbiAgICAgICAgICByZXNvdXJjZVRlbXBsYXRlLmdldEVsZW1lbnRCeUlkKFJ1bm5lci5zb3VuZHNbc291bmRdKS5zcmNcclxuICAgICAgICBzb3VuZFNyYyA9IHNvdW5kU3JjLnN1YnN0cihzb3VuZFNyYy5pbmRleE9mKCcsJykgKyAxKVxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGRlY29kZUJhc2U2NFRvQXJyYXlCdWZmZXIoc291bmRTcmMpXHJcblxyXG4gICAgICAgIC8vIEFzeW5jLCBzbyBubyBndWFyYW50ZWUgb2Ygb3JkZXIgaW4gYXJyYXkuXHJcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGJ1ZmZlciwgZnVuY3Rpb24gKGluZGV4LCBhdWRpb0RhdGEpIHtcclxuICAgICAgICAgIHRoaXMuc291bmRGeFtpbmRleF0gPSBhdWRpb0RhdGFcclxuICAgICAgICB9LmJpbmQodGhpcywgc291bmQpKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgZ2FtZSBzcGVlZC4gQWRqdXN0IHRoZSBzcGVlZCBhY2NvcmRpbmdseSBpZiBvbiBhIHNtYWxsZXIgc2NyZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0U3BlZWRcclxuICAgKi9cclxuICBzZXRTcGVlZCAob3B0U3BlZWQpIHtcclxuICAgIGNvbnN0IHNwZWVkID0gb3B0U3BlZWQgfHwgdGhpcy5jdXJyZW50U3BlZWRcclxuXHJcbiAgICAvLyBSZWR1Y2UgdGhlIHNwZWVkIG9uIHNtYWxsZXIgbW9iaWxlIHNjcmVlbnMuXHJcbiAgICBpZiAodGhpcy5kaW1lbnNpb25zLldJRFRIIDwgREVGQVVMVF9XSURUSCkge1xyXG4gICAgICBjb25zdCBtb2JpbGVTcGVlZCA9IFJ1bm5lci5zbG93RG93blxyXG4gICAgICAgID8gc3BlZWRcclxuICAgICAgICA6IHNwZWVkICogdGhpcy5kaW1lbnNpb25zLldJRFRIIC9cclxuICAgICAgICBERUZBVUxUX1dJRFRIICogdGhpcy5jb25maWcuTU9CSUxFX1NQRUVEX0NPRUZGSUNJRU5UXHJcbiAgICAgIHRoaXMuY3VycmVudFNwZWVkID0gbW9iaWxlU3BlZWQgPiBzcGVlZCA/IHNwZWVkIDogbW9iaWxlU3BlZWRcclxuICAgIH0gZWxzZSBpZiAob3B0U3BlZWQpIHtcclxuICAgICAgdGhpcy5jdXJyZW50U3BlZWQgPSBvcHRTcGVlZFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdhbWUgaW5pdGlhbGlzZXIuXHJcbiAgICovXHJcbiAgaW5pdCAoKSB7XHJcbiAgICAvLyBIaWRlIHRoZSBzdGF0aWMgaWNvbi5cclxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgUnVubmVyLmNsYXNzZXMuSUNPTikuc3R5bGUudmlzaWJpbGl0eSA9XHJcbiAgICAgICdoaWRkZW4nXHJcblxyXG4gICAgdGhpcy5hZGp1c3REaW1lbnNpb25zKClcclxuICAgIHRoaXMuc2V0U3BlZWQoKVxyXG5cclxuICAgIGNvbnN0IGFyaWFMYWJlbCA9IGdldEExMXlTdHJpbmcoQTExWV9TVFJJTkdTLmFyaWFMYWJlbClcclxuICAgIHRoaXMuY29udGFpbmVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgdGhpcy5jb250YWluZXJFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBJU19NT0JJTEUgPyAnYnV0dG9uJyA6ICdhcHBsaWNhdGlvbicpXHJcbiAgICB0aGlzLmNvbnRhaW5lckVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpXHJcbiAgICB0aGlzLmNvbnRhaW5lckVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBhcmlhTGFiZWwpXHJcblxyXG4gICAgdGhpcy5jb250YWluZXJFbC5jbGFzc05hbWUgPSBSdW5uZXIuY2xhc3Nlcy5DT05UQUlORVJcclxuXHJcbiAgICAvLyBQbGF5ZXIgY2FudmFzIGNvbnRhaW5lci5cclxuICAgIHRoaXMuY2FudmFzID0gY3JlYXRlQ2FudmFzKHRoaXMuY29udGFpbmVyRWwsIHRoaXMuZGltZW5zaW9ucy5XSURUSCxcclxuICAgICAgdGhpcy5kaW1lbnNpb25zLkhFSUdIVClcclxuXHJcbiAgICAvLyBMaXZlIHJlZ2lvbiBmb3IgZ2FtZSBzdGF0dXMgdXBkYXRlcy5cclxuICAgIHRoaXMuYTExeVN0YXR1c0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXHJcbiAgICB0aGlzLmExMXlTdGF0dXNFbC5jbGFzc05hbWUgPSAnb2ZmbGluZS1ydW5uZXItbGl2ZS1yZWdpb24nXHJcbiAgICB0aGlzLmExMXlTdGF0dXNFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKVxyXG4gICAgdGhpcy5hMTF5U3RhdHVzRWwudGV4dENvbnRlbnQgPSAnJ1xyXG4gICAgUnVubmVyLmExMXlTdGF0dXNFbCA9IHRoaXMuYTExeVN0YXR1c0VsXHJcblxyXG4gICAgLy8gQWRkIGNoZWNrYm94IHRvIHNsb3cgZG93biB0aGUgZ2FtZS5cclxuICAgIHRoaXMuc2xvd1NwZWVkQ2hlY2tib3hMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcclxuICAgIHRoaXMuc2xvd1NwZWVkQ2hlY2tib3hMYWJlbC5jbGFzc05hbWUgPSAnc2xvdy1zcGVlZC1vcHRpb24gaGlkZGVuJ1xyXG4gICAgdGhpcy5zbG93U3BlZWRDaGVja2JveExhYmVsLnRleHRDb250ZW50ID1cclxuICAgICAgZ2V0QTExeVN0cmluZyhBMTFZX1NUUklOR1Muc3BlZWRMYWJlbClcclxuXHJcbiAgICB0aGlzLnNsb3dTcGVlZENoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxyXG4gICAgdGhpcy5zbG93U3BlZWRDaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKVxyXG4gICAgdGhpcy5zbG93U3BlZWRDaGVja2JveC5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICd0aXRsZScsIGdldEExMXlTdHJpbmcoQTExWV9TVFJJTkdTLnNwZWVkTGFiZWwpKVxyXG4gICAgdGhpcy5zbG93U3BlZWRDaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKVxyXG4gICAgdGhpcy5zbG93U3BlZWRDaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpXHJcblxyXG4gICAgdGhpcy5zbG93U3BlZWRUb2dnbGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxyXG4gICAgdGhpcy5zbG93U3BlZWRUb2dnbGVFbC5jbGFzc05hbWUgPSAnc2xvdy1zcGVlZC10b2dnbGUnXHJcblxyXG4gICAgdGhpcy5zbG93U3BlZWRDaGVja2JveExhYmVsLmFwcGVuZENoaWxkKHRoaXMuc2xvd1NwZWVkQ2hlY2tib3gpXHJcbiAgICB0aGlzLnNsb3dTcGVlZENoZWNrYm94TGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5zbG93U3BlZWRUb2dnbGVFbClcclxuXHJcbiAgICBpZiAoSVNfSU9TKSB7XHJcbiAgICAgIHRoaXMub3V0ZXJDb250YWluZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmExMXlTdGF0dXNFbClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQodGhpcy5hMTF5U3RhdHVzRWwpXHJcbiAgICB9XHJcblxyXG4gICAgYW5ub3VuY2VQaHJhc2UoZ2V0QTExeVN0cmluZyhBMTFZX1NUUklOR1MuZGVzY3JpcHRpb24pKVxyXG5cclxuICAgIHRoaXMuZ2VuZXJhdGVkU291bmRGeCA9IG5ldyBHZW5lcmF0ZWRTb3VuZEZ4KClcclxuXHJcbiAgICB0aGlzLmNhbnZhc0N0eCA9XHJcbiAgICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAodGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSlcclxuICAgIHRoaXMuY2FudmFzQ3R4LmZpbGxTdHlsZSA9ICcjZjdmN2Y3J1xyXG4gICAgdGhpcy5jYW52YXNDdHguZmlsbCgpXHJcbiAgICBSdW5uZXIudXBkYXRlQ2FudmFzU2NhbGluZyh0aGlzLmNhbnZhcylcclxuXHJcbiAgICAvLyBIb3Jpem9uIGNvbnRhaW5zIGNsb3Vkcywgb2JzdGFjbGVzIGFuZCB0aGUgZ3JvdW5kLlxyXG4gICAgdGhpcy5ob3Jpem9uID0gbmV3IEhvcml6b24odGhpcy5jYW52YXMsIHRoaXMuc3ByaXRlRGVmLCB0aGlzLmRpbWVuc2lvbnMsXHJcbiAgICAgIHRoaXMuY29uZmlnLkdBUF9DT0VGRklDSUVOVClcclxuXHJcbiAgICAvLyBEaXN0YW5jZSBtZXRlclxyXG4gICAgdGhpcy5kaXN0YW5jZU1ldGVyID0gbmV3IERpc3RhbmNlTWV0ZXIodGhpcy5jYW52YXMsXHJcbiAgICAgIHRoaXMuc3ByaXRlRGVmLlRFWFRfU1BSSVRFLCB0aGlzLmRpbWVuc2lvbnMuV0lEVEgpXHJcblxyXG4gICAgLy8gRHJhdyB0LXJleFxyXG4gICAgdGhpcy50UmV4ID0gbmV3IFRyZXgodGhpcy5jYW52YXMsIHRoaXMuc3ByaXRlRGVmLlRSRVgpXHJcblxyXG4gICAgdGhpcy5vdXRlckNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyRWwpXHJcbiAgICB0aGlzLm91dGVyQ29udGFpbmVyRWwuYXBwZW5kQ2hpbGQodGhpcy5zbG93U3BlZWRDaGVja2JveExhYmVsKVxyXG5cclxuICAgIHRoaXMuc3RhcnRMaXN0ZW5pbmcoKVxyXG4gICAgdGhpcy51cGRhdGUoKVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuUkVTSVpFLFxyXG4gICAgICB0aGlzLmRlYm91bmNlUmVzaXplLmJpbmQodGhpcykpXHJcblxyXG4gICAgLy8gSGFuZGxlIGRhcmsgbW9kZVxyXG4gICAgY29uc3QgZGFya01vZGVNZWRpYVF1ZXJ5ID1cclxuICAgICAgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKVxyXG4gICAgdGhpcy5pc0RhcmtNb2RlID0gZGFya01vZGVNZWRpYVF1ZXJ5ICYmIGRhcmtNb2RlTWVkaWFRdWVyeS5tYXRjaGVzXHJcbiAgICBkYXJrTW9kZU1lZGlhUXVlcnkuYWRkTGlzdGVuZXIoKGUpID0+IHtcclxuICAgICAgdGhpcy5pc0RhcmtNb2RlID0gZS5tYXRjaGVzXHJcbiAgICB9KVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgdG91Y2ggY29udHJvbGxlci4gQSBkaXYgdGhhdCBjb3ZlcnMgd2hvbGUgc2NyZWVuLlxyXG4gICAqL1xyXG4gIGNyZWF0ZVRvdWNoQ29udHJvbGxlciAoKSB7XHJcbiAgICB0aGlzLnRvdWNoQ29udHJvbGxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICB0aGlzLnRvdWNoQ29udHJvbGxlci5jbGFzc05hbWUgPSBSdW5uZXIuY2xhc3Nlcy5UT1VDSF9DT05UUk9MTEVSXHJcbiAgICB0aGlzLnRvdWNoQ29udHJvbGxlci5hZGRFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuVE9VQ0hTVEFSVCwgdGhpcylcclxuICAgIHRoaXMudG91Y2hDb250cm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoUnVubmVyLmV2ZW50cy5UT1VDSEVORCwgdGhpcylcclxuICAgIHRoaXMub3V0ZXJDb250YWluZXJFbC5hcHBlbmRDaGlsZCh0aGlzLnRvdWNoQ29udHJvbGxlcilcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEZWJvdW5jZSB0aGUgcmVzaXplIGV2ZW50LlxyXG4gICAqL1xyXG4gIGRlYm91bmNlUmVzaXplICgpIHtcclxuICAgIGlmICghdGhpcy5yZXNpemVUaW1lcklkXykge1xyXG4gICAgICB0aGlzLnJlc2l6ZVRpbWVySWRfID1cclxuICAgICAgICBzZXRJbnRlcnZhbCh0aGlzLmFkanVzdERpbWVuc2lvbnMuYmluZCh0aGlzKSwgMjUwKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEFkanVzdCBnYW1lIHNwYWNlIGRpbWVuc2lvbnMgb24gcmVzaXplLlxyXG4gICAqL1xyXG4gIGFkanVzdERpbWVuc2lvbnMgKCkge1xyXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2l6ZVRpbWVySWRfKVxyXG4gICAgdGhpcy5yZXNpemVUaW1lcklkXyA9IG51bGxcclxuXHJcbiAgICBjb25zdCBib3hTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm91dGVyQ29udGFpbmVyRWwpXHJcbiAgICBjb25zdCBwYWRkaW5nID0gTnVtYmVyKGJveFN0eWxlcy5wYWRkaW5nTGVmdC5zdWJzdHIoMCxcclxuICAgICAgYm94U3R5bGVzLnBhZGRpbmdMZWZ0Lmxlbmd0aCAtIDIpKVxyXG5cclxuICAgIHRoaXMuZGltZW5zaW9ucy5XSURUSCA9IHRoaXMub3V0ZXJDb250YWluZXJFbC5vZmZzZXRXaWR0aCAtIHBhZGRpbmcgKiAyXHJcbiAgICBpZiAodGhpcy5pc0FyY2FkZU1vZGUoKSkge1xyXG4gICAgICB0aGlzLmRpbWVuc2lvbnMuV0lEVEggPSBNYXRoLm1pbihERUZBVUxUX1dJRFRILCB0aGlzLmRpbWVuc2lvbnMuV0lEVEgpXHJcbiAgICAgIGlmICh0aGlzLmFjdGl2YXRlZCkge1xyXG4gICAgICAgIHRoaXMuc2V0QXJjYWRlTW9kZUNvbnRhaW5lclNjYWxlKClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlZHJhdyB0aGUgZWxlbWVudHMgYmFjayBvbnRvIHRoZSBjYW52YXMuXHJcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcclxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmRpbWVuc2lvbnMuV0lEVEhcclxuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5kaW1lbnNpb25zLkhFSUdIVFxyXG5cclxuICAgICAgUnVubmVyLnVwZGF0ZUNhbnZhc1NjYWxpbmcodGhpcy5jYW52YXMpXHJcblxyXG4gICAgICB0aGlzLmRpc3RhbmNlTWV0ZXIuY2FsY1hQb3ModGhpcy5kaW1lbnNpb25zLldJRFRIKVxyXG4gICAgICB0aGlzLmNsZWFyQ2FudmFzKClcclxuICAgICAgdGhpcy5ob3Jpem9uLnVwZGF0ZSgwLCAwLCB0cnVlKVxyXG4gICAgICB0aGlzLnRSZXgudXBkYXRlKDApXHJcblxyXG4gICAgICAvLyBPdXRlciBjb250YWluZXIgYW5kIGRpc3RhbmNlIG1ldGVyLlxyXG4gICAgICBpZiAodGhpcy5wbGF5aW5nIHx8IHRoaXMuY3Jhc2hlZCB8fCB0aGlzLnBhdXNlZCkge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuc3R5bGUud2lkdGggPSB0aGlzLmRpbWVuc2lvbnMuV0lEVEggKyAncHgnXHJcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmRpbWVuc2lvbnMuSEVJR0hUICsgJ3B4J1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VNZXRlci51cGRhdGUoMCwgTWF0aC5jZWlsKHRoaXMuZGlzdGFuY2VSYW4pKVxyXG4gICAgICAgIHRoaXMuc3RvcCgpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy50UmV4LmRyYXcoMCwgMClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2FtZSBvdmVyIHBhbmVsLlxyXG4gICAgICBpZiAodGhpcy5jcmFzaGVkICYmIHRoaXMuZ2FtZU92ZXJQYW5lbCkge1xyXG4gICAgICAgIHRoaXMuZ2FtZU92ZXJQYW5lbC51cGRhdGVEaW1lbnNpb25zKHRoaXMuZGltZW5zaW9ucy5XSURUSClcclxuICAgICAgICB0aGlzLmdhbWVPdmVyUGFuZWwuZHJhdyh0aGlzLmFsdEdhbWVNb2RlQWN0aXZlLCB0aGlzLnRSZXgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IHRoZSBnYW1lIGludHJvLlxyXG4gICAqIENhbnZhcyBjb250YWluZXIgd2lkdGggZXhwYW5kcyBvdXQgdG8gdGhlIGZ1bGwgd2lkdGguXHJcbiAgICovXHJcbiAgcGxheUludHJvICgpIHtcclxuICAgIGlmICghdGhpcy5hY3RpdmF0ZWQgJiYgIXRoaXMuY3Jhc2hlZCkge1xyXG4gICAgICB0aGlzLnBsYXlpbmdJbnRybyA9IHRydWVcclxuICAgICAgdGhpcy50UmV4LnBsYXlpbmdJbnRybyA9IHRydWVcclxuXHJcbiAgICAgIC8vIENTUyBhbmltYXRpb24gZGVmaW5pdGlvbi5cclxuICAgICAgY29uc3Qga2V5ZnJhbWVzID0gJ0Atd2Via2l0LWtleWZyYW1lcyBpbnRybyB7ICcgK1xyXG4gICAgICAgICdmcm9tIHsgd2lkdGg6JyArIFRyZXguY29uZmlnLldJRFRIICsgJ3B4IH0nICtcclxuICAgICAgICAndG8geyB3aWR0aDogJyArIHRoaXMuZGltZW5zaW9ucy5XSURUSCArICdweCB9JyArXHJcbiAgICAgICAgJ30nXHJcbiAgICAgIGRvY3VtZW50LnN0eWxlU2hlZXRzWzBdLmluc2VydFJ1bGUoa2V5ZnJhbWVzLCAwKVxyXG5cclxuICAgICAgdGhpcy5jb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuQU5JTV9FTkQsXHJcbiAgICAgICAgdGhpcy5zdGFydEdhbWUuYmluZCh0aGlzKSlcclxuXHJcbiAgICAgIHRoaXMuY29udGFpbmVyRWwuc3R5bGUud2Via2l0QW5pbWF0aW9uID0gJ2ludHJvIC40cyBlYXNlLW91dCAxIGJvdGgnXHJcbiAgICAgIHRoaXMuY29udGFpbmVyRWwuc3R5bGUud2lkdGggPSB0aGlzLmRpbWVuc2lvbnMuV0lEVEggKyAncHgnXHJcblxyXG4gICAgICB0aGlzLnNldFBsYXlTdGF0dXModHJ1ZSlcclxuICAgICAgdGhpcy5hY3RpdmF0ZWQgPSB0cnVlXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3Jhc2hlZCkge1xyXG4gICAgICB0aGlzLnJlc3RhcnQoKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZ2FtZSBzdGF0dXMgdG8gc3RhcnRlZC5cclxuICAgKi9cclxuICBzdGFydEdhbWUgKCkge1xyXG4gICAgaWYgKHRoaXMuaXNBcmNhZGVNb2RlKCkpIHtcclxuICAgICAgdGhpcy5zZXRBcmNhZGVNb2RlKClcclxuICAgIH1cclxuICAgIHRoaXMudG9nZ2xlU3BlZWQoKVxyXG4gICAgdGhpcy5ydW5uaW5nVGltZSA9IDBcclxuICAgIHRoaXMucGxheWluZ0ludHJvID0gZmFsc2VcclxuICAgIHRoaXMudFJleC5wbGF5aW5nSW50cm8gPSBmYWxzZVxyXG4gICAgdGhpcy5jb250YWluZXJFbC5zdHlsZS53ZWJraXRBbmltYXRpb24gPSAnJ1xyXG4gICAgdGhpcy5wbGF5Q291bnQrK1xyXG4gICAgdGhpcy5nZW5lcmF0ZWRTb3VuZEZ4LmJhY2tncm91bmQoKVxyXG4gICAgYW5ub3VuY2VQaHJhc2UoZ2V0QTExeVN0cmluZyhBMTFZX1NUUklOR1Muc3RhcnRlZCkpXHJcblxyXG4gICAgaWYgKFJ1bm5lci5hdWRpb0N1ZXMpIHtcclxuICAgICAgdGhpcy5jb250YWluZXJFbC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZ2V0QTExeVN0cmluZyhBMTFZX1NUUklOR1MuanVtcCkpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIHRhYmJpbmcgb2ZmIHRoZSBwYWdlLiBQYXVzZSB0aGUgY3VycmVudCBnYW1lLlxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLlZJU0lCSUxJVFksXHJcbiAgICAgIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlLmJpbmQodGhpcykpXHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUnVubmVyLmV2ZW50cy5CTFVSLFxyXG4gICAgICB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZS5iaW5kKHRoaXMpKVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuRk9DVVMsXHJcbiAgICAgIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlLmJpbmQodGhpcykpXHJcbiAgfSxcclxuXHJcbiAgY2xlYXJDYW52YXMgKCkge1xyXG4gICAgdGhpcy5jYW52YXNDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuZGltZW5zaW9ucy5XSURUSCxcclxuICAgICAgdGhpcy5kaW1lbnNpb25zLkhFSUdIVClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgY2FudmFzIGFyZWEgaXMgaW4gdGhlIHZpZXdwb3J0IG9mIHRoZSBicm93c2VyXHJcbiAgICogdGhyb3VnaCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24uXHJcbiAgICogQHJldHVybiBib29sZWFuLlxyXG4gICAqL1xyXG4gIGlzQ2FudmFzSW5WaWV3ICgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA+XHJcbiAgICAgIFJ1bm5lci5jb25maWcuQ0FOVkFTX0lOX1ZJRVdfT0ZGU0VUXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlIHRoZSBhbHQgZ2FtZSBtb2RlLiBTd2l0Y2hpbmcgb3V0IHRoZSBzcHJpdGVzLlxyXG4gICAqL1xyXG4gIGVuYWJsZUFsdEdhbWVNb2RlICgpIHtcclxuICAgIFJ1bm5lci5pbWFnZVNwcml0ZSA9IFJ1bm5lci5hbHRHYW1lSW1hZ2VTcHJpdGVcclxuICAgIFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uID0gUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGVbUnVubmVyLmdhbWVUeXBlXVxyXG5cclxuICAgIGlmIChJU19ISURQSSkge1xyXG4gICAgICB0aGlzLnNwcml0ZURlZiA9IFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLkhEUElcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3ByaXRlRGVmID0gUnVubmVyLnNwcml0ZURlZmluaXRpb24uTERQSVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWx0R2FtZU1vZGVBY3RpdmUgPSB0cnVlXHJcbiAgICB0aGlzLnRSZXguZW5hYmxlQWx0R2FtZU1vZGUodGhpcy5zcHJpdGVEZWYuVFJFWClcclxuICAgIHRoaXMuaG9yaXpvbi5lbmFibGVBbHRHYW1lTW9kZSh0aGlzLnNwcml0ZURlZilcclxuICAgIHRoaXMuZ2VuZXJhdGVkU291bmRGeC5iYWNrZ3JvdW5kKClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGdhbWUgZnJhbWUgYW5kIHNjaGVkdWxlcyB0aGUgbmV4dCBvbmUuXHJcbiAgICovXHJcbiAgdXBkYXRlICgpIHtcclxuICAgIHRoaXMudXBkYXRlUGVuZGluZyA9IGZhbHNlXHJcblxyXG4gICAgY29uc3Qgbm93ID0gZ2V0VGltZVN0YW1wKClcclxuICAgIGxldCBkZWx0YVRpbWUgPSBub3cgLSAodGhpcy50aW1lIHx8IG5vdylcclxuXHJcbiAgICAvLyBGbGFzaGluZyB3aGVuIHN3aXRjaGluZyBnYW1lIG1vZGVzLlxyXG4gICAgaWYgKHRoaXMuYWx0R2FtZU1vZGVGbGFzaFRpbWVyIDwgMCB8fCB0aGlzLmFsdEdhbWVNb2RlRmxhc2hUaW1lciA9PT0gMCkge1xyXG4gICAgICB0aGlzLmFsdEdhbWVNb2RlRmxhc2hUaW1lciA9IG51bGxcclxuICAgICAgdGhpcy50UmV4LnNldEZsYXNoaW5nKGZhbHNlKVxyXG4gICAgICB0aGlzLmVuYWJsZUFsdEdhbWVNb2RlKClcclxuICAgIH0gZWxzZSBpZiAodGhpcy5hbHRHYW1lTW9kZUZsYXNoVGltZXIgPiAwKSB7XHJcbiAgICAgIHRoaXMuYWx0R2FtZU1vZGVGbGFzaFRpbWVyIC09IGRlbHRhVGltZVxyXG4gICAgICB0aGlzLnRSZXgudXBkYXRlKGRlbHRhVGltZSlcclxuICAgICAgZGVsdGFUaW1lID0gMFxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGltZSA9IG5vd1xyXG5cclxuICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcclxuICAgICAgdGhpcy5jbGVhckNhbnZhcygpXHJcblxyXG4gICAgICAvLyBBZGRpdGlvbmFsIGZhZGUgaW4gLSBQcmV2ZW50cyBqdW1wIHdoZW4gc3dpdGNoaW5nIHNwcml0ZXNcclxuICAgICAgaWYgKHRoaXMuYWx0R2FtZU1vZGVBY3RpdmUgJiZcclxuICAgICAgICB0aGlzLmZhZGVJblRpbWVyIDw9IHRoaXMuY29uZmlnLkZBREVfRFVSQVRJT04pIHtcclxuICAgICAgICB0aGlzLmZhZGVJblRpbWVyICs9IGRlbHRhVGltZSAvIDEwMDBcclxuICAgICAgICB0aGlzLmNhbnZhc0N0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZmFkZUluVGltZXJcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNhbnZhc0N0eC5nbG9iYWxBbHBoYSA9IDFcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMudFJleC5qdW1waW5nKSB7XHJcbiAgICAgICAgdGhpcy50UmV4LnVwZGF0ZUp1bXAoZGVsdGFUaW1lKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJ1bm5pbmdUaW1lICs9IGRlbHRhVGltZVxyXG4gICAgICBjb25zdCBoYXNPYnN0YWNsZXMgPSB0aGlzLnJ1bm5pbmdUaW1lID4gdGhpcy5jb25maWcuQ0xFQVJfVElNRVxyXG5cclxuICAgICAgLy8gRmlyc3QganVtcCB0cmlnZ2VycyB0aGUgaW50cm8uXHJcbiAgICAgIGlmICh0aGlzLnRSZXguanVtcENvdW50ID09PSAxICYmICF0aGlzLnBsYXlpbmdJbnRybykge1xyXG4gICAgICAgIHRoaXMucGxheUludHJvKClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIGhvcml6b24gZG9lc24ndCBtb3ZlIHVudGlsIHRoZSBpbnRybyBpcyBvdmVyLlxyXG4gICAgICBpZiAodGhpcy5wbGF5aW5nSW50cm8pIHtcclxuICAgICAgICB0aGlzLmhvcml6b24udXBkYXRlKDAsIHRoaXMuY3VycmVudFNwZWVkLCBoYXNPYnN0YWNsZXMpXHJcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY3Jhc2hlZCkge1xyXG4gICAgICAgIGNvbnN0IHNob3dOaWdodE1vZGUgPSB0aGlzLmlzRGFya01vZGUgXiB0aGlzLmludmVydGVkXHJcbiAgICAgICAgZGVsdGFUaW1lID0gIXRoaXMuYWN0aXZhdGVkID8gMCA6IGRlbHRhVGltZVxyXG4gICAgICAgIHRoaXMuaG9yaXpvbi51cGRhdGUoXHJcbiAgICAgICAgICBkZWx0YVRpbWUsIHRoaXMuY3VycmVudFNwZWVkLCBoYXNPYnN0YWNsZXMsIHNob3dOaWdodE1vZGUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zLlxyXG4gICAgICBsZXQgY29sbGlzaW9uID0gaGFzT2JzdGFjbGVzICYmXHJcbiAgICAgICAgY2hlY2tGb3JDb2xsaXNpb24odGhpcy5ob3Jpem9uLm9ic3RhY2xlc1swXSwgdGhpcy50UmV4KVxyXG5cclxuICAgICAgLy8gRm9yIGExMXksIGF1ZGlvIGN1ZXMuXHJcbiAgICAgIGlmIChSdW5uZXIuYXVkaW9DdWVzICYmIGhhc09ic3RhY2xlcykge1xyXG4gICAgICAgIGNvbnN0IGp1bXBPYnN0YWNsZSA9XHJcbiAgICAgICAgICB0aGlzLmhvcml6b24ub2JzdGFjbGVzWzBdLnR5cGVDb25maWcudHlwZSAhPT0gJ0NPTExFQ1RBQkxFJ1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaG9yaXpvbi5vYnN0YWNsZXNbMF0uanVtcEFsZXJ0ZWQpIHtcclxuICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IFJ1bm5lci5pc01vYmlsZU1vdXNlSW5wdXRcclxuICAgICAgICAgICAgPyBSdW5uZXIuY29uZmlnLkFVRElPQ1VFX1BST1hJTUlUWV9USFJFU0hPTERfTU9CSUxFX0ExMVlcclxuICAgICAgICAgICAgOiBSdW5uZXIuY29uZmlnLkFVRElPQ1VFX1BST1hJTUlUWV9USFJFU0hPTERcclxuICAgICAgICAgIGNvbnN0IGFkalByb3hpbWl0eVRocmVzaG9sZCA9IHRocmVzaG9sZCArXHJcbiAgICAgICAgICAgICh0aHJlc2hvbGQgKiBNYXRoLmxvZzEwKHRoaXMuY3VycmVudFNwZWVkIC8gUnVubmVyLmNvbmZpZy5TUEVFRCkpXHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbi5vYnN0YWNsZXNbMF0ueFBvcyA8IGFkalByb3hpbWl0eVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICBpZiAoanVtcE9ic3RhY2xlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRTb3VuZEZ4Lmp1bXAoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaG9yaXpvbi5vYnN0YWNsZXNbMF0uanVtcEFsZXJ0ZWQgPSB0cnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBY3RpdmF0ZWQgYWx0IGdhbWUgbW9kZS5cclxuICAgICAgaWYgKFJ1bm5lci5pc0FsdEdhbWVNb2RlRW5hYmxlZCgpICYmIGNvbGxpc2lvbiAmJlxyXG4gICAgICAgIHRoaXMuaG9yaXpvbi5vYnN0YWNsZXNbMF0udHlwZUNvbmZpZy50eXBlID09PSAnQ09MTEVDVEFCTEUnKSB7XHJcbiAgICAgICAgdGhpcy5ob3Jpem9uLnJlbW92ZUZpcnN0T2JzdGFjbGUoKVxyXG4gICAgICAgIHRoaXMudFJleC5zZXRGbGFzaGluZyh0cnVlKVxyXG4gICAgICAgIGNvbGxpc2lvbiA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5hbHRHYW1lTW9kZUZsYXNoVGltZXIgPSB0aGlzLmNvbmZpZy5GTEFTSF9EVVJBVElPTlxyXG4gICAgICAgIHRoaXMucnVubmluZ1RpbWUgPSAwXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZWRTb3VuZEZ4LmNvbGxlY3QoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWNvbGxpc2lvbikge1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VSYW4gKz0gdGhpcy5jdXJyZW50U3BlZWQgKiBkZWx0YVRpbWUgLyB0aGlzLm1zUGVyRnJhbWVcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNwZWVkIDwgdGhpcy5jb25maWcuTUFYX1NQRUVEKSB7XHJcbiAgICAgICAgICB0aGlzLmN1cnJlbnRTcGVlZCArPSB0aGlzLmNvbmZpZy5BQ0NFTEVSQVRJT05cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nYW1lT3ZlcigpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHBsYXlBY2hpZXZlbWVudFNvdW5kID0gdGhpcy5kaXN0YW5jZU1ldGVyLnVwZGF0ZShkZWx0YVRpbWUsXHJcbiAgICAgICAgTWF0aC5jZWlsKHRoaXMuZGlzdGFuY2VSYW4pKVxyXG5cclxuICAgICAgaWYgKCFSdW5uZXIuYXVkaW9DdWVzICYmIHBsYXlBY2hpZXZlbWVudFNvdW5kKSB7XHJcbiAgICAgICAgdGhpcy5wbGF5U291bmQodGhpcy5zb3VuZEZ4LlNDT1JFKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBOaWdodCBtb2RlLlxyXG4gICAgICBpZiAoIVJ1bm5lci5pc0FsdEdhbWVNb2RlRW5hYmxlZCgpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW52ZXJ0VGltZXIgPiB0aGlzLmNvbmZpZy5JTlZFUlRfRkFERV9EVVJBVElPTikge1xyXG4gICAgICAgICAgdGhpcy5pbnZlcnRUaW1lciA9IDBcclxuICAgICAgICAgIHRoaXMuaW52ZXJ0VHJpZ2dlciA9IGZhbHNlXHJcbiAgICAgICAgICB0aGlzLmludmVydChmYWxzZSlcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW52ZXJ0VGltZXIpIHtcclxuICAgICAgICAgIHRoaXMuaW52ZXJ0VGltZXIgKz0gZGVsdGFUaW1lXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGFjdHVhbERpc3RhbmNlID1cclxuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZU1ldGVyLmdldEFjdHVhbERpc3RhbmNlKE1hdGguY2VpbCh0aGlzLmRpc3RhbmNlUmFuKSlcclxuXHJcbiAgICAgICAgICBpZiAoYWN0dWFsRGlzdGFuY2UgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW52ZXJ0VHJpZ2dlciA9XHJcbiAgICAgICAgICAgICAgIShhY3R1YWxEaXN0YW5jZSAlIHRoaXMuY29uZmlnLklOVkVSVF9ESVNUQU5DRSlcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmludmVydFRyaWdnZXIgJiYgdGhpcy5pbnZlcnRUaW1lciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuaW52ZXJ0VGltZXIgKz0gZGVsdGFUaW1lXHJcbiAgICAgICAgICAgICAgdGhpcy5pbnZlcnQoZmFsc2UpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wbGF5aW5nIHx8ICghdGhpcy5hY3RpdmF0ZWQgJiZcclxuICAgICAgdGhpcy50UmV4LmJsaW5rQ291bnQgPCBSdW5uZXIuY29uZmlnLk1BWF9CTElOS19DT1VOVCkpIHtcclxuICAgICAgdGhpcy50UmV4LnVwZGF0ZShkZWx0YVRpbWUpXHJcbiAgICAgIHRoaXMuc2NoZWR1bGVOZXh0VXBkYXRlKClcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCBoYW5kbGVyLlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgKi9cclxuICBoYW5kbGVFdmVudCAoZSkge1xyXG4gICAgcmV0dXJuIChmdW5jdGlvbiAoZXZ0VHlwZSwgZXZlbnRzKSB7XHJcbiAgICAgIHN3aXRjaCAoZXZ0VHlwZSkge1xyXG4gICAgICAgIGNhc2UgZXZlbnRzLktFWURPV046XHJcbiAgICAgICAgY2FzZSBldmVudHMuVE9VQ0hTVEFSVDpcclxuICAgICAgICBjYXNlIGV2ZW50cy5QT0lOVEVSRE9XTjpcclxuICAgICAgICAgIHRoaXMub25LZXlEb3duKGUpXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgZXZlbnRzLktFWVVQOlxyXG4gICAgICAgIGNhc2UgZXZlbnRzLlRPVUNIRU5EOlxyXG4gICAgICAgIGNhc2UgZXZlbnRzLlBPSU5URVJVUDpcclxuICAgICAgICAgIHRoaXMub25LZXlVcChlKVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlIGV2ZW50cy5HQU1FUEFEQ09OTkVDVEVEOlxyXG4gICAgICAgICAgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWQoZSlcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKSkoZS50eXBlLCBSdW5uZXIuZXZlbnRzKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgYXVkaW8gY3VlcyBpZiBhY3RpdmF0ZWQgYnkgZm9jdXMgb24gdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgKi9cclxuICBoYW5kbGVDYW52YXNLZXlQcmVzcyAoZSkge1xyXG4gICAgaWYgKCF0aGlzLmFjdGl2YXRlZCAmJiAhUnVubmVyLmF1ZGlvQ3Vlcykge1xyXG4gICAgICB0aGlzLnRvZ2dsZVNwZWVkKClcclxuICAgICAgUnVubmVyLmF1ZGlvQ3VlcyA9IHRydWVcclxuICAgICAgdGhpcy5nZW5lcmF0ZWRTb3VuZEZ4LmluaXQoKVxyXG4gICAgICBSdW5uZXIuZ2VuZXJhdGVkU291bmRGeCA9IHRoaXMuZ2VuZXJhdGVkU291bmRGeFxyXG4gICAgICBSdW5uZXIuY29uZmlnLkNMRUFSX1RJTUUgKj0gMS4yXHJcbiAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSAmJiBSdW5uZXIua2V5Y29kZXMuSlVNUFtlLmtleUNvZGVdKSB7XHJcbiAgICAgIHRoaXMub25LZXlEb3duKGUpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUHJldmVudCBzcGFjZSBrZXkgcHJlc3MgZnJvbSBzY3JvbGxpbmcuXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAqL1xyXG4gIHByZXZlbnRTY3JvbGxpbmcgKGUpIHtcclxuICAgIGlmIChlLmtleUNvZGUgPT09IDMyKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZSBzcGVlZCBzZXR0aW5nIGlmIHRvZ2dsZSBpcyBzaG93bi5cclxuICAgKi9cclxuICB0b2dnbGVTcGVlZCAoKSB7XHJcbiAgICBpZiAoUnVubmVyLmF1ZGlvQ3Vlcykge1xyXG4gICAgICBjb25zdCBzcGVlZENoYW5nZSA9IFJ1bm5lci5zbG93RG93biAhPSB0aGlzLnNsb3dTcGVlZENoZWNrYm94LmNoZWNrZWRcclxuXHJcbiAgICAgIGlmIChzcGVlZENoYW5nZSkge1xyXG4gICAgICAgIFJ1bm5lci5zbG93RG93biA9IHRoaXMuc2xvd1NwZWVkQ2hlY2tib3guY2hlY2tlZFxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDb25maWcgPVxyXG4gICAgICAgICAgUnVubmVyLnNsb3dEb3duID8gUnVubmVyLnNsb3dDb25maWcgOiBSdW5uZXIubm9ybWFsQ29uZmlnXHJcblxyXG4gICAgICAgIFJ1bm5lci5jb25maWcgPSBPYmplY3QuYXNzaWduKFJ1bm5lci5jb25maWcsIHVwZGF0ZWRDb25maWcpXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3BlZWQgPSB1cGRhdGVkQ29uZmlnLlNQRUVEXHJcbiAgICAgICAgdGhpcy50UmV4LmVuYWJsZVNsb3dDb25maWcoKVxyXG4gICAgICAgIHRoaXMuaG9yaXpvbi5hZGp1c3RPYnN0YWNsZVNwZWVkKClcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlU3BlZWRUb2dnbGUodHJ1ZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3cgdGhlIHNwZWVkIHRvZ2dsZS5cclxuICAgKiBGcm9tIGZvY3VzIGV2ZW50IG9yIHdoZW4gYXVkaW8gY3VlcyBhcmUgYWN0aXZhdGVkLlxyXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBlXHJcbiAgICovXHJcbiAgc2hvd1NwZWVkVG9nZ2xlIChlKSB7XHJcbiAgICBjb25zdCBpc0ZvY3VzRXZlbnQgPSBlICYmIGUudHlwZSA9PSAnZm9jdXMnXHJcbiAgICBpZiAoUnVubmVyLmF1ZGlvQ3VlcyB8fCBpc0ZvY3VzRXZlbnQpIHtcclxuICAgICAgdGhpcy5zbG93U3BlZWRDaGVja2JveExhYmVsLmNsYXNzTGlzdC50b2dnbGUoXHJcbiAgICAgICAgSElEREVOX0NMQVNTLCBpc0ZvY3VzRXZlbnQgPyBmYWxzZSA6ICF0aGlzLmNyYXNoZWQpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGlzYWJsZSB0aGUgc3BlZWQgdG9nZ2xlLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZVxyXG4gICAqL1xyXG4gIGRpc2FibGVTcGVlZFRvZ2dsZSAoZGlzYWJsZSkge1xyXG4gICAgaWYgKGRpc2FibGUpIHtcclxuICAgICAgdGhpcy5zbG93U3BlZWRDaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2xvd1NwZWVkQ2hlY2tib3gucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCByZWxldmFudCBrZXkgLyBtb3VzZSAvIHRvdWNoIGxpc3RlbmVycy5cclxuICAgKi9cclxuICBzdGFydExpc3RlbmluZyAoKSB7XHJcbiAgICAvLyBBMTF5IGtleWJvYXJkIC8gc2NyZWVuIHJlYWRlciBhY3RpdmF0aW9uLlxyXG4gICAgdGhpcy5jb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICBSdW5uZXIuZXZlbnRzLktFWURPV04sIHRoaXMuaGFuZGxlQ2FudmFzS2V5UHJlc3MuYmluZCh0aGlzKSlcclxuICAgIGlmICghSVNfTU9CSUxFKSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBSdW5uZXIuZXZlbnRzLkZPQ1VTLCB0aGlzLnNob3dTcGVlZFRvZ2dsZS5iaW5kKHRoaXMpKVxyXG4gICAgfVxyXG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgUnVubmVyLmV2ZW50cy5LRVlET1dOLCB0aGlzLnByZXZlbnRTY3JvbGxpbmcuYmluZCh0aGlzKSlcclxuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIFJ1bm5lci5ldmVudHMuS0VZVVAsIHRoaXMucHJldmVudFNjcm9sbGluZy5iaW5kKHRoaXMpKVxyXG5cclxuICAgIC8vIEtleXMuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuS0VZRE9XTiwgdGhpcylcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUnVubmVyLmV2ZW50cy5LRVlVUCwgdGhpcylcclxuXHJcbiAgICAvLyBUb3VjaCAvIHBvaW50ZXIuXHJcbiAgICB0aGlzLmNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoUnVubmVyLmV2ZW50cy5UT1VDSFNUQVJULCB0aGlzKVxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLlBPSU5URVJET1dOLCB0aGlzKVxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLlBPSU5URVJVUCwgdGhpcylcclxuXHJcbiAgICBpZiAodGhpcy5pc0FyY2FkZU1vZGUoKSkge1xyXG4gICAgICAvLyBHYW1lcGFkXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuR0FNRVBBRENPTk5FQ1RFRCwgdGhpcylcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycy5cclxuICAgKi9cclxuICBzdG9wTGlzdGVuaW5nICgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoUnVubmVyLmV2ZW50cy5LRVlET1dOLCB0aGlzKVxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLktFWVVQLCB0aGlzKVxyXG5cclxuICAgIGlmICh0aGlzLnRvdWNoQ29udHJvbGxlcikge1xyXG4gICAgICB0aGlzLnRvdWNoQ29udHJvbGxlci5yZW1vdmVFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuVE9VQ0hTVEFSVCwgdGhpcylcclxuICAgICAgdGhpcy50b3VjaENvbnRyb2xsZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLlRPVUNIRU5ELCB0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihSdW5uZXIuZXZlbnRzLlRPVUNIU1RBUlQsIHRoaXMpXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuUE9JTlRFUkRPV04sIHRoaXMpXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuUE9JTlRFUlVQLCB0aGlzKVxyXG5cclxuICAgIGlmICh0aGlzLmlzQXJjYWRlTW9kZSgpKSB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFJ1bm5lci5ldmVudHMuR0FNRVBBRENPTk5FQ1RFRCwgdGhpcylcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzIGtleWRvd24uXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAqL1xyXG4gIG9uS2V5RG93biAoZSkge1xyXG4gICAgLy8gUHJldmVudCBuYXRpdmUgcGFnZSBzY3JvbGxpbmcgd2hpbHN0IHRhcHBpbmcgb24gbW9iaWxlLlxyXG4gICAgaWYgKElTX01PQklMRSAmJiB0aGlzLnBsYXlpbmcpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNDYW52YXNJblZpZXcoKSkge1xyXG4gICAgICAvLyBBbGxvdyB0b2dnbGluZyBvZiBzcGVlZCB0b2dnbGUuXHJcbiAgICAgIGlmIChSdW5uZXIua2V5Y29kZXMuSlVNUFtlLmtleUNvZGVdICYmXHJcbiAgICAgICAgZS50YXJnZXQgPT0gdGhpcy5zbG93U3BlZWRDaGVja2JveCkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMuY3Jhc2hlZCAmJiAhdGhpcy5wYXVzZWQpIHtcclxuICAgICAgICAvLyBGb3IgYTExeSwgc2NyZWVuIHJlYWRlciBhY3RpdmF0aW9uLlxyXG4gICAgICAgIGNvbnN0IGlzTW9iaWxlTW91c2VJbnB1dCA9IElTX01PQklMRSAmJlxyXG4gICAgICAgICAgZS50eXBlID09PSBSdW5uZXIuZXZlbnRzLlBPSU5URVJET1dOICYmXHJcbiAgICAgICAgICBlLnBvaW50ZXJUeXBlID09ICdtb3VzZScgJiYgZS50YXJnZXQgPT0gdGhpcy5jb250YWluZXJFbCB8fFxyXG4gICAgICAgICAgKElTX0lPUyAmJiBlLnBvaW50ZXJUeXBlID09ICd0b3VjaCcgJiZcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRhaW5lckVsKVxyXG5cclxuICAgICAgICBpZiAoUnVubmVyLmtleWNvZGVzLkpVTVBbZS5rZXlDb2RlXSB8fFxyXG4gICAgICAgICAgZS50eXBlID09PSBSdW5uZXIuZXZlbnRzLlRPVUNIU1RBUlQgfHwgaXNNb2JpbGVNb3VzZUlucHV0IHx8XHJcbiAgICAgICAgICAoUnVubmVyLmtleWNvZGVzLkRVQ0tbZS5rZXlDb2RlXSAmJiB0aGlzLmFsdEdhbWVNb2RlQWN0aXZlKSkge1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAvLyBTdGFydGluZyB0aGUgZ2FtZSBmb3IgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAgICAgICBpZiAoIXRoaXMucGxheWluZykge1xyXG4gICAgICAgICAgICAvLyBTdGFydGVkIGJ5IHRvdWNoIHNvIGNyZWF0ZSBhIHRvdWNoIGNvbnRyb2xsZXIuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy50b3VjaENvbnRyb2xsZXIgJiYgZS50eXBlID09PSBSdW5uZXIuZXZlbnRzLlRPVUNIU1RBUlQpIHtcclxuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVRvdWNoQ29udHJvbGxlcigpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpc01vYmlsZU1vdXNlSW5wdXQpIHtcclxuICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhbnZhc0tleVByZXNzKGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb2FkU291bmRzKClcclxuICAgICAgICAgICAgdGhpcy5zZXRQbGF5U3RhdHVzKHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKClcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5lcnJvclBhZ2VDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3JQYWdlQ29udHJvbGxlci50cmFja0Vhc3RlckVnZygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFN0YXJ0IGp1bXAuXHJcbiAgICAgICAgICBpZiAoIXRoaXMudFJleC5qdW1waW5nICYmICF0aGlzLnRSZXguZHVja2luZykge1xyXG4gICAgICAgICAgICBpZiAoUnVubmVyLmF1ZGlvQ3Vlcykge1xyXG4gICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkU291bmRGeC5jYW5jZWxGb290U3RlcHMoKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMucGxheVNvdW5kKHRoaXMuc291bmRGeC5CVVRUT05fUFJFU1MpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50UmV4LnN0YXJ0SnVtcCh0aGlzLmN1cnJlbnRTcGVlZClcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIER1Y2tpbmcgaXMgZGlzYWJsZWQgb24gYWx0IGdhbWUgbW9kZXMuXHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICF0aGlzLmFsdEdhbWVNb2RlQWN0aXZlICYmIHRoaXMucGxheWluZyAmJlxyXG4gICAgICAgICAgUnVubmVyLmtleWNvZGVzLkRVQ0tbZS5rZXlDb2RlXSkge1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICBpZiAodGhpcy50UmV4Lmp1bXBpbmcpIHtcclxuICAgICAgICAgICAgLy8gU3BlZWQgZHJvcCwgYWN0aXZhdGVkIG9ubHkgd2hlbiBqdW1wIGtleSBpcyBub3QgcHJlc3NlZC5cclxuICAgICAgICAgICAgdGhpcy50UmV4LnNldFNwZWVkRHJvcCgpXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnRSZXguanVtcGluZyAmJiAhdGhpcy50UmV4LmR1Y2tpbmcpIHtcclxuICAgICAgICAgICAgLy8gRHVjay5cclxuICAgICAgICAgICAgdGhpcy50UmV4LnNldER1Y2sodHJ1ZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzIGtleSB1cC5cclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICovXHJcbiAgb25LZXlVcCAoZSkge1xyXG4gICAgY29uc3Qga2V5Q29kZSA9IFN0cmluZyhlLmtleUNvZGUpXHJcbiAgICBjb25zdCBpc2p1bXBLZXkgPSBSdW5uZXIua2V5Y29kZXMuSlVNUFtrZXlDb2RlXSB8fFxyXG4gICAgICBlLnR5cGUgPT09IFJ1bm5lci5ldmVudHMuVE9VQ0hFTkQgfHwgZS50eXBlID09PSBSdW5uZXIuZXZlbnRzLlBPSU5URVJVUFxyXG5cclxuICAgIGlmICh0aGlzLmlzUnVubmluZygpICYmIGlzanVtcEtleSkge1xyXG4gICAgICB0aGlzLnRSZXguZW5kSnVtcCgpXHJcbiAgICB9IGVsc2UgaWYgKFJ1bm5lci5rZXljb2Rlcy5EVUNLW2tleUNvZGVdKSB7XHJcbiAgICAgIHRoaXMudFJleC5zcGVlZERyb3AgPSBmYWxzZVxyXG4gICAgICB0aGlzLnRSZXguc2V0RHVjayhmYWxzZSlcclxuICAgIH0gZWxzZSBpZiAodGhpcy5jcmFzaGVkKSB7XHJcbiAgICAgIC8vIENoZWNrIHRoYXQgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQgYmVmb3JlIGFsbG93aW5nIGp1bXAga2V5IHRvIHJlc3RhcnQuXHJcbiAgICAgIGNvbnN0IGRlbHRhVGltZSA9IGdldFRpbWVTdGFtcCgpIC0gdGhpcy50aW1lXHJcblxyXG4gICAgICBpZiAodGhpcy5pc0NhbnZhc0luVmlldygpICYmXHJcbiAgICAgICAgKFJ1bm5lci5rZXljb2Rlcy5SRVNUQVJUW2tleUNvZGVdIHx8IHRoaXMuaXNMZWZ0Q2xpY2tPbkNhbnZhcyhlKSB8fFxyXG4gICAgICAgICAgKGRlbHRhVGltZSA+PSB0aGlzLmNvbmZpZy5HQU1FT1ZFUl9DTEVBUl9USU1FICYmXHJcbiAgICAgICAgICAgIFJ1bm5lci5rZXljb2Rlcy5KVU1QW2tleUNvZGVdKSkpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUdhbWVPdmVyQ2xpY2tzKGUpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXVzZWQgJiYgaXNqdW1wS2V5KSB7XHJcbiAgICAgIC8vIFJlc2V0IHRoZSBqdW1wIHN0YXRlXHJcbiAgICAgIHRoaXMudFJleC5yZXNldCgpXHJcbiAgICAgIHRoaXMucGxheSgpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2VzcyBnYW1lcGFkIGNvbm5lY3RlZCBldmVudC5cclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICovXHJcbiAgb25HYW1lcGFkQ29ubmVjdGVkIChlKSB7XHJcbiAgICBpZiAoIXRoaXMucG9sbGluZ0dhbWVwYWRzKSB7XHJcbiAgICAgIHRoaXMucG9sbEdhbWVwYWRTdGF0ZSgpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogckFGIGxvb3AgZm9yIGdhbWVwYWQgcG9sbGluZy5cclxuICAgKi9cclxuICBwb2xsR2FtZXBhZFN0YXRlICgpIHtcclxuICAgIGNvbnN0IGdhbWVwYWRzID0gbmF2aWdhdG9yLmdldEdhbWVwYWRzKClcclxuICAgIHRoaXMucG9sbEFjdGl2ZUdhbWVwYWQoZ2FtZXBhZHMpXHJcblxyXG4gICAgdGhpcy5wb2xsaW5nR2FtZXBhZHMgPSB0cnVlXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5wb2xsR2FtZXBhZFN0YXRlLmJpbmQodGhpcykpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUG9sbHMgZm9yIGEgZ2FtZXBhZCB3aXRoIHRoZSBqdW1wIGJ1dHRvbiBwcmVzc2VkLiBJZiBvbmUgaXMgZm91bmQgdGhpc1xyXG4gICAqIGJlY29tZXMgdGhlIFwiYWN0aXZlXCIgZ2FtZXBhZCBhbmQgYWxsIG90aGVycyBhcmUgaWdub3JlZC5cclxuICAgKiBAcGFyYW0geyFBcnJheTxHYW1lcGFkPn0gZ2FtZXBhZHNcclxuICAgKi9cclxuICBwb2xsRm9yQWN0aXZlR2FtZXBhZCAoZ2FtZXBhZHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2FtZXBhZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgaWYgKGdhbWVwYWRzW2ldICYmIGdhbWVwYWRzW2ldLmJ1dHRvbnMubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgIGdhbWVwYWRzW2ldLmJ1dHRvbnNbMF0ucHJlc3NlZCkge1xyXG4gICAgICAgIHRoaXMuZ2FtZXBhZEluZGV4ID0gaVxyXG4gICAgICAgIHRoaXMucG9sbEFjdGl2ZUdhbWVwYWQoZ2FtZXBhZHMpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQb2xscyB0aGUgY2hvc2VuIGdhbWVwYWQgZm9yIGJ1dHRvbiBwcmVzc2VzIGFuZCBnZW5lcmF0ZXMgS2V5Ym9hcmRFdmVudHNcclxuICAgKiB0byBpbnRlZ3JhdGUgd2l0aCB0aGUgcmVzdCBvZiB0aGUgZ2FtZSBsb2dpYy5cclxuICAgKiBAcGFyYW0geyFBcnJheTxHYW1lcGFkPn0gZ2FtZXBhZHNcclxuICAgKi9cclxuICBwb2xsQWN0aXZlR2FtZXBhZCAoZ2FtZXBhZHMpIHtcclxuICAgIGlmICh0aGlzLmdhbWVwYWRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMucG9sbEZvckFjdGl2ZUdhbWVwYWQoZ2FtZXBhZHMpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdhbWVwYWQgPSBnYW1lcGFkc1t0aGlzLmdhbWVwYWRJbmRleF1cclxuICAgIGlmICghZ2FtZXBhZCkge1xyXG4gICAgICB0aGlzLmdhbWVwYWRJbmRleCA9IHVuZGVmaW5lZFxyXG4gICAgICB0aGlzLnBvbGxGb3JBY3RpdmVHYW1lcGFkKGdhbWVwYWRzKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgZ2FtZXBhZCBzcGVjaWZpY2F0aW9uIGRlZmluZXMgdGhlIHR5cGljYWwgbWFwcGluZyBvZiBwaHlzaWNhbCBidXR0b25zXHJcbiAgICAvLyB0byBidXR0b24gaW5kaWNpZXM6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9nYW1lcGFkLyNyZW1hcHBpbmdcclxuICAgIHRoaXMucG9sbEdhbWVwYWRCdXR0b24oZ2FtZXBhZCwgMCwgMzgpIC8vIEp1bXBcclxuICAgIGlmIChnYW1lcGFkLmJ1dHRvbnMubGVuZ3RoID49IDIpIHtcclxuICAgICAgdGhpcy5wb2xsR2FtZXBhZEJ1dHRvbihnYW1lcGFkLCAxLCA0MCkgLy8gRHVja1xyXG4gICAgfVxyXG4gICAgaWYgKGdhbWVwYWQuYnV0dG9ucy5sZW5ndGggPj0gMTApIHtcclxuICAgICAgdGhpcy5wb2xsR2FtZXBhZEJ1dHRvbihnYW1lcGFkLCA5LCAxMykgLy8gUmVzdGFydFxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJldmlvdXNHYW1lcGFkID0gZ2FtZXBhZFxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIGtleSBldmVudCBiYXNlZCBvbiBhIGdhbWVwYWQgYnV0dG9uLlxyXG4gICAqIEBwYXJhbSB7IUdhbWVwYWR9IGdhbWVwYWRcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYnV0dG9uSW5kZXhcclxuICAgKiBAcGFyYW0ge251bWJlcn0ga2V5Q29kZVxyXG4gICAqL1xyXG4gIHBvbGxHYW1lcGFkQnV0dG9uIChnYW1lcGFkLCBidXR0b25JbmRleCwga2V5Q29kZSkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSBnYW1lcGFkLmJ1dHRvbnNbYnV0dG9uSW5kZXhdLnByZXNzZWRcclxuICAgIGxldCBwcmV2aW91c1N0YXRlID0gZmFsc2VcclxuICAgIGlmICh0aGlzLnByZXZpb3VzR2FtZXBhZCkge1xyXG4gICAgICBwcmV2aW91c1N0YXRlID0gdGhpcy5wcmV2aW91c0dhbWVwYWQuYnV0dG9uc1tidXR0b25JbmRleF0ucHJlc3NlZFxyXG4gICAgfVxyXG4gICAgLy8gR2VuZXJhdGUga2V5IGV2ZW50cyBvbiB0aGUgcmlzaW5nIGFuZCBmYWxsaW5nIGVkZ2Ugb2YgYSBidXR0b24gcHJlc3MuXHJcbiAgICBpZiAoc3RhdGUgIT09IHByZXZpb3VzU3RhdGUpIHtcclxuICAgICAgY29uc3QgZSA9IG5ldyBLZXlib2FyZEV2ZW50KHN0YXRlXHJcbiAgICAgICAgPyBSdW5uZXIuZXZlbnRzLktFWURPV05cclxuICAgICAgICA6IFJ1bm5lci5ldmVudHMuS0VZVVAsXHJcbiAgICAgIHsga2V5Q29kZSB9KVxyXG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGUpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGludGVyYWN0aW9ucyBvbiB0aGUgZ2FtZSBvdmVyIHNjcmVlbiBzdGF0ZS5cclxuICAgKiBBIHVzZXIgaXMgYWJsZSB0byB0YXAgdGhlIGhpZ2ggc2NvcmUgdHdpY2UgdG8gcmVzZXQgaXQuXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAqL1xyXG4gIGhhbmRsZUdhbWVPdmVyQ2xpY2tzIChlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQgIT0gdGhpcy5zbG93U3BlZWRDaGVja2JveCkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgaWYgKHRoaXMuZGlzdGFuY2VNZXRlci5oYXNDbGlja2VkT25IaWdoU2NvcmUoZSkgJiYgdGhpcy5oaWdoZXN0U2NvcmUpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXN0YW5jZU1ldGVyLmlzSGlnaFNjb3JlRmxhc2hpbmcoKSkge1xyXG4gICAgICAgICAgLy8gU3Vic2VxdWVudCBjbGljaywgcmVzZXQgdGhlIGhpZ2ggc2NvcmUuXHJcbiAgICAgICAgICB0aGlzLnNhdmVIaWdoU2NvcmUoMCwgdHJ1ZSlcclxuICAgICAgICAgIHRoaXMuZGlzdGFuY2VNZXRlci5yZXNldEhpZ2hTY29yZSgpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEZpcnN0IGNsaWNrLCBmbGFzaCB0aGUgaGlnaCBzY29yZS5cclxuICAgICAgICAgIHRoaXMuZGlzdGFuY2VNZXRlci5zdGFydEhpZ2hTY29yZUZsYXNoaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZU1ldGVyLmNhbmNlbEhpZ2hTY29yZUZsYXNoaW5nKClcclxuICAgICAgICB0aGlzLnJlc3RhcnQoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBldmVudCB3YXMgYSBsZWZ0IGNsaWNrIG9uIGNhbnZhcy5cclxuICAgKiBPbiBXaW5kb3dzIHJpZ2h0IGNsaWNrIGlzIHJlZ2lzdGVyZWQgYXMgYSBjbGljay5cclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBpc0xlZnRDbGlja09uQ2FudmFzIChlKSB7XHJcbiAgICByZXR1cm4gZS5idXR0b24gIT0gbnVsbCAmJiBlLmJ1dHRvbiA8IDIgJiZcclxuICAgICAgZS50eXBlID09PSBSdW5uZXIuZXZlbnRzLlBPSU5URVJVUCAmJlxyXG4gICAgICAoZS50YXJnZXQgPT09IHRoaXMuY2FudmFzIHx8XHJcbiAgICAgICAgKElTX01PQklMRSAmJiBSdW5uZXIuYXVkaW9DdWVzICYmIGUudGFyZ2V0ID09PSB0aGlzLmNvbnRhaW5lckVsKSlcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd3JhcHBlci5cclxuICAgKi9cclxuICBzY2hlZHVsZU5leHRVcGRhdGUgKCkge1xyXG4gICAgaWYgKCF0aGlzLnVwZGF0ZVBlbmRpbmcpIHtcclxuICAgICAgdGhpcy51cGRhdGVQZW5kaW5nID0gdHJ1ZVxyXG4gICAgICB0aGlzLnJhcUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgZ2FtZSBpcyBydW5uaW5nLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNSdW5uaW5nICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMucmFxSWRcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGluaXRpYWwgaGlnaCBzY29yZSBhcyBzdG9yZWQgaW4gdGhlIHVzZXIncyBwcm9maWxlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoU2NvcmVcclxuICAgKi9cclxuICBpbml0aWFsaXplSGlnaFNjb3JlIChoaWdoU2NvcmUpIHtcclxuICAgIHRoaXMuc3luY0hpZ2hlc3RTY29yZSA9IHRydWVcclxuICAgIGhpZ2hTY29yZSA9IE1hdGguY2VpbChoaWdoU2NvcmUpXHJcbiAgICBpZiAoaGlnaFNjb3JlIDwgdGhpcy5oaWdoZXN0U2NvcmUpIHtcclxuICAgICAgaWYgKHdpbmRvdy5lcnJvclBhZ2VDb250cm9sbGVyKSB7XHJcbiAgICAgICAgZXJyb3JQYWdlQ29udHJvbGxlci51cGRhdGVFYXN0ZXJFZ2dIaWdoU2NvcmUodGhpcy5oaWdoZXN0U2NvcmUpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICB0aGlzLmhpZ2hlc3RTY29yZSA9IGhpZ2hTY29yZVxyXG4gICAgdGhpcy5kaXN0YW5jZU1ldGVyLnNldEhpZ2hTY29yZSh0aGlzLmhpZ2hlc3RTY29yZSlcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGhpZ2ggc2NvcmUgYW5kIHNhdmVzIHRvIHRoZSBwcm9maWxlIGlmIGF2YWlsYWJsZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VSYW4gVG90YWwgZGlzdGFuY2UgcmFuLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdFJlc2V0U2NvcmUgV2hldGhlciB0byByZXNldCB0aGUgc2NvcmUuXHJcbiAgICovXHJcbiAgc2F2ZUhpZ2hTY29yZSAoZGlzdGFuY2VSYW4sIG9wdFJlc2V0U2NvcmUpIHtcclxuICAgIHRoaXMuaGlnaGVzdFNjb3JlID0gTWF0aC5jZWlsKGRpc3RhbmNlUmFuKVxyXG4gICAgdGhpcy5kaXN0YW5jZU1ldGVyLnNldEhpZ2hTY29yZSh0aGlzLmhpZ2hlc3RTY29yZSlcclxuXHJcbiAgICAvLyBTdG9yZSB0aGUgbmV3IGhpZ2ggc2NvcmUgaW4gdGhlIHByb2ZpbGUuXHJcbiAgICBpZiAodGhpcy5zeW5jSGlnaGVzdFNjb3JlICYmIHdpbmRvdy5lcnJvclBhZ2VDb250cm9sbGVyKSB7XHJcbiAgICAgIGlmIChvcHRSZXNldFNjb3JlKSB7XHJcbiAgICAgICAgZXJyb3JQYWdlQ29udHJvbGxlci5yZXNldEVhc3RlckVnZ0hpZ2hTY29yZSgpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXJyb3JQYWdlQ29udHJvbGxlci51cGRhdGVFYXN0ZXJFZ2dIaWdoU2NvcmUodGhpcy5oaWdoZXN0U2NvcmUpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHYW1lIG92ZXIgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2FtZU92ZXIgKCkge1xyXG4gICAgdGhpcy5wbGF5U291bmQodGhpcy5zb3VuZEZ4LkhJVClcclxuICAgIHZpYnJhdGUoMjAwKVxyXG5cclxuICAgIHRoaXMuc3RvcCgpXHJcbiAgICB0aGlzLmNyYXNoZWQgPSB0cnVlXHJcbiAgICB0aGlzLmRpc3RhbmNlTWV0ZXIuYWNoaWV2ZW1lbnQgPSBmYWxzZVxyXG5cclxuICAgIHRoaXMudFJleC51cGRhdGUoMTAwLCBUcmV4LnN0YXR1cy5DUkFTSEVEKVxyXG5cclxuICAgIC8vIEdhbWUgb3ZlciBwYW5lbC5cclxuICAgIGlmICghdGhpcy5nYW1lT3ZlclBhbmVsKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdTcHJpdGVEZWYgPSBJU19ISURQSVxyXG4gICAgICAgID8gUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGUub3JpZ2luYWwuSERQSVxyXG4gICAgICAgIDogUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGUub3JpZ2luYWwuTERQSVxyXG5cclxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XHJcbiAgICAgICAgaWYgKFJ1bm5lci5pc0FsdEdhbWVNb2RlRW5hYmxlZCkge1xyXG4gICAgICAgICAgdGhpcy5nYW1lT3ZlclBhbmVsID0gbmV3IEdhbWVPdmVyUGFuZWwoXHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLCBvcmlnU3ByaXRlRGVmLlRFWFRfU1BSSVRFLCBvcmlnU3ByaXRlRGVmLlJFU1RBUlQsXHJcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucywgb3JpZ1Nwcml0ZURlZi5BTFRfR0FNRV9FTkQsXHJcbiAgICAgICAgICAgIHRoaXMuYWx0R2FtZU1vZGVBY3RpdmUpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuZ2FtZU92ZXJQYW5lbCA9IG5ldyBHYW1lT3ZlclBhbmVsKFxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcywgb3JpZ1Nwcml0ZURlZi5URVhUX1NQUklURSwgb3JpZ1Nwcml0ZURlZi5SRVNUQVJULFxyXG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nYW1lT3ZlclBhbmVsLmRyYXcodGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSwgdGhpcy50UmV4KVxyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgaGlnaCBzY29yZS5cclxuICAgIGlmICh0aGlzLmRpc3RhbmNlUmFuID4gdGhpcy5oaWdoZXN0U2NvcmUpIHtcclxuICAgICAgdGhpcy5zYXZlSGlnaFNjb3JlKHRoaXMuZGlzdGFuY2VSYW4pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgdGhlIHRpbWUgY2xvY2suXHJcbiAgICB0aGlzLnRpbWUgPSBnZXRUaW1lU3RhbXAoKVxyXG5cclxuICAgIGlmIChSdW5uZXIuYXVkaW9DdWVzKSB7XHJcbiAgICAgIHRoaXMuZ2VuZXJhdGVkU291bmRGeC5zdG9wQWxsKClcclxuICAgICAgYW5ub3VuY2VQaHJhc2UoXHJcbiAgICAgICAgZ2V0QTExeVN0cmluZyhBMTFZX1NUUklOR1MuZ2FtZU92ZXIpXHJcbiAgICAgICAgICAucmVwbGFjZShcclxuICAgICAgICAgICAgJyQxJyxcclxuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZU1ldGVyLmdldEFjdHVhbERpc3RhbmNlKHRoaXMuZGlzdGFuY2VSYW4pXHJcbiAgICAgICAgICAgICAgLnRvU3RyaW5nKCkpICtcclxuICAgICAgICAnICcgK1xyXG4gICAgICAgIGdldEExMXlTdHJpbmcoQTExWV9TVFJJTkdTLmhpZ2hTY29yZSlcclxuICAgICAgICAgIC5yZXBsYWNlKFxyXG4gICAgICAgICAgICAnJDEnLFxyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZU1ldGVyLmdldEFjdHVhbERpc3RhbmNlKHRoaXMuaGlnaGVzdFNjb3JlKVxyXG4gICAgICAgICAgICAgIC50b1N0cmluZygpKSlcclxuICAgICAgdGhpcy5jb250YWluZXJFbC5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAgJ3RpdGxlJywgZ2V0QTExeVN0cmluZyhBMTFZX1NUUklOR1MuYXJpYUxhYmVsKSlcclxuICAgIH1cclxuICAgIHRoaXMuc2hvd1NwZWVkVG9nZ2xlKClcclxuICAgIHRoaXMuZGlzYWJsZVNwZWVkVG9nZ2xlKGZhbHNlKVxyXG4gIH0sXHJcblxyXG4gIHN0b3AgKCkge1xyXG4gICAgdGhpcy5zZXRQbGF5U3RhdHVzKGZhbHNlKVxyXG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlXHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhcUlkKVxyXG4gICAgdGhpcy5yYXFJZCA9IDBcclxuICAgIHRoaXMuZ2VuZXJhdGVkU291bmRGeC5zdG9wQWxsKClcclxuICB9LFxyXG5cclxuICBwbGF5ICgpIHtcclxuICAgIGlmICghdGhpcy5jcmFzaGVkKSB7XHJcbiAgICAgIHRoaXMuc2V0UGxheVN0YXR1cyh0cnVlKVxyXG4gICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXHJcbiAgICAgIHRoaXMudFJleC51cGRhdGUoMCwgVHJleC5zdGF0dXMuUlVOTklORylcclxuICAgICAgdGhpcy50aW1lID0gZ2V0VGltZVN0YW1wKClcclxuICAgICAgdGhpcy51cGRhdGUoKVxyXG4gICAgICB0aGlzLmdlbmVyYXRlZFNvdW5kRnguYmFja2dyb3VuZCgpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcmVzdGFydCAoKSB7XHJcbiAgICBpZiAoIXRoaXMucmFxSWQpIHtcclxuICAgICAgdGhpcy5wbGF5Q291bnQrK1xyXG4gICAgICB0aGlzLnJ1bm5pbmdUaW1lID0gMFxyXG4gICAgICB0aGlzLnNldFBsYXlTdGF0dXModHJ1ZSlcclxuICAgICAgdGhpcy50b2dnbGVTcGVlZCgpXHJcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2VcclxuICAgICAgdGhpcy5jcmFzaGVkID0gZmFsc2VcclxuICAgICAgdGhpcy5kaXN0YW5jZVJhbiA9IDBcclxuICAgICAgdGhpcy5zZXRTcGVlZCh0aGlzLmNvbmZpZy5TUEVFRClcclxuICAgICAgdGhpcy50aW1lID0gZ2V0VGltZVN0YW1wKClcclxuICAgICAgdGhpcy5jb250YWluZXJFbC5jbGFzc0xpc3QucmVtb3ZlKFJ1bm5lci5jbGFzc2VzLkNSQVNIRUQpXHJcbiAgICAgIHRoaXMuY2xlYXJDYW52YXMoKVxyXG4gICAgICB0aGlzLmRpc3RhbmNlTWV0ZXIucmVzZXQoKVxyXG4gICAgICB0aGlzLmhvcml6b24ucmVzZXQoKVxyXG4gICAgICB0aGlzLnRSZXgucmVzZXQoKVxyXG4gICAgICB0aGlzLnBsYXlTb3VuZCh0aGlzLnNvdW5kRnguQlVUVE9OX1BSRVNTKVxyXG4gICAgICB0aGlzLmludmVydCh0cnVlKVxyXG4gICAgICB0aGlzLmZsYXNoVGltZXIgPSBudWxsXHJcbiAgICAgIHRoaXMudXBkYXRlKClcclxuICAgICAgdGhpcy5nYW1lT3ZlclBhbmVsLnJlc2V0KClcclxuICAgICAgdGhpcy5nZW5lcmF0ZWRTb3VuZEZ4LmJhY2tncm91bmQoKVxyXG4gICAgICB0aGlzLmNvbnRhaW5lckVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBnZXRBMTF5U3RyaW5nKEExMVlfU1RSSU5HUy5qdW1wKSlcclxuICAgICAgYW5ub3VuY2VQaHJhc2UoZ2V0QTExeVN0cmluZyhBMTFZX1NUUklOR1Muc3RhcnRlZCkpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgc2V0UGxheVN0YXR1cyAoaXNQbGF5aW5nKSB7XHJcbiAgICBpZiAodGhpcy50b3VjaENvbnRyb2xsZXIpIHtcclxuICAgICAgdGhpcy50b3VjaENvbnRyb2xsZXIuY2xhc3NMaXN0LnRvZ2dsZShISURERU5fQ0xBU1MsICFpc1BsYXlpbmcpXHJcbiAgICB9XHJcbiAgICB0aGlzLnBsYXlpbmcgPSBpc1BsYXlpbmdcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBnYW1lIHNob3VsZCBnbyBpbnRvIGFyY2FkZSBtb2RlLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNBcmNhZGVNb2RlICgpIHtcclxuICAgIC8vIEluIFJUTCBsYW5ndWFnZXMgdGhlIHRpdGxlIGlzIHdyYXBwZWQgd2l0aCB0aGUgbGVmdCB0byByaWdodCBtYXJrXHJcbiAgICAvLyBjb250cm9sIGNoYXJhY3RlcnMgJiN4MjAyQTsgYW5kICYjeDIwMkMgYnV0IGFyZSBpbnZpc2libGUuXHJcbiAgICByZXR1cm4gSVNfUlRMXHJcbiAgICAgID8gZG9jdW1lbnQudGl0bGUuaW5kZXhPZihBUkNBREVfTU9ERV9VUkwpID09IDFcclxuICAgICAgOiBkb2N1bWVudC50aXRsZSA9PT0gQVJDQURFX01PREVfVVJMXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSGlkZXMgb2ZmbGluZSBtZXNzYWdpbmcgZm9yIGEgZnVsbHNjcmVlbiBnYW1lIG9ubHkgZXhwZXJpZW5jZS5cclxuICAgKi9cclxuICBzZXRBcmNhZGVNb2RlICgpIHtcclxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChSdW5uZXIuY2xhc3Nlcy5BUkNBREVfTU9ERSlcclxuICAgIHRoaXMuc2V0QXJjYWRlTW9kZUNvbnRhaW5lclNjYWxlKClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzY2FsaW5nIGZvciBhcmNhZGUgbW9kZS5cclxuICAgKi9cclxuICBzZXRBcmNhZGVNb2RlQ29udGFpbmVyU2NhbGUgKCkge1xyXG4gICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XHJcbiAgICBjb25zdCBzY2FsZUhlaWdodCA9IHdpbmRvd0hlaWdodCAvIHRoaXMuZGltZW5zaW9ucy5IRUlHSFRcclxuICAgIGNvbnN0IHNjYWxlV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHRoaXMuZGltZW5zaW9ucy5XSURUSFxyXG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihzY2FsZUhlaWdodCwgc2NhbGVXaWR0aCkpXHJcbiAgICBjb25zdCBzY2FsZWRDYW52YXNIZWlnaHQgPSB0aGlzLmRpbWVuc2lvbnMuSEVJR0hUICogc2NhbGVcclxuICAgIC8vIFBvc2l0aW9ucyB0aGUgZ2FtZSBjb250YWluZXIgYXQgMTAlIG9mIHRoZSBhdmFpbGFibGUgdmVydGljYWwgd2luZG93XHJcbiAgICAvLyBoZWlnaHQgbWludXMgdGhlIGdhbWUgY29udGFpbmVyIGhlaWdodC5cclxuICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSBNYXRoLmNlaWwoTWF0aC5tYXgoMCwgKHdpbmRvd0hlaWdodCAtIHNjYWxlZENhbnZhc0hlaWdodCAtXHJcbiAgICAgICAgICBSdW5uZXIuY29uZmlnLkFSQ0FERV9NT0RFX0lOSVRJQUxfVE9QX1BPU0lUSU9OKSAqXHJcbiAgICAgICAgUnVubmVyLmNvbmZpZy5BUkNBREVfTU9ERV9UT1BfUE9TSVRJT05fUEVSQ0VOVCkpICpcclxuICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW9cclxuXHJcbiAgICBjb25zdCBjc3NTY2FsZSA9IElTX1JUTCA/IC1zY2FsZSArICcsJyArIHNjYWxlIDogc2NhbGVcclxuICAgIHRoaXMuY29udGFpbmVyRWwuc3R5bGUudHJhbnNmb3JtID1cclxuICAgICAgJ3NjYWxlKCcgKyBjc3NTY2FsZSArICcpIHRyYW5zbGF0ZVkoJyArIHRyYW5zbGF0ZVkgKyAncHgpJ1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBnYW1lIGlmIHRoZSB0YWIgaXMgbm90IGluIGZvY3VzLlxyXG4gICAqL1xyXG4gIG9uVmlzaWJpbGl0eUNoYW5nZSAoZSkge1xyXG4gICAgaWYgKGRvY3VtZW50LmhpZGRlbiB8fCBkb2N1bWVudC53ZWJraXRIaWRkZW4gfHwgZS50eXBlID09PSAnYmx1cicgfHxcclxuICAgICAgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSAndmlzaWJsZScpIHtcclxuICAgICAgdGhpcy5zdG9wKClcclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3Jhc2hlZCkge1xyXG4gICAgICB0aGlzLnRSZXgucmVzZXQoKVxyXG4gICAgICB0aGlzLnBsYXkoKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYXkgYSBzb3VuZC5cclxuICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBzb3VuZEJ1ZmZlclxyXG4gICAqL1xyXG4gIHBsYXlTb3VuZCAoc291bmRCdWZmZXIpIHtcclxuICAgIGlmIChzb3VuZEJ1ZmZlcikge1xyXG4gICAgICBjb25zdCBzb3VyY2VOb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKClcclxuICAgICAgc291cmNlTm9kZS5idWZmZXIgPSBzb3VuZEJ1ZmZlclxyXG4gICAgICBzb3VyY2VOb2RlLmNvbm5lY3QodGhpcy5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pXHJcbiAgICAgIHNvdXJjZU5vZGUuc3RhcnQoMClcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBJbnZlcnRzIHRoZSBjdXJyZW50IHBhZ2UgLyBjYW52YXMgY29sb3JzLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzZXQgV2hldGhlciB0byByZXNldCBjb2xvcnMuXHJcbiAgICovXHJcbiAgaW52ZXJ0IChyZXNldCkge1xyXG4gICAgY29uc3QgaHRtbEVsID0gZG9jdW1lbnQuZmlyc3RFbGVtZW50Q2hpbGRcclxuXHJcbiAgICBpZiAocmVzZXQpIHtcclxuICAgICAgaHRtbEVsLmNsYXNzTGlzdC50b2dnbGUoUnVubmVyLmNsYXNzZXMuSU5WRVJURUQsXHJcbiAgICAgICAgZmFsc2UpXHJcbiAgICAgIHRoaXMuaW52ZXJ0VGltZXIgPSAwXHJcbiAgICAgIHRoaXMuaW52ZXJ0ZWQgPSBmYWxzZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5pbnZlcnRlZCA9IGh0bWxFbC5jbGFzc0xpc3QudG9nZ2xlKFxyXG4gICAgICAgIFJ1bm5lci5jbGFzc2VzLklOVkVSVEVELCB0aGlzLmludmVydFRyaWdnZXIpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgY2FudmFzIHNpemUgdGFraW5nIGludG9cclxuICogYWNjb3VudCB0aGUgYmFja2luZyBzdG9yZSBwaXhlbCByYXRpbyBhbmRcclxuICogdGhlIGRldmljZSBwaXhlbCByYXRpby5cclxuICpcclxuICogU2VlIGFydGljbGUgYnkgUGF1bCBMZXdpczpcclxuICogaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2hpZHBpL1xyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcclxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfd2lkdGhcclxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGVpZ2h0XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNhbnZhcyB3YXMgc2NhbGVkLlxyXG4gKi9cclxuUnVubmVyLnVwZGF0ZUNhbnZhc1NjYWxpbmcgPSBmdW5jdGlvbiAoY2FudmFzLCBvcHRfd2lkdGgsIG9wdF9oZWlnaHQpIHtcclxuICBjb25zdCBjb250ZXh0ID1cclxuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoY2FudmFzLmdldENvbnRleHQoJzJkJykpXHJcblxyXG4gIC8vIFF1ZXJ5IHRoZSB2YXJpb3VzIHBpeGVsIHJhdGlvc1xyXG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBNYXRoLmZsb29yKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxXHJcbiAgLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXHJcbiAgY29uc3QgYmFja2luZ1N0b3JlUmF0aW8gPVxyXG4gICAgTWF0aC5mbG9vcihjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8pIHx8IDFcclxuICBjb25zdCByYXRpbyA9IGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpb1xyXG5cclxuICAvLyBVcHNjYWxlIHRoZSBjYW52YXMgaWYgdGhlIHR3byByYXRpb3MgZG9uJ3QgbWF0Y2hcclxuICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyAhPT0gYmFja2luZ1N0b3JlUmF0aW8pIHtcclxuICAgIGNvbnN0IG9sZFdpZHRoID0gb3B0X3dpZHRoIHx8IGNhbnZhcy53aWR0aFxyXG4gICAgY29uc3Qgb2xkSGVpZ2h0ID0gb3B0X2hlaWdodCB8fCBjYW52YXMuaGVpZ2h0XHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gb2xkV2lkdGggKiByYXRpb1xyXG4gICAgY2FudmFzLmhlaWdodCA9IG9sZEhlaWdodCAqIHJhdGlvXHJcblxyXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gb2xkV2lkdGggKyAncHgnXHJcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb2xkSGVpZ2h0ICsgJ3B4J1xyXG5cclxuICAgIC8vIFNjYWxlIHRoZSBjb250ZXh0IHRvIGNvdW50ZXIgdGhlIGZhY3QgdGhhdCB3ZSd2ZSBtYW51YWxseSBzY2FsZWRcclxuICAgIC8vIG91ciBjYW52YXMgZWxlbWVudC5cclxuICAgIGNvbnRleHQuc2NhbGUocmF0aW8sIHJhdGlvKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9IGVsc2UgaWYgKGRldmljZVBpeGVsUmF0aW8gPT09IDEpIHtcclxuICAgIC8vIFJlc2V0IHRoZSBjYW52YXMgd2lkdGggLyBoZWlnaHQuIEZpeGVzIHNjYWxpbmcgYnVnIHdoZW4gdGhlIHBhZ2UgaXNcclxuICAgIC8vIHpvb21lZCBhbmQgdGhlIGRldmljZVBpeGVsUmF0aW8gY2hhbmdlcyBhY2NvcmRpbmdseS5cclxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCArICdweCdcclxuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICsgJ3B4J1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgZXZlbnRzIGFyZSBlbmFibGVkLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuUnVubmVyLmlzQWx0R2FtZU1vZGVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBsb2FkVGltZURhdGEgJiYgbG9hZFRpbWVEYXRhLnZhbHVlRXhpc3RzKCdlbmFibGVBbHRHYW1lTW9kZScpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZWQgc291bmQgRlggY2xhc3MgZm9yIGF1ZGlvIGN1ZXMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gR2VuZXJhdGVkU291bmRGeCAoKSB7XHJcbiAgdGhpcy5hdWRpb0N1ZXMgPSBmYWxzZVxyXG4gIHRoaXMuY29udGV4dCA9IG51bGxcclxuICB0aGlzLnBhbm5lciA9IG51bGxcclxufVxyXG5cclxuR2VuZXJhdGVkU291bmRGeC5wcm90b3R5cGUgPSB7XHJcbiAgaW5pdCAoKSB7XHJcbiAgICB0aGlzLmF1ZGlvQ3VlcyA9IHRydWVcclxuICAgIGlmICghdGhpcy5jb250ZXh0KSB7XHJcbiAgICAgIC8vIGlPUyBvbmx5IHN1cHBvcnRzIHRoZSB3ZWJraXQgdmVyc2lvbi5cclxuICAgICAgdGhpcy5jb250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxyXG4gICAgICAgID8gbmV3IHdlYmtpdEF1ZGlvQ29udGV4dCgpXHJcbiAgICAgICAgOiBuZXcgQXVkaW9Db250ZXh0KClcclxuICAgICAgaWYgKElTX0lPUykge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5vbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdGF0ZSAhPSAncnVubmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3VtZSgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlc3VtZSgpXHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyXHJcbiAgICAgICAgPyB0aGlzLmNvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyKClcclxuICAgICAgICA6IG51bGxcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBzdG9wQWxsICgpIHtcclxuICAgIHRoaXMuY2FuY2VsRm9vdFN0ZXBzKClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IG9zY2lsbGF0b3JzIGF0IGNlcnRhaW4gZnJlcXVlbmN5IGFuZCBmb3IgYSBjZXJ0YWluIHRpbWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyZXF1ZW5jeVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFRpbWVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cclxuICAgKiBAcGFyYW0gez9udW1iZXI9fSBvcHRfdm9sXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcGFuXHJcbiAgICovXHJcbiAgcGxheU5vdGUgKGZyZXF1ZW5jeSwgc3RhcnRUaW1lLCBkdXJhdGlvbiwgb3B0X3ZvbCwgb3B0X3Bhbikge1xyXG4gICAgY29uc3Qgb3NjMSA9IHRoaXMuY29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKClcclxuICAgIGNvbnN0IG9zYzIgPSB0aGlzLmNvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpXHJcbiAgICBjb25zdCB2b2x1bWUgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpXHJcblxyXG4gICAgLy8gU2V0IG9zY2lsbGF0b3Igd2F2ZSB0eXBlXHJcbiAgICBvc2MxLnR5cGUgPSAndHJpYW5nbGUnXHJcbiAgICBvc2MyLnR5cGUgPSAndHJpYW5nbGUnXHJcbiAgICB2b2x1bWUuZ2Fpbi52YWx1ZSA9IDAuMVxyXG5cclxuICAgIC8vIFNldCB1cCBub2RlIHJvdXRpbmdcclxuICAgIGlmICh0aGlzLnBhbm5lcikge1xyXG4gICAgICB0aGlzLnBhbm5lci5wYW4udmFsdWUgPSBvcHRfcGFuIHx8IDBcclxuICAgICAgb3NjMS5jb25uZWN0KHZvbHVtZSkuY29ubmVjdCh0aGlzLnBhbm5lcilcclxuICAgICAgb3NjMi5jb25uZWN0KHZvbHVtZSkuY29ubmVjdCh0aGlzLnBhbm5lcilcclxuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvc2MxLmNvbm5lY3Qodm9sdW1lKVxyXG4gICAgICBvc2MyLmNvbm5lY3Qodm9sdW1lKVxyXG4gICAgICB2b2x1bWUuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0dW5lIG9zY2lsbGF0b3JzIGZvciBjaG9ydXMgZWZmZWN0XHJcbiAgICBvc2MxLmZyZXF1ZW5jeS52YWx1ZSA9IGZyZXF1ZW5jeSArIDFcclxuICAgIG9zYzIuZnJlcXVlbmN5LnZhbHVlID0gZnJlcXVlbmN5IC0gMlxyXG5cclxuICAgIC8vIEZhZGUgb3V0XHJcbiAgICB2b2x1bWUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShvcHRfdm9sIHx8IDAuMDEsIHN0YXJ0VGltZSArIGR1cmF0aW9uIC0gMC4wNSlcclxuICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAuMDAwMDEsIHN0YXJ0VGltZSArIGR1cmF0aW9uKVxyXG5cclxuICAgIC8vIFN0YXJ0IG9zY2lsbGF0b3JzXHJcbiAgICBvc2MxLnN0YXJ0KHN0YXJ0VGltZSlcclxuICAgIG9zYzIuc3RhcnQoc3RhcnRUaW1lKVxyXG4gICAgLy8gU3RvcCBvc2NpbGxhdG9yc1xyXG4gICAgb3NjMS5zdG9wKHN0YXJ0VGltZSArIGR1cmF0aW9uKVxyXG4gICAgb3NjMi5zdG9wKHN0YXJ0VGltZSArIGR1cmF0aW9uKVxyXG4gIH0sXHJcblxyXG4gIGJhY2tncm91bmQgKCkge1xyXG4gICAgaWYgKHRoaXMuYXVkaW9DdWVzKSB7XHJcbiAgICAgIGNvbnN0IG5vdyA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZVxyXG4gICAgICB0aGlzLnBsYXlOb3RlKDQ5My44ODMsIG5vdywgMC4xMTYpXHJcbiAgICAgIHRoaXMucGxheU5vdGUoNjU5LjI1NSwgbm93ICsgMC4xMTYsIDAuMjMyKVxyXG4gICAgICB0aGlzLmxvb3BGb290U3RlcHMoKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGxvb3BGb290U3RlcHMgKCkge1xyXG4gICAgaWYgKHRoaXMuYXVkaW9DdWVzICYmICF0aGlzLmJnU291bmRJbnRlcnZhbElkKSB7XHJcbiAgICAgIHRoaXMuYmdTb3VuZEludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wbGF5Tm90ZSg3My40MiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjA1LCAwLjE2KVxyXG4gICAgICAgIHRoaXMucGxheU5vdGUoNjkuMzAsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIDAuMTE2LCAwLjExNiwgMC4xNilcclxuICAgICAgfS5iaW5kKHRoaXMpLCAyODApXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY2FuY2VsRm9vdFN0ZXBzICgpIHtcclxuICAgIGlmICh0aGlzLmF1ZGlvQ3VlcyAmJiB0aGlzLmJnU291bmRJbnRlcnZhbElkKSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5iZ1NvdW5kSW50ZXJ2YWxJZClcclxuICAgICAgdGhpcy5iZ1NvdW5kSW50ZXJ2YWxJZCA9IG51bGxcclxuICAgICAgdGhpcy5wbGF5Tm90ZSgxMDMuODMsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4yMzIsIDAuMDIpXHJcbiAgICAgIHRoaXMucGxheU5vdGUoMTE2LjU0LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyAwLjExNiwgMC4yMzIsIDAuMDIpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY29sbGVjdCAoKSB7XHJcbiAgICBpZiAodGhpcy5hdWRpb0N1ZXMpIHtcclxuICAgICAgdGhpcy5jYW5jZWxGb290U3RlcHMoKVxyXG4gICAgICBjb25zdCBub3cgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWVcclxuICAgICAgdGhpcy5wbGF5Tm90ZSg4MzAuNjEsIG5vdywgMC4xMTYpXHJcbiAgICAgIHRoaXMucGxheU5vdGUoMTMxOC41MSwgbm93ICsgMC4xMTYsIDAuMjMyKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGp1bXAgKCkge1xyXG4gICAgaWYgKHRoaXMuYXVkaW9DdWVzKSB7XHJcbiAgICAgIGNvbnN0IG5vdyA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZVxyXG4gICAgICB0aGlzLnBsYXlOb3RlKDY1OS4yNSwgbm93LCAwLjExNiwgMC4zLCAtMC42KVxyXG4gICAgICB0aGlzLnBsYXlOb3RlKDg4MCwgbm93ICsgMC4xMTYsIDAuMjMyLCAwLjMsIC0wLjYpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3BlYWsgYSBwaHJhc2UgdXNpbmcgU3BlZWNoIFN5bnRoZXNpcyBBUEkgZm9yIGExMXkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwaHJhc2UgU2VudGVuY2UgdG8gc3BlYWsuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGVha1BocmFzZSAocGhyYXNlKSB7XHJcbiAgaWYgKCdzcGVlY2hTeW50aGVzaXMnIGluIHdpbmRvdykge1xyXG4gICAgY29uc3QgbXNnID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZShwaHJhc2UpXHJcbiAgICBjb25zdCB2b2ljZXMgPSB3aW5kb3cuc3BlZWNoU3ludGhlc2lzLmdldFZvaWNlcygpXHJcbiAgICBtc2cudGV4dCA9IHBocmFzZVxyXG4gICAgc3BlZWNoU3ludGhlc2lzLnNwZWFrKG1zZylcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3Igc2NyZWVuIHJlYWRlcnMgbWFrZSBhbiBhbm5vdW5jZW1lbnQgdG8gdGhlIGxpdmUgcmVnaW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGhyYXNlIFNlbnRlbmNlIHRvIHNwZWFrLlxyXG4gKi9cclxuZnVuY3Rpb24gYW5ub3VuY2VQaHJhc2UgKHBocmFzZSkge1xyXG4gIGlmIChSdW5uZXIuYTExeVN0YXR1c0VsKSB7XHJcbiAgICBSdW5uZXIuYTExeVN0YXR1c0VsLnRleHRDb250ZW50ID0gJydcclxuICAgIFJ1bm5lci5hMTF5U3RhdHVzRWwudGV4dENvbnRlbnQgPSBwaHJhc2VcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIGZyb20gbG9hZFRpbWVEYXRhIGRhdGEgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nTmFtZVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBMTF5U3RyaW5nIChzdHJpbmdOYW1lKSB7XHJcbiAgcmV0dXJuIGxvYWRUaW1lRGF0YSAmJiBsb2FkVGltZURhdGEudmFsdWVFeGlzdHMoc3RyaW5nTmFtZSlcclxuICAgID8gbG9hZFRpbWVEYXRhLmdldFN0cmluZyhzdHJpbmdOYW1lKVxyXG4gICAgOiAnJ1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHJhbmRvbSBudW1iZXIuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cclxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmFuZG9tTnVtIChtaW4sIG1heCkge1xyXG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWaWJyYXRlIG9uIG1vYmlsZSBkZXZpY2VzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIHZpYnJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2aWJyYXRlIChkdXJhdGlvbikge1xyXG4gIGlmIChJU19NT0JJTEUgJiYgd2luZG93Lm5hdmlnYXRvci52aWJyYXRlKSB7XHJcbiAgICB3aW5kb3cubmF2aWdhdG9yLnZpYnJhdGUoZHVyYXRpb24pXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGNhbnZhcyBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciBFbGVtZW50IHRvIGFwcGVuZCBjYW52YXMgdG8uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2NsYXNzbmFtZVxyXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyAoY29udGFpbmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRfY2xhc3NuYW1lKSB7XHJcbiAgY29uc3QgY2FudmFzID1cclxuICAgIC8qKiBAdHlwZSB7IUhUTUxDYW52YXNFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpXHJcbiAgY2FudmFzLmNsYXNzTmFtZSA9IG9wdF9jbGFzc25hbWVcclxuICAgID8gUnVubmVyLmNsYXNzZXMuQ0FOVkFTICsgJyAnICtcclxuICAgIG9wdF9jbGFzc25hbWVcclxuICAgIDogUnVubmVyLmNsYXNzZXMuQ0FOVkFTXHJcbiAgY2FudmFzLndpZHRoID0gd2lkdGhcclxuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XHJcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcylcclxuXHJcbiAgcmV0dXJuIGNhbnZhc1xyXG59XHJcblxyXG4vKipcclxuICogRGVjb2RlcyB0aGUgYmFzZSA2NCBhdWRpbyB0byBBcnJheUJ1ZmZlciB1c2VkIGJ5IFdlYiBBdWRpby5cclxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0VG9BcnJheUJ1ZmZlciAoYmFzZTY0U3RyaW5nKSB7XHJcbiAgY29uc3QgbGVuID0gKGJhc2U2NFN0cmluZy5sZW5ndGggLyA0KSAqIDNcclxuICBjb25zdCBzdHIgPSBhdG9iKGJhc2U2NFN0cmluZylcclxuICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pXHJcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcilcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKVxyXG4gIH1cclxuICByZXR1cm4gYnl0ZXMuYnVmZmVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUaW1lU3RhbXAgKCkge1xyXG4gIHJldHVybiBJU19JT1MgPyBuZXcgRGF0ZSgpLmdldFRpbWUoKSA6IHBlcmZvcm1hbmNlLm5vdygpXHJcbn1cclxuXHJcbi8vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuLyoqXHJcbiAqIEdhbWUgb3ZlciBwYW5lbC5cclxuICogQHBhcmFtIHshSFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dEltZ1Bvc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdGFydEltZ1Bvc1xyXG4gKiBAcGFyYW0geyFPYmplY3R9IGRpbWVuc2lvbnMgQ2FudmFzIGRpbWVuc2lvbnMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2FsdEdhbWVFbmRJbWdQb3NcclxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2FsdEdhbWVBY3RpdmVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBHYW1lT3ZlclBhbmVsIChcclxuICBjYW52YXMsIHRleHRJbWdQb3MsIHJlc3RhcnRJbWdQb3MsIGRpbWVuc2lvbnMsIG9wdF9hbHRHYW1lRW5kSW1nUG9zLFxyXG4gIG9wdF9hbHRHYW1lQWN0aXZlKSB7XHJcbiAgdGhpcy5jYW52YXMgPSBjYW52YXNcclxuICB0aGlzLmNhbnZhc0N0eCA9XHJcbiAgICAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi8gKGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKVxyXG4gIHRoaXMuY2FudmFzRGltZW5zaW9ucyA9IGRpbWVuc2lvbnNcclxuICB0aGlzLnRleHRJbWdQb3MgPSB0ZXh0SW1nUG9zXHJcbiAgdGhpcy5yZXN0YXJ0SW1nUG9zID0gcmVzdGFydEltZ1Bvc1xyXG4gIHRoaXMuYWx0R2FtZUVuZEltZ1BvcyA9IG9wdF9hbHRHYW1lRW5kSW1nUG9zXHJcbiAgdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSA9IG9wdF9hbHRHYW1lQWN0aXZlXHJcblxyXG4gIC8vIFJldHJ5IGFuaW1hdGlvbi5cclxuICB0aGlzLmZyYW1lVGltZVN0YW1wID0gMFxyXG4gIHRoaXMuYW5pbVRpbWVyID0gMFxyXG4gIHRoaXMuY3VycmVudEZyYW1lID0gMFxyXG5cclxuICB0aGlzLmdhbWVPdmVyUmFmSWQgPSBudWxsXHJcblxyXG4gIHRoaXMuZmxhc2hUaW1lciA9IDBcclxuICB0aGlzLmZsYXNoQ291bnRlciA9IDBcclxuICB0aGlzLm9yaWdpbmFsVGV4dCA9IHRydWVcclxufVxyXG5cclxuR2FtZU92ZXJQYW5lbC5SRVNUQVJUX0FOSU1fRFVSQVRJT04gPSA4NzVcclxuR2FtZU92ZXJQYW5lbC5MT0dPX1BBVVNFX0RVUkFUSU9OID0gODc1XHJcbkdhbWVPdmVyUGFuZWwuRkxBU0hfSVRFUkFUSU9OUyA9IDVcclxuXHJcbi8qKlxyXG4gKiBBbmltYXRpb24gZnJhbWVzIHNwZWMuXHJcbiAqL1xyXG5HYW1lT3ZlclBhbmVsLmFuaW1Db25maWcgPSB7XHJcbiAgZnJhbWVzOiBbMCwgMzYsIDcyLCAxMDgsIDE0NCwgMTgwLCAyMTYsIDI1Ml0sXHJcbiAgbXNQZXJGcmFtZTogR2FtZU92ZXJQYW5lbC5SRVNUQVJUX0FOSU1fRFVSQVRJT04gLyA4XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaW1lbnNpb25zIHVzZWQgaW4gdGhlIHBhbmVsLlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxuR2FtZU92ZXJQYW5lbC5kaW1lbnNpb25zID0ge1xyXG4gIFRFWFRfWDogMCxcclxuICBURVhUX1k6IDEzLFxyXG4gIFRFWFRfV0lEVEg6IDE5MSxcclxuICBURVhUX0hFSUdIVDogMTEsXHJcbiAgUkVTVEFSVF9XSURUSDogMzYsXHJcbiAgUkVTVEFSVF9IRUlHSFQ6IDMyXHJcbn1cclxuXHJcbkdhbWVPdmVyUGFuZWwucHJvdG90eXBlID0ge1xyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgcGFuZWwgZGltZW5zaW9ucy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggTmV3IGNhbnZhcyB3aWR0aC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0X2hlaWdodCBPcHRpb25hbCBuZXcgY2FudmFzIGhlaWdodC5cclxuICAgKi9cclxuICB1cGRhdGVEaW1lbnNpb25zICh3aWR0aCwgb3B0X2hlaWdodCkge1xyXG4gICAgdGhpcy5jYW52YXNEaW1lbnNpb25zLldJRFRIID0gd2lkdGhcclxuICAgIGlmIChvcHRfaGVpZ2h0KSB7XHJcbiAgICAgIHRoaXMuY2FudmFzRGltZW5zaW9ucy5IRUlHSFQgPSBvcHRfaGVpZ2h0XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IEdhbWVPdmVyUGFuZWwuYW5pbUNvbmZpZy5mcmFtZXMubGVuZ3RoIC0gMVxyXG4gIH0sXHJcblxyXG4gIGRyYXdHYW1lT3ZlclRleHQgKGRpbWVuc2lvbnMsIG9wdF91c2VBbHRUZXh0KSB7XHJcbiAgICBjb25zdCBjZW50ZXJYID0gdGhpcy5jYW52YXNEaW1lbnNpb25zLldJRFRIIC8gMlxyXG4gICAgbGV0IHRleHRTb3VyY2VYID0gZGltZW5zaW9ucy5URVhUX1hcclxuICAgIGxldCB0ZXh0U291cmNlWSA9IGRpbWVuc2lvbnMuVEVYVF9ZXHJcbiAgICBsZXQgdGV4dFNvdXJjZVdpZHRoID0gZGltZW5zaW9ucy5URVhUX1dJRFRIXHJcbiAgICBsZXQgdGV4dFNvdXJjZUhlaWdodCA9IGRpbWVuc2lvbnMuVEVYVF9IRUlHSFRcclxuXHJcbiAgICBjb25zdCB0ZXh0VGFyZ2V0WCA9IE1hdGgucm91bmQoY2VudGVyWCAtIChkaW1lbnNpb25zLlRFWFRfV0lEVEggLyAyKSlcclxuICAgIGNvbnN0IHRleHRUYXJnZXRZID0gTWF0aC5yb3VuZCgodGhpcy5jYW52YXNEaW1lbnNpb25zLkhFSUdIVCAtIDI1KSAvIDMpXHJcbiAgICBjb25zdCB0ZXh0VGFyZ2V0V2lkdGggPSBkaW1lbnNpb25zLlRFWFRfV0lEVEhcclxuICAgIGNvbnN0IHRleHRUYXJnZXRIZWlnaHQgPSBkaW1lbnNpb25zLlRFWFRfSEVJR0hUXHJcblxyXG4gICAgaWYgKElTX0hJRFBJKSB7XHJcbiAgICAgIHRleHRTb3VyY2VZICo9IDJcclxuICAgICAgdGV4dFNvdXJjZVggKj0gMlxyXG4gICAgICB0ZXh0U291cmNlV2lkdGggKj0gMlxyXG4gICAgICB0ZXh0U291cmNlSGVpZ2h0ICo9IDJcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW9wdF91c2VBbHRUZXh0KSB7XHJcbiAgICAgIHRleHRTb3VyY2VYICs9IHRoaXMudGV4dEltZ1Bvcy54XHJcbiAgICAgIHRleHRTb3VyY2VZICs9IHRoaXMudGV4dEltZ1Bvcy55XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3ByaXRlU291cmNlID1cclxuICAgICAgb3B0X3VzZUFsdFRleHQgPyBSdW5uZXIuYWx0Q29tbW9uSW1hZ2VTcHJpdGUgOiBSdW5uZXIub3JpZ0ltYWdlU3ByaXRlXHJcblxyXG4gICAgdGhpcy5jYW52YXNDdHguc2F2ZSgpXHJcblxyXG4gICAgaWYgKElTX1JUTCkge1xyXG4gICAgICB0aGlzLmNhbnZhc0N0eC50cmFuc2xhdGUodGhpcy5jYW52YXNEaW1lbnNpb25zLldJRFRILCAwKVxyXG4gICAgICB0aGlzLmNhbnZhc0N0eC5zY2FsZSgtMSwgMSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBHYW1lIG92ZXIgdGV4dCBmcm9tIHNwcml0ZS5cclxuICAgIHRoaXMuY2FudmFzQ3R4LmRyYXdJbWFnZShcclxuICAgICAgc3ByaXRlU291cmNlLCB0ZXh0U291cmNlWCwgdGV4dFNvdXJjZVksIHRleHRTb3VyY2VXaWR0aCxcclxuICAgICAgdGV4dFNvdXJjZUhlaWdodCwgdGV4dFRhcmdldFgsIHRleHRUYXJnZXRZLCB0ZXh0VGFyZ2V0V2lkdGgsXHJcbiAgICAgIHRleHRUYXJnZXRIZWlnaHQpXHJcblxyXG4gICAgdGhpcy5jYW52YXNDdHgucmVzdG9yZSgpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhdyBhZGRpdGlvbmFsIGFkb3JubWVudHMgZm9yIGFsdGVybmF0aXZlIGdhbWUgdHlwZXMuXHJcbiAgICovXHJcbiAgZHJhd0FsdEdhbWVFbGVtZW50cyAodFJleCkge1xyXG4gICAgLy8gQWRkaXRpb25hbCBhZG9ybm1lbnRzLlxyXG4gICAgaWYgKHRoaXMuYWx0R2FtZU1vZGVBY3RpdmUgJiYgUnVubmVyLnNwcml0ZURlZmluaXRpb24uQUxUX0dBTUVfRU5EX0NPTkZJRykge1xyXG4gICAgICBjb25zdCBhbHRHYW1lRW5kQ29uZmlnID0gUnVubmVyLnNwcml0ZURlZmluaXRpb24uQUxUX0dBTUVfRU5EX0NPTkZJR1xyXG5cclxuICAgICAgbGV0IGFsdEdhbWVFbmRTb3VyY2VXaWR0aCA9IGFsdEdhbWVFbmRDb25maWcuV0lEVEhcclxuICAgICAgbGV0IGFsdEdhbWVFbmRTb3VyY2VIZWlnaHQgPSBhbHRHYW1lRW5kQ29uZmlnLkhFSUdIVFxyXG4gICAgICBjb25zdCBhbHRHYW1lRW5kVGFyZ2V0WCA9IHRSZXgueFBvcyArIGFsdEdhbWVFbmRDb25maWcuWF9PRkZTRVRcclxuICAgICAgY29uc3QgYWx0R2FtZUVuZFRhcmdldFkgPSB0UmV4LnlQb3MgKyBhbHRHYW1lRW5kQ29uZmlnLllfT0ZGU0VUXHJcblxyXG4gICAgICBpZiAoSVNfSElEUEkpIHtcclxuICAgICAgICBhbHRHYW1lRW5kU291cmNlV2lkdGggKj0gMlxyXG4gICAgICAgIGFsdEdhbWVFbmRTb3VyY2VIZWlnaHQgKj0gMlxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNhbnZhc0N0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgUnVubmVyLmFsdENvbW1vbkltYWdlU3ByaXRlLCB0aGlzLmFsdEdhbWVFbmRJbWdQb3MueCxcclxuICAgICAgICB0aGlzLmFsdEdhbWVFbmRJbWdQb3MueSwgYWx0R2FtZUVuZFNvdXJjZVdpZHRoLFxyXG4gICAgICAgIGFsdEdhbWVFbmRTb3VyY2VIZWlnaHQsIGFsdEdhbWVFbmRUYXJnZXRYLCBhbHRHYW1lRW5kVGFyZ2V0WSxcclxuICAgICAgICBhbHRHYW1lRW5kQ29uZmlnLldJRFRILCBhbHRHYW1lRW5kQ29uZmlnLkhFSUdIVClcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEcmF3IHJlc3RhcnQgYnV0dG9uLlxyXG4gICAqL1xyXG4gIGRyYXdSZXN0YXJ0QnV0dG9uICgpIHtcclxuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBHYW1lT3ZlclBhbmVsLmRpbWVuc2lvbnNcclxuICAgIGxldCBmcmFtZVBvc1ggPSBHYW1lT3ZlclBhbmVsLmFuaW1Db25maWcuZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXVxyXG4gICAgbGV0IHJlc3RhcnRTb3VyY2VXaWR0aCA9IGRpbWVuc2lvbnMuUkVTVEFSVF9XSURUSFxyXG4gICAgbGV0IHJlc3RhcnRTb3VyY2VIZWlnaHQgPSBkaW1lbnNpb25zLlJFU1RBUlRfSEVJR0hUXHJcbiAgICBjb25zdCByZXN0YXJ0VGFyZ2V0WCA9XHJcbiAgICAgICh0aGlzLmNhbnZhc0RpbWVuc2lvbnMuV0lEVEggLyAyKSAtIChkaW1lbnNpb25zLlJFU1RBUlRfV0lEVEggLyAyKVxyXG4gICAgY29uc3QgcmVzdGFydFRhcmdldFkgPSB0aGlzLmNhbnZhc0RpbWVuc2lvbnMuSEVJR0hUIC8gMlxyXG5cclxuICAgIGlmIChJU19ISURQSSkge1xyXG4gICAgICByZXN0YXJ0U291cmNlV2lkdGggKj0gMlxyXG4gICAgICByZXN0YXJ0U291cmNlSGVpZ2h0ICo9IDJcclxuICAgICAgZnJhbWVQb3NYICo9IDJcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNhbnZhc0N0eC5zYXZlKClcclxuXHJcbiAgICBpZiAoSVNfUlRMKSB7XHJcbiAgICAgIHRoaXMuY2FudmFzQ3R4LnRyYW5zbGF0ZSh0aGlzLmNhbnZhc0RpbWVuc2lvbnMuV0lEVEgsIDApXHJcbiAgICAgIHRoaXMuY2FudmFzQ3R4LnNjYWxlKC0xLCAxKVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FudmFzQ3R4LmRyYXdJbWFnZShcclxuICAgICAgUnVubmVyLm9yaWdJbWFnZVNwcml0ZSwgdGhpcy5yZXN0YXJ0SW1nUG9zLnggKyBmcmFtZVBvc1gsXHJcbiAgICAgIHRoaXMucmVzdGFydEltZ1Bvcy55LCByZXN0YXJ0U291cmNlV2lkdGgsIHJlc3RhcnRTb3VyY2VIZWlnaHQsXHJcbiAgICAgIHJlc3RhcnRUYXJnZXRYLCByZXN0YXJ0VGFyZ2V0WSwgZGltZW5zaW9ucy5SRVNUQVJUX1dJRFRILFxyXG4gICAgICBkaW1lbnNpb25zLlJFU1RBUlRfSEVJR0hUKVxyXG4gICAgdGhpcy5jYW52YXNDdHgucmVzdG9yZSgpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhdyB0aGUgcGFuZWwuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRfYWx0R2FtZU1vZGVBY3RpdmVcclxuICAgKiBAcGFyYW0geyFUcmV4fSBvcHRfdFJleFxyXG4gICAqL1xyXG4gIGRyYXcgKG9wdF9hbHRHYW1lTW9kZUFjdGl2ZSwgb3B0X3RSZXgpIHtcclxuICAgIGlmIChvcHRfYWx0R2FtZU1vZGVBY3RpdmUpIHtcclxuICAgICAgdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSA9IG9wdF9hbHRHYW1lTW9kZUFjdGl2ZVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJhd0dhbWVPdmVyVGV4dChHYW1lT3ZlclBhbmVsLmRpbWVuc2lvbnMsIGZhbHNlKVxyXG4gICAgdGhpcy5kcmF3UmVzdGFydEJ1dHRvbigpXHJcbiAgICB0aGlzLmRyYXdBbHRHYW1lRWxlbWVudHMob3B0X3RSZXgpXHJcbiAgICB0aGlzLnVwZGF0ZSgpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuaW1hdGlvbiBmcmFtZXMuXHJcbiAgICovXHJcbiAgdXBkYXRlICgpIHtcclxuICAgIGNvbnN0IG5vdyA9IGdldFRpbWVTdGFtcCgpXHJcbiAgICBjb25zdCBkZWx0YVRpbWUgPSBub3cgLSAodGhpcy5mcmFtZVRpbWVTdGFtcCB8fCBub3cpXHJcblxyXG4gICAgdGhpcy5mcmFtZVRpbWVTdGFtcCA9IG5vd1xyXG4gICAgdGhpcy5hbmltVGltZXIgKz0gZGVsdGFUaW1lXHJcbiAgICB0aGlzLmZsYXNoVGltZXIgKz0gZGVsdGFUaW1lXHJcblxyXG4gICAgLy8gUmVzdGFydCBCdXR0b25cclxuICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSA9PSAwICYmXHJcbiAgICAgIHRoaXMuYW5pbVRpbWVyID4gR2FtZU92ZXJQYW5lbC5MT0dPX1BBVVNFX0RVUkFUSU9OKSB7XHJcbiAgICAgIHRoaXMuYW5pbVRpbWVyID0gMFxyXG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSsrXHJcbiAgICAgIHRoaXMuZHJhd1Jlc3RhcnRCdXR0b24oKVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPiAwICYmXHJcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lIDwgR2FtZU92ZXJQYW5lbC5hbmltQ29uZmlnLmZyYW1lcy5sZW5ndGgpIHtcclxuICAgICAgaWYgKHRoaXMuYW5pbVRpbWVyID49IEdhbWVPdmVyUGFuZWwuYW5pbUNvbmZpZy5tc1BlckZyYW1lKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUrK1xyXG4gICAgICAgIHRoaXMuZHJhd1Jlc3RhcnRCdXR0b24oKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAhdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSAmJlxyXG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9PSBHYW1lT3ZlclBhbmVsLmFuaW1Db25maWcuZnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLnJlc2V0KClcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2FtZSBvdmVyIHRleHRcclxuICAgIGlmICh0aGlzLmFsdEdhbWVNb2RlQWN0aXZlICYmXHJcbiAgICAgIFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uQnlUeXBlLm9yaWdpbmFsLkFMVF9HQU1FX09WRVJfVEVYVF9DT05GSUcpIHtcclxuICAgICAgY29uc3QgYWx0VGV4dENvbmZpZyA9XHJcbiAgICAgICAgUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGUub3JpZ2luYWwuQUxUX0dBTUVfT1ZFUl9URVhUX0NPTkZJR1xyXG5cclxuICAgICAgaWYgKHRoaXMuZmxhc2hDb3VudGVyIDwgR2FtZU92ZXJQYW5lbC5GTEFTSF9JVEVSQVRJT05TICYmXHJcbiAgICAgICAgdGhpcy5mbGFzaFRpbWVyID4gYWx0VGV4dENvbmZpZy5GTEFTSF9EVVJBVElPTikge1xyXG4gICAgICAgIHRoaXMuZmxhc2hUaW1lciA9IDBcclxuICAgICAgICB0aGlzLm9yaWdpbmFsVGV4dCA9ICF0aGlzLm9yaWdpbmFsVGV4dFxyXG5cclxuICAgICAgICB0aGlzLmNsZWFyR2FtZU92ZXJUZXh0Qm91bmRzKClcclxuICAgICAgICBpZiAodGhpcy5vcmlnaW5hbFRleHQpIHtcclxuICAgICAgICAgIHRoaXMuZHJhd0dhbWVPdmVyVGV4dChHYW1lT3ZlclBhbmVsLmRpbWVuc2lvbnMsIGZhbHNlKVxyXG4gICAgICAgICAgdGhpcy5mbGFzaENvdW50ZXIrK1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmRyYXdHYW1lT3ZlclRleHQoYWx0VGV4dENvbmZpZywgdHJ1ZSlcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mbGFzaENvdW50ZXIgPj0gR2FtZU92ZXJQYW5lbC5GTEFTSF9JVEVSQVRJT05TKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdhbWVPdmVyUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUuYmluZCh0aGlzKSlcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBnYW1lIG92ZXIgdGV4dC5cclxuICAgKi9cclxuICBjbGVhckdhbWVPdmVyVGV4dEJvdW5kcyAoKSB7XHJcbiAgICB0aGlzLmNhbnZhc0N0eC5zYXZlKClcclxuXHJcbiAgICB0aGlzLmNhbnZhc0N0eC5jbGVhclJlY3QoXHJcbiAgICAgIE1hdGgucm91bmQoXHJcbiAgICAgICAgdGhpcy5jYW52YXNEaW1lbnNpb25zLldJRFRIIC8gMiAtXHJcbiAgICAgICAgKEdhbWVPdmVyUGFuZWwuZGltZW5zaW9ucy5URVhUX1dJRFRIIC8gMikpLFxyXG4gICAgICBNYXRoLnJvdW5kKCh0aGlzLmNhbnZhc0RpbWVuc2lvbnMuSEVJR0hUIC0gMjUpIC8gMyksXHJcbiAgICAgIEdhbWVPdmVyUGFuZWwuZGltZW5zaW9ucy5URVhUX1dJRFRILFxyXG4gICAgICBHYW1lT3ZlclBhbmVsLmRpbWVuc2lvbnMuVEVYVF9IRUlHSFQgKyA0KVxyXG4gICAgdGhpcy5jYW52YXNDdHgucmVzdG9yZSgpXHJcbiAgfSxcclxuXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgaWYgKHRoaXMuZ2FtZU92ZXJSYWZJZCkge1xyXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVPdmVyUmFmSWQpXHJcbiAgICAgIHRoaXMuZ2FtZU92ZXJSYWZJZCA9IG51bGxcclxuICAgIH1cclxuICAgIHRoaXMuYW5pbVRpbWVyID0gMFxyXG4gICAgdGhpcy5mcmFtZVRpbWVTdGFtcCA9IDBcclxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMFxyXG4gICAgdGhpcy5mbGFzaFRpbWVyID0gMFxyXG4gICAgdGhpcy5mbGFzaENvdW50ZXIgPSAwXHJcbiAgICB0aGlzLm9yaWdpbmFsVGV4dCA9IHRydWVcclxuICB9XHJcbn1cclxuXHJcbi8vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGZvciBhIGNvbGxpc2lvbi5cclxuICogQHBhcmFtIHshT2JzdGFjbGV9IG9ic3RhY2xlXHJcbiAqIEBwYXJhbSB7IVRyZXh9IHRSZXggVC1yZXggb2JqZWN0LlxyXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRD19IG9wdF9jYW52YXNDdHggT3B0aW9uYWwgY2FudmFzIGNvbnRleHQgZm9yXHJcbiAqICAgIGRyYXdpbmcgY29sbGlzaW9uIGJveGVzLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxDb2xsaXNpb25Cb3g+fHVuZGVmaW5lZH1cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrRm9yQ29sbGlzaW9uIChvYnN0YWNsZSwgdFJleCwgb3B0X2NhbnZhc0N0eCkge1xyXG4gIGNvbnN0IG9ic3RhY2xlQm94WFBvcyA9IFJ1bm5lci5kZWZhdWx0RGltZW5zaW9ucy5XSURUSCArIG9ic3RhY2xlLnhQb3NcclxuXHJcbiAgLy8gQWRqdXN0bWVudHMgYXJlIG1hZGUgdG8gdGhlIGJvdW5kaW5nIGJveCBhcyB0aGVyZSBpcyBhIDEgcGl4ZWwgd2hpdGVcclxuICAvLyBib3JkZXIgYXJvdW5kIHRoZSB0LXJleCBhbmQgb2JzdGFjbGVzLlxyXG4gIGNvbnN0IHRSZXhCb3ggPSBuZXcgQ29sbGlzaW9uQm94KFxyXG4gICAgdFJleC54UG9zICsgMSxcclxuICAgIHRSZXgueVBvcyArIDEsXHJcbiAgICB0UmV4LmNvbmZpZy5XSURUSCAtIDIsXHJcbiAgICB0UmV4LmNvbmZpZy5IRUlHSFQgLSAyKVxyXG5cclxuICBjb25zdCBvYnN0YWNsZUJveCA9IG5ldyBDb2xsaXNpb25Cb3goXHJcbiAgICBvYnN0YWNsZS54UG9zICsgMSxcclxuICAgIG9ic3RhY2xlLnlQb3MgKyAxLFxyXG4gICAgb2JzdGFjbGUudHlwZUNvbmZpZy53aWR0aCAqIG9ic3RhY2xlLnNpemUgLSAyLFxyXG4gICAgb2JzdGFjbGUudHlwZUNvbmZpZy5oZWlnaHQgLSAyKVxyXG5cclxuICAvLyBEZWJ1ZyBvdXRlciBib3hcclxuICBpZiAob3B0X2NhbnZhc0N0eCkge1xyXG4gICAgZHJhd0NvbGxpc2lvbkJveGVzKG9wdF9jYW52YXNDdHgsIHRSZXhCb3gsIG9ic3RhY2xlQm94KVxyXG4gIH1cclxuXHJcbiAgLy8gU2ltcGxlIG91dGVyIGJvdW5kcyBjaGVjay5cclxuICBpZiAoYm94Q29tcGFyZSh0UmV4Qm94LCBvYnN0YWNsZUJveCkpIHtcclxuICAgIGNvbnN0IGNvbGxpc2lvbkJveGVzID0gb2JzdGFjbGUuY29sbGlzaW9uQm94ZXNcclxuICAgIGxldCB0UmV4Q29sbGlzaW9uQm94ZXMgPSBbXVxyXG5cclxuICAgIGlmIChSdW5uZXIuaXNBbHRHYW1lTW9kZUVuYWJsZWQoKSkge1xyXG4gICAgICB0UmV4Q29sbGlzaW9uQm94ZXMgPSBSdW5uZXIuc3ByaXRlRGVmaW5pdGlvbi5UUkVYLkNPTExJU0lPTl9CT1hFU1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdFJleENvbGxpc2lvbkJveGVzID0gdFJleC5kdWNraW5nXHJcbiAgICAgICAgPyBUcmV4LmNvbGxpc2lvbkJveGVzLkRVQ0tJTkdcclxuICAgICAgICA6IFRyZXguY29sbGlzaW9uQm94ZXMuUlVOTklOR1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGFpbGVkIGF4aXMgYWxpZ25lZCBib3ggY2hlY2suXHJcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRSZXhDb2xsaXNpb25Cb3hlcy5sZW5ndGg7IHQrKykge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxpc2lvbkJveGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBib3ggdG8gYWN0dWFsIHBvc2l0aW9ucy5cclxuICAgICAgICBjb25zdCBhZGpUcmV4Qm94ID1cclxuICAgICAgICAgIGNyZWF0ZUFkanVzdGVkQ29sbGlzaW9uQm94KHRSZXhDb2xsaXNpb25Cb3hlc1t0XSwgdFJleEJveClcclxuICAgICAgICBjb25zdCBhZGpPYnN0YWNsZUJveCA9XHJcbiAgICAgICAgICBjcmVhdGVBZGp1c3RlZENvbGxpc2lvbkJveChjb2xsaXNpb25Cb3hlc1tpXSwgb2JzdGFjbGVCb3gpXHJcbiAgICAgICAgY29uc3QgY3Jhc2hlZCA9IGJveENvbXBhcmUoYWRqVHJleEJveCwgYWRqT2JzdGFjbGVCb3gpXHJcblxyXG4gICAgICAgIC8vIERyYXcgYm94ZXMgZm9yIGRlYnVnLlxyXG4gICAgICAgIGlmIChvcHRfY2FudmFzQ3R4KSB7XHJcbiAgICAgICAgICBkcmF3Q29sbGlzaW9uQm94ZXMob3B0X2NhbnZhc0N0eCwgYWRqVHJleEJveCwgYWRqT2JzdGFjbGVCb3gpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3Jhc2hlZCkge1xyXG4gICAgICAgICAgcmV0dXJuIFthZGpUcmV4Qm94LCBhZGpPYnN0YWNsZUJveF1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGp1c3QgdGhlIGNvbGxpc2lvbiBib3guXHJcbiAqIEBwYXJhbSB7IUNvbGxpc2lvbkJveH0gYm94IFRoZSBvcmlnaW5hbCBib3guXHJcbiAqIEBwYXJhbSB7IUNvbGxpc2lvbkJveH0gYWRqdXN0bWVudCBBZGp1c3RtZW50IGJveC5cclxuICogQHJldHVybiB7Q29sbGlzaW9uQm94fSBUaGUgYWRqdXN0ZWQgY29sbGlzaW9uIGJveCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBZGp1c3RlZENvbGxpc2lvbkJveCAoYm94LCBhZGp1c3RtZW50KSB7XHJcbiAgcmV0dXJuIG5ldyBDb2xsaXNpb25Cb3goXHJcbiAgICBib3gueCArIGFkanVzdG1lbnQueCxcclxuICAgIGJveC55ICsgYWRqdXN0bWVudC55LFxyXG4gICAgYm94LndpZHRoLFxyXG4gICAgYm94LmhlaWdodClcclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXcgdGhlIGNvbGxpc2lvbiBib3hlcyBmb3IgZGVidWcuXHJcbiAqL1xyXG5mdW5jdGlvbiBkcmF3Q29sbGlzaW9uQm94ZXMgKGNhbnZhc0N0eCwgdFJleEJveCwgb2JzdGFjbGVCb3gpIHtcclxuICBjYW52YXNDdHguc2F2ZSgpXHJcbiAgY2FudmFzQ3R4LnN0cm9rZVN0eWxlID0gJyNmMDAnXHJcbiAgY2FudmFzQ3R4LnN0cm9rZVJlY3QodFJleEJveC54LCB0UmV4Qm94LnksIHRSZXhCb3gud2lkdGgsIHRSZXhCb3guaGVpZ2h0KVxyXG5cclxuICBjYW52YXNDdHguc3Ryb2tlU3R5bGUgPSAnIzBmMCdcclxuICBjYW52YXNDdHguc3Ryb2tlUmVjdChvYnN0YWNsZUJveC54LCBvYnN0YWNsZUJveC55LFxyXG4gICAgb2JzdGFjbGVCb3gud2lkdGgsIG9ic3RhY2xlQm94LmhlaWdodClcclxuICBjYW52YXNDdHgucmVzdG9yZSgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlIHR3byBjb2xsaXNpb24gYm94ZXMgZm9yIGEgY29sbGlzaW9uLlxyXG4gKiBAcGFyYW0ge0NvbGxpc2lvbkJveH0gdFJleEJveFxyXG4gKiBAcGFyYW0ge0NvbGxpc2lvbkJveH0gb2JzdGFjbGVCb3hcclxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYm94ZXMgaW50ZXJzZWN0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBib3hDb21wYXJlICh0UmV4Qm94LCBvYnN0YWNsZUJveCkge1xyXG4gIGxldCBjcmFzaGVkID0gZmFsc2VcclxuICBjb25zdCB0UmV4Qm94WCA9IHRSZXhCb3gueFxyXG4gIGNvbnN0IHRSZXhCb3hZID0gdFJleEJveC55XHJcblxyXG4gIGNvbnN0IG9ic3RhY2xlQm94WCA9IG9ic3RhY2xlQm94LnhcclxuICBjb25zdCBvYnN0YWNsZUJveFkgPSBvYnN0YWNsZUJveC55XHJcblxyXG4gIC8vIEF4aXMtQWxpZ25lZCBCb3VuZGluZyBCb3ggbWV0aG9kLlxyXG4gIGlmICh0UmV4Qm94LnggPCBvYnN0YWNsZUJveFggKyBvYnN0YWNsZUJveC53aWR0aCAmJlxyXG4gICAgdFJleEJveC54ICsgdFJleEJveC53aWR0aCA+IG9ic3RhY2xlQm94WCAmJlxyXG4gICAgdFJleEJveC55IDwgb2JzdGFjbGVCb3gueSArIG9ic3RhY2xlQm94LmhlaWdodCAmJlxyXG4gICAgdFJleEJveC5oZWlnaHQgKyB0UmV4Qm94LnkgPiBvYnN0YWNsZUJveC55KSB7XHJcbiAgICBjcmFzaGVkID0gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNyYXNoZWRcclxufVxyXG5cclxuLy8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4vKipcclxuICogQ29sbGlzaW9uIGJveCBvYmplY3QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFggcG9zaXRpb24uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgUG9zaXRpb24uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3IFdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaCBIZWlnaHQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIENvbGxpc2lvbkJveCAoeCwgeSwgdywgaCkge1xyXG4gIHRoaXMueCA9IHhcclxuICB0aGlzLnkgPSB5XHJcbiAgdGhpcy53aWR0aCA9IHdcclxuICB0aGlzLmhlaWdodCA9IGhcclxufVxyXG5cclxuLy8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4vKipcclxuICogT2JzdGFjbGUuXHJcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjYW52YXNDdHhcclxuICogQHBhcmFtIHtPYnN0YWNsZVR5cGV9IHR5cGVcclxuICogQHBhcmFtIHtPYmplY3R9IHNwcml0ZUltZ1BvcyBPYnN0YWNsZSBwb3NpdGlvbiBpbiBzcHJpdGUuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBnYXBDb2VmZmljaWVudCBNdXRpcGxlciBpbiBkZXRlcm1pbmluZyB0aGUgZ2FwLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3BlZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfeE9mZnNldFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNBbHRHYW1lTW9kZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE9ic3RhY2xlIChcclxuICBjYW52YXNDdHgsIHR5cGUsIHNwcml0ZUltZ1BvcywgZGltZW5zaW9ucywgZ2FwQ29lZmZpY2llbnQsIHNwZWVkLFxyXG4gIG9wdF94T2Zmc2V0LCBvcHRfaXNBbHRHYW1lTW9kZSkge1xyXG4gIHRoaXMuY2FudmFzQ3R4ID0gY2FudmFzQ3R4XHJcbiAgdGhpcy5zcHJpdGVQb3MgPSBzcHJpdGVJbWdQb3NcclxuICB0aGlzLnR5cGVDb25maWcgPSB0eXBlXHJcbiAgdGhpcy5nYXBDb2VmZmljaWVudCA9IFJ1bm5lci5zbG93RG93biA/IGdhcENvZWZmaWNpZW50ICogMiA6IGdhcENvZWZmaWNpZW50XHJcbiAgdGhpcy5zaXplID0gZ2V0UmFuZG9tTnVtKDEsIE9ic3RhY2xlLk1BWF9PQlNUQUNMRV9MRU5HVEgpXHJcbiAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9uc1xyXG4gIHRoaXMucmVtb3ZlID0gZmFsc2VcclxuICB0aGlzLnhQb3MgPSBkaW1lbnNpb25zLldJRFRIICsgKG9wdF94T2Zmc2V0IHx8IDApXHJcbiAgdGhpcy55UG9zID0gMFxyXG4gIHRoaXMud2lkdGggPSAwXHJcbiAgdGhpcy5jb2xsaXNpb25Cb3hlcyA9IFtdXHJcbiAgdGhpcy5nYXAgPSAwXHJcbiAgdGhpcy5zcGVlZE9mZnNldCA9IDBcclxuICB0aGlzLmFsdEdhbWVNb2RlQWN0aXZlID0gb3B0X2lzQWx0R2FtZU1vZGVcclxuICB0aGlzLmltYWdlU3ByaXRlID0gdGhpcy50eXBlQ29uZmlnLnR5cGUgPT0gJ0NPTExFQ1RBQkxFJ1xyXG4gICAgPyBSdW5uZXIuYWx0Q29tbW9uSW1hZ2VTcHJpdGVcclxuICAgIDogdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSA/IFJ1bm5lci5hbHRHYW1lSW1hZ2VTcHJpdGUgOiBSdW5uZXIuaW1hZ2VTcHJpdGVcclxuXHJcbiAgLy8gRm9yIGFuaW1hdGVkIG9ic3RhY2xlcy5cclxuICB0aGlzLmN1cnJlbnRGcmFtZSA9IDBcclxuICB0aGlzLnRpbWVyID0gMFxyXG5cclxuICB0aGlzLmluaXQoc3BlZWQpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb2VmZmljaWVudCBmb3IgY2FsY3VsYXRpbmcgdGhlIG1heGltdW0gZ2FwLlxyXG4gKi9cclxuT2JzdGFjbGUuTUFYX0dBUF9DT0VGRklDSUVOVCA9IDEuNVxyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gb2JzdGFjbGUgZ3JvdXBpbmcgY291bnQuXHJcbiAqL1xyXG5PYnN0YWNsZS5NQVhfT0JTVEFDTEVfTEVOR1RIID0gM1xyXG5cclxuT2JzdGFjbGUucHJvdG90eXBlID0ge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpc2UgdGhlIERPTSBmb3IgdGhlIG9ic3RhY2xlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxyXG4gICAqL1xyXG4gIGluaXQgKHNwZWVkKSB7XHJcbiAgICB0aGlzLmNsb25lQ29sbGlzaW9uQm94ZXMoKVxyXG5cclxuICAgIC8vIE9ubHkgYWxsb3cgc2l6aW5nIGlmIHdlJ3JlIGF0IHRoZSByaWdodCBzcGVlZC5cclxuICAgIGlmICh0aGlzLnNpemUgPiAxICYmIHRoaXMudHlwZUNvbmZpZy5tdWx0aXBsZVNwZWVkID4gc3BlZWQpIHtcclxuICAgICAgdGhpcy5zaXplID0gMVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMud2lkdGggPSB0aGlzLnR5cGVDb25maWcud2lkdGggKiB0aGlzLnNpemVcclxuXHJcbiAgICAvLyBDaGVjayBpZiBvYnN0YWNsZSBjYW4gYmUgcG9zaXRpb25lZCBhdCB2YXJpb3VzIGhlaWdodHMuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnR5cGVDb25maWcueVBvcykpIHtcclxuICAgICAgY29uc3QgeVBvc0NvbmZpZyA9XHJcbiAgICAgICAgSVNfTU9CSUxFID8gdGhpcy50eXBlQ29uZmlnLnlQb3NNb2JpbGUgOiB0aGlzLnR5cGVDb25maWcueVBvc1xyXG4gICAgICB0aGlzLnlQb3MgPSB5UG9zQ29uZmlnW2dldFJhbmRvbU51bSgwLCB5UG9zQ29uZmlnLmxlbmd0aCAtIDEpXVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy55UG9zID0gdGhpcy50eXBlQ29uZmlnLnlQb3NcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRyYXcoKVxyXG5cclxuICAgIC8vIE1ha2UgY29sbGlzaW9uIGJveCBhZGp1c3RtZW50cyxcclxuICAgIC8vIENlbnRyYWwgYm94IGlzIGFkanVzdGVkIHRvIHRoZSBzaXplIGFzIG9uZSBib3guXHJcbiAgICAvLyAgICAgIF9fX18gICAgICAgIF9fX19fXyAgICAgICAgX19fX19fX19cclxuICAgIC8vICAgIF98ICAgfC18ICAgIF98ICAgICB8LXwgICAgX3wgICAgICAgfC18XHJcbiAgICAvLyAgIHwgfDwtPnwgfCAgIHwgfDwtLS0+fCB8ICAgfCB8PC0tLS0tPnwgfFxyXG4gICAgLy8gICB8IHwgMSB8IHwgICB8IHwgIDIgIHwgfCAgIHwgfCAgIDMgICB8IHxcclxuICAgIC8vICAgfF98X19ffF98ICAgfF98X19fX198X3wgICB8X3xfX19fX19ffF98XHJcbiAgICAvL1xyXG4gICAgaWYgKHRoaXMuc2l6ZSA+IDEpIHtcclxuICAgICAgdGhpcy5jb2xsaXNpb25Cb3hlc1sxXS53aWR0aCA9IHRoaXMud2lkdGggLSB0aGlzLmNvbGxpc2lvbkJveGVzWzBdLndpZHRoIC1cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbkJveGVzWzJdLndpZHRoXHJcbiAgICAgIHRoaXMuY29sbGlzaW9uQm94ZXNbMl0ueCA9IHRoaXMud2lkdGggLSB0aGlzLmNvbGxpc2lvbkJveGVzWzJdLndpZHRoXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIG9ic3RhY2xlcyB0aGF0IGdvIGF0IGEgZGlmZmVyZW50IHNwZWVkIGZyb20gdGhlIGhvcml6b24uXHJcbiAgICBpZiAodGhpcy50eXBlQ29uZmlnLnNwZWVkT2Zmc2V0KSB7XHJcbiAgICAgIHRoaXMuc3BlZWRPZmZzZXQgPSBNYXRoLnJhbmRvbSgpID4gMC41XHJcbiAgICAgICAgPyB0aGlzLnR5cGVDb25maWcuc3BlZWRPZmZzZXRcclxuICAgICAgICA6IC10aGlzLnR5cGVDb25maWcuc3BlZWRPZmZzZXRcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdhcCA9IHRoaXMuZ2V0R2FwKHRoaXMuZ2FwQ29lZmZpY2llbnQsIHNwZWVkKVxyXG5cclxuICAgIC8vIEluY3JlYXNlIGdhcCBmb3IgYXVkaW8gY3VlcyBlbmFibGVkLlxyXG4gICAgaWYgKFJ1bm5lci5hdWRpb0N1ZXMpIHtcclxuICAgICAgdGhpcy5nYXAgKj0gMlxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXcgYW5kIGNyb3AgYmFzZWQgb24gc2l6ZS5cclxuICAgKi9cclxuICBkcmF3ICgpIHtcclxuICAgIGxldCBzb3VyY2VXaWR0aCA9IHRoaXMudHlwZUNvbmZpZy53aWR0aFxyXG4gICAgbGV0IHNvdXJjZUhlaWdodCA9IHRoaXMudHlwZUNvbmZpZy5oZWlnaHRcclxuXHJcbiAgICBpZiAoSVNfSElEUEkpIHtcclxuICAgICAgc291cmNlV2lkdGggPSBzb3VyY2VXaWR0aCAqIDJcclxuICAgICAgc291cmNlSGVpZ2h0ID0gc291cmNlSGVpZ2h0ICogMlxyXG4gICAgfVxyXG5cclxuICAgIC8vIFggcG9zaXRpb24gaW4gc3ByaXRlLlxyXG4gICAgbGV0IHNvdXJjZVggPVxyXG4gICAgICAoc291cmNlV2lkdGggKiB0aGlzLnNpemUpICogKDAuNSAqICh0aGlzLnNpemUgLSAxKSkgKyB0aGlzLnNwcml0ZVBvcy54XHJcblxyXG4gICAgLy8gQW5pbWF0aW9uIGZyYW1lcy5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSA+IDApIHtcclxuICAgICAgc291cmNlWCArPSBzb3VyY2VXaWR0aCAqIHRoaXMuY3VycmVudEZyYW1lXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYW52YXNDdHguZHJhd0ltYWdlKFxyXG4gICAgICB0aGlzLmltYWdlU3ByaXRlLCBzb3VyY2VYLCB0aGlzLnNwcml0ZVBvcy55LCBzb3VyY2VXaWR0aCAqIHRoaXMuc2l6ZSxcclxuICAgICAgc291cmNlSGVpZ2h0LCB0aGlzLnhQb3MsIHRoaXMueVBvcywgdGhpcy50eXBlQ29uZmlnLndpZHRoICogdGhpcy5zaXplLFxyXG4gICAgICB0aGlzLnR5cGVDb25maWcuaGVpZ2h0KVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIE9ic3RhY2xlIGZyYW1lIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXHJcbiAgICovXHJcbiAgdXBkYXRlIChkZWx0YVRpbWUsIHNwZWVkKSB7XHJcbiAgICBpZiAoIXRoaXMucmVtb3ZlKSB7XHJcbiAgICAgIGlmICh0aGlzLnR5cGVDb25maWcuc3BlZWRPZmZzZXQpIHtcclxuICAgICAgICBzcGVlZCArPSB0aGlzLnNwZWVkT2Zmc2V0XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy54UG9zIC09IE1hdGguZmxvb3IoKHNwZWVkICogRlBTIC8gMTAwMCkgKiBkZWx0YVRpbWUpXHJcblxyXG4gICAgICAvLyBVcGRhdGUgZnJhbWVcclxuICAgICAgaWYgKHRoaXMudHlwZUNvbmZpZy5udW1GcmFtZXMpIHtcclxuICAgICAgICB0aGlzLnRpbWVyICs9IGRlbHRhVGltZVxyXG4gICAgICAgIGlmICh0aGlzLnRpbWVyID49IHRoaXMudHlwZUNvbmZpZy5mcmFtZVJhdGUpIHtcclxuICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID1cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPT09IHRoaXMudHlwZUNvbmZpZy5udW1GcmFtZXMgLSAxXHJcbiAgICAgICAgICAgICAgPyAwXHJcbiAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRGcmFtZSArIDFcclxuICAgICAgICAgIHRoaXMudGltZXIgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZHJhdygpXHJcblxyXG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZSA9IHRydWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBhIHJhbmRvbSBnYXAgc2l6ZS5cclxuICAgKiAtIE1pbmltdW0gZ2FwIGdldHMgd2lkZXIgYXMgc3BlZWQgaW5jcmVzZXNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwQ29lZmZpY2llbnRcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWRcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBnYXAgc2l6ZS5cclxuICAgKi9cclxuICBnZXRHYXAgKGdhcENvZWZmaWNpZW50LCBzcGVlZCkge1xyXG4gICAgY29uc3QgbWluR2FwID0gTWF0aC5yb3VuZChcclxuICAgICAgdGhpcy53aWR0aCAqIHNwZWVkICsgdGhpcy50eXBlQ29uZmlnLm1pbkdhcCAqIGdhcENvZWZmaWNpZW50KVxyXG4gICAgY29uc3QgbWF4R2FwID0gTWF0aC5yb3VuZChtaW5HYXAgKiBPYnN0YWNsZS5NQVhfR0FQX0NPRUZGSUNJRU5UKVxyXG4gICAgcmV0dXJuIGdldFJhbmRvbU51bShtaW5HYXAsIG1heEdhcClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBvYnN0YWNsZSBpcyB2aXNpYmxlLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG9ic3RhY2xlIGlzIGluIHRoZSBnYW1lIGFyZWEuXHJcbiAgICovXHJcbiAgaXNWaXNpYmxlICgpIHtcclxuICAgIHJldHVybiB0aGlzLnhQb3MgKyB0aGlzLndpZHRoID4gMFxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIE1ha2UgYSBjb3B5IG9mIHRoZSBjb2xsaXNpb24gYm94ZXMsIHNpbmNlIHRoZXNlIHdpbGwgY2hhbmdlIGJhc2VkIG9uXHJcbiAgICogb2JzdGFjbGUgdHlwZSBhbmQgc2l6ZS5cclxuICAgKi9cclxuICBjbG9uZUNvbGxpc2lvbkJveGVzICgpIHtcclxuICAgIGNvbnN0IGNvbGxpc2lvbkJveGVzID0gdGhpcy50eXBlQ29uZmlnLmNvbGxpc2lvbkJveGVzXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IGNvbGxpc2lvbkJveGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIHRoaXMuY29sbGlzaW9uQm94ZXNbaV0gPSBuZXcgQ29sbGlzaW9uQm94KFxyXG4gICAgICAgIGNvbGxpc2lvbkJveGVzW2ldLngsIGNvbGxpc2lvbkJveGVzW2ldLnksIGNvbGxpc2lvbkJveGVzW2ldLndpZHRoLFxyXG4gICAgICAgIGNvbGxpc2lvbkJveGVzW2ldLmhlaWdodClcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vKipcclxuICogVC1yZXggZ2FtZSBjaGFyYWN0ZXIuXHJcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gc3ByaXRlUG9zIFBvc2l0aW9uaW5nIHdpdGhpbiBpbWFnZSBzcHJpdGUuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gVHJleCAoY2FudmFzLCBzcHJpdGVQb3MpIHtcclxuICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xyXG4gIHRoaXMuY2FudmFzQ3R4ID1cclxuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoY2FudmFzLmdldENvbnRleHQoJzJkJykpXHJcbiAgdGhpcy5zcHJpdGVQb3MgPSBzcHJpdGVQb3NcclxuICB0aGlzLnhQb3MgPSAwXHJcbiAgdGhpcy55UG9zID0gMFxyXG4gIHRoaXMueEluaXRpYWxQb3MgPSAwXHJcbiAgLy8gUG9zaXRpb24gd2hlbiBvbiB0aGUgZ3JvdW5kLlxyXG4gIHRoaXMuZ3JvdW5kWVBvcyA9IDBcclxuICB0aGlzLmN1cnJlbnRGcmFtZSA9IDBcclxuICB0aGlzLmN1cnJlbnRBbmltRnJhbWVzID0gW11cclxuICB0aGlzLmJsaW5rRGVsYXkgPSAwXHJcbiAgdGhpcy5ibGlua0NvdW50ID0gMFxyXG4gIHRoaXMuYW5pbVN0YXJ0VGltZSA9IDBcclxuICB0aGlzLnRpbWVyID0gMFxyXG4gIHRoaXMubXNQZXJGcmFtZSA9IDEwMDAgLyBGUFNcclxuICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oVHJleC5jb25maWcsIFRyZXgubm9ybWFsSnVtcENvbmZpZylcclxuICAvLyBDdXJyZW50IHN0YXR1cy5cclxuICB0aGlzLnN0YXR1cyA9IFRyZXguc3RhdHVzLldBSVRJTkdcclxuICB0aGlzLmp1bXBpbmcgPSBmYWxzZVxyXG4gIHRoaXMuZHVja2luZyA9IGZhbHNlXHJcbiAgdGhpcy5qdW1wVmVsb2NpdHkgPSAwXHJcbiAgdGhpcy5yZWFjaGVkTWluSGVpZ2h0ID0gZmFsc2VcclxuICB0aGlzLnNwZWVkRHJvcCA9IGZhbHNlXHJcbiAgdGhpcy5qdW1wQ291bnQgPSAwXHJcbiAgdGhpcy5qdW1wc3BvdFggPSAwXHJcbiAgdGhpcy5hbHRHYW1lTW9kZUVuYWJsZWQgPSBmYWxzZVxyXG4gIHRoaXMuZmxhc2hpbmcgPSBmYWxzZVxyXG5cclxuICB0aGlzLmluaXQoKVxyXG59XHJcblxyXG4vKipcclxuICogVC1yZXggcGxheWVyIGNvbmZpZy5cclxuICovXHJcblRyZXguY29uZmlnID0ge1xyXG4gIERST1BfVkVMT0NJVFk6IC01LFxyXG4gIEZMQVNIX09GRjogMTc1LFxyXG4gIEZMQVNIX09OOiAxMDAsXHJcbiAgSEVJR0hUOiA0NyxcclxuICBIRUlHSFRfRFVDSzogMjUsXHJcbiAgSU5UUk9fRFVSQVRJT046IDE1MDAsXHJcbiAgU1BFRURfRFJPUF9DT0VGRklDSUVOVDogMyxcclxuICBTUFJJVEVfV0lEVEg6IDI2MixcclxuICBTVEFSVF9YX1BPUzogNTAsXHJcbiAgV0lEVEg6IDQ0LFxyXG4gIFdJRFRIX0RVQ0s6IDU5XHJcbn1cclxuXHJcblRyZXguc2xvd0p1bXBDb25maWcgPSB7XHJcbiAgR1JBVklUWTogMC4yNSxcclxuICBNQVhfSlVNUF9IRUlHSFQ6IDUwLFxyXG4gIE1JTl9KVU1QX0hFSUdIVDogNDUsXHJcbiAgSU5JVElBTF9KVU1QX1ZFTE9DSVRZOiAtMjBcclxufVxyXG5cclxuVHJleC5ub3JtYWxKdW1wQ29uZmlnID0ge1xyXG4gIEdSQVZJVFk6IDAuNixcclxuICBNQVhfSlVNUF9IRUlHSFQ6IDMwLFxyXG4gIE1JTl9KVU1QX0hFSUdIVDogMzAsXHJcbiAgSU5JVElBTF9KVU1QX1ZFTE9DSVRZOiAtMTBcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWQgaW4gY29sbGlzaW9uIGRldGVjdGlvbi5cclxuICogQGVudW0ge0FycmF5PENvbGxpc2lvbkJveD59XHJcbiAqL1xyXG5UcmV4LmNvbGxpc2lvbkJveGVzID0ge1xyXG4gIERVQ0tJTkc6IFtuZXcgQ29sbGlzaW9uQm94KDEsIDE4LCA1NSwgMjUpXSxcclxuICBSVU5OSU5HOiBbXHJcbiAgICBuZXcgQ29sbGlzaW9uQm94KDIyLCAwLCAxNywgMTYpLFxyXG4gICAgbmV3IENvbGxpc2lvbkJveCgxLCAxOCwgMzAsIDkpLFxyXG4gICAgbmV3IENvbGxpc2lvbkJveCgxMCwgMzUsIDE0LCA4KSxcclxuICAgIG5ldyBDb2xsaXNpb25Cb3goMSwgMjQsIDI5LCA1KSxcclxuICAgIG5ldyBDb2xsaXNpb25Cb3goNSwgMzAsIDIxLCA0KSxcclxuICAgIG5ldyBDb2xsaXNpb25Cb3goOSwgMzQsIDE1LCA0KVxyXG4gIF1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuaW1hdGlvbiBzdGF0ZXMuXHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5UcmV4LnN0YXR1cyA9IHtcclxuICBDUkFTSEVEOiAnQ1JBU0hFRCcsXHJcbiAgRFVDS0lORzogJ0RVQ0tJTkcnLFxyXG4gIEpVTVBJTkc6ICdKVU1QSU5HJyxcclxuICBSVU5OSU5HOiAnUlVOTklORycsXHJcbiAgV0FJVElORzogJ1dBSVRJTkcnXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCbGlua2luZyBjb2VmZmljaWVudC5cclxuICogQGNvbnN0XHJcbiAqL1xyXG5UcmV4LkJMSU5LX1RJTUlORyA9IDcwMDBcclxuXHJcbi8qKlxyXG4gKiBBbmltYXRpb24gY29uZmlnIGZvciBkaWZmZXJlbnQgc3RhdGVzLlxyXG4gKiBAZW51bSB7T2JqZWN0fVxyXG4gKi9cclxuVHJleC5hbmltRnJhbWVzID0ge1xyXG4gIFdBSVRJTkc6IHtcclxuICAgIGZyYW1lczogWzQ0LCAwXSxcclxuICAgIG1zUGVyRnJhbWU6IDEwMDAgLyAzXHJcbiAgfSxcclxuICBSVU5OSU5HOiB7XHJcbiAgICBmcmFtZXM6IFs4OCwgMTMyXSxcclxuICAgIG1zUGVyRnJhbWU6IDEwMDAgLyAxMlxyXG4gIH0sXHJcbiAgQ1JBU0hFRDoge1xyXG4gICAgZnJhbWVzOiBbMjIwXSxcclxuICAgIG1zUGVyRnJhbWU6IDEwMDAgLyA2MFxyXG4gIH0sXHJcbiAgSlVNUElORzoge1xyXG4gICAgZnJhbWVzOiBbMF0sXHJcbiAgICBtc1BlckZyYW1lOiAxMDAwIC8gNjBcclxuICB9LFxyXG4gIERVQ0tJTkc6IHtcclxuICAgIGZyYW1lczogWzI2NCwgMzIzXSxcclxuICAgIG1zUGVyRnJhbWU6IDEwMDAgLyA4XHJcbiAgfVxyXG59XHJcblxyXG5UcmV4LnByb3RvdHlwZSA9IHtcclxuICAvKipcclxuICAgKiBULXJleCBwbGF5ZXIgaW5pdGFsaXNlci5cclxuICAgKiBTZXRzIHRoZSB0LXJleCB0byBibGluayBhdCByYW5kb20gaW50ZXJ2YWxzLlxyXG4gICAqL1xyXG4gIGluaXQgKCkge1xyXG4gICAgdGhpcy5ncm91bmRZUG9zID0gUnVubmVyLmRlZmF1bHREaW1lbnNpb25zLkhFSUdIVCAtIHRoaXMuY29uZmlnLkhFSUdIVCAtXHJcbiAgICAgIFJ1bm5lci5jb25maWcuQk9UVE9NX1BBRFxyXG4gICAgdGhpcy55UG9zID0gdGhpcy5ncm91bmRZUG9zXHJcbiAgICB0aGlzLm1pbkp1bXBIZWlnaHQgPSB0aGlzLmdyb3VuZFlQb3MgLSB0aGlzLmNvbmZpZy5NSU5fSlVNUF9IRUlHSFRcclxuXHJcbiAgICB0aGlzLmRyYXcoMCwgMClcclxuICAgIHRoaXMudXBkYXRlKDAsIFRyZXguc3RhdHVzLldBSVRJTkcpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQXNzaWduIHRoZSBhcHByb3ByaWF0ZSBqdW1wIHBhcmFtZXRlcnMgYmFzZWQgb24gdGhlIGdhbWUgc3BlZWQuXHJcbiAgICovXHJcbiAgZW5hYmxlU2xvd0NvbmZpZzogZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QganVtcENvbmZpZyA9XHJcbiAgICAgIFJ1bm5lci5zbG93RG93biA/IFRyZXguc2xvd0p1bXBDb25maWcgOiBUcmV4Lm5vcm1hbEp1bXBDb25maWdcclxuICAgIFRyZXguY29uZmlnID0gT2JqZWN0LmFzc2lnbihUcmV4LmNvbmZpZywganVtcENvbmZpZylcclxuXHJcbiAgICB0aGlzLmFkanVzdEFsdEdhbWVDb25maWdGb3JTbG93U3BlZWQoKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEVuYWJsZXMgdGhlIGFsdGVybmF0aXZlIGdhbWUuIFJlZGVmaW5lcyB0aGUgZGlubyBjb25maWcuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNwcml0ZVBvcyBOZXcgcG9zaXRpb25pbmcgd2l0aGluIGltYWdlIHNwcml0ZS5cclxuICAgKi9cclxuICBlbmFibGVBbHRHYW1lTW9kZTogZnVuY3Rpb24gKHNwcml0ZVBvcykge1xyXG4gICAgdGhpcy5hbHRHYW1lTW9kZUVuYWJsZWQgPSB0cnVlXHJcbiAgICB0aGlzLnNwcml0ZVBvcyA9IHNwcml0ZVBvc1xyXG4gICAgY29uc3Qgc3ByaXRlRGVmaW5pdGlvbiA9IFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLlRSRVhcclxuXHJcbiAgICAvLyBVcGRhdGUgYW5pbWF0aW9uIGZyYW1lcy5cclxuICAgIFRyZXguYW5pbUZyYW1lcy5SVU5OSU5HLmZyYW1lcyA9XHJcbiAgICAgIFtzcHJpdGVEZWZpbml0aW9uLlJVTk5JTkdfMS54LCBzcHJpdGVEZWZpbml0aW9uLlJVTk5JTkdfMi54XVxyXG4gICAgVHJleC5hbmltRnJhbWVzLkNSQVNIRUQuZnJhbWVzID0gW3Nwcml0ZURlZmluaXRpb24uQ1JBU0hFRC54XVxyXG5cclxuICAgIGlmICh0eXBlb2Ygc3ByaXRlRGVmaW5pdGlvbi5KVU1QSU5HLnggPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIFRyZXguYW5pbUZyYW1lcy5KVU1QSU5HLmZyYW1lcyA9IHNwcml0ZURlZmluaXRpb24uSlVNUElORy54XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBUcmV4LmFuaW1GcmFtZXMuSlVNUElORy5mcmFtZXMgPSBbc3ByaXRlRGVmaW5pdGlvbi5KVU1QSU5HLnhdXHJcbiAgICB9XHJcblxyXG4gICAgVHJleC5hbmltRnJhbWVzLkRVQ0tJTkcuZnJhbWVzID1cclxuICAgICAgW3Nwcml0ZURlZmluaXRpb24uUlVOTklOR18xLngsIHNwcml0ZURlZmluaXRpb24uUlVOTklOR18yLnhdXHJcblxyXG4gICAgLy8gVXBkYXRlIFRyZXggY29uZmlnXHJcbiAgICBUcmV4LmNvbmZpZy5HUkFWSVRZID0gc3ByaXRlRGVmaW5pdGlvbi5HUkFWSVRZIHx8IFRyZXguY29uZmlnLkdSQVZJVFlcclxuICAgIFRyZXguY29uZmlnLkhFSUdIVCA9IHNwcml0ZURlZmluaXRpb24uUlVOTklOR18xLmgsXHJcbiAgICBUcmV4LmNvbmZpZy5JTklUSUFMX0pVTVBfVkVMT0NJVFkgPSBzcHJpdGVEZWZpbml0aW9uLklOSVRJQUxfSlVNUF9WRUxPQ0lUWVxyXG4gICAgVHJleC5jb25maWcuTUFYX0pVTVBfSEVJR0hUID0gc3ByaXRlRGVmaW5pdGlvbi5NQVhfSlVNUF9IRUlHSFRcclxuICAgIFRyZXguY29uZmlnLk1JTl9KVU1QX0hFSUdIVCA9IHNwcml0ZURlZmluaXRpb24uTUlOX0pVTVBfSEVJR0hUXHJcbiAgICBUcmV4LmNvbmZpZy5XSURUSCA9IHNwcml0ZURlZmluaXRpb24uUlVOTklOR18xLndcclxuICAgIFRyZXguY29uZmlnLldJRFRIX0pVTVAgPSBzcHJpdGVEZWZpbml0aW9uLkpVTVBJTkcud1xyXG4gICAgVHJleC5jb25maWcuSU5WRVJUX0pVTVAgPSBzcHJpdGVEZWZpbml0aW9uLklOVkVSVF9KVU1QXHJcblxyXG4gICAgdGhpcy5hZGp1c3RBbHRHYW1lQ29uZmlnRm9yU2xvd1NwZWVkKHNwcml0ZURlZmluaXRpb24uR1JBVklUWSlcclxuICAgIHRoaXMuY29uZmlnID0gVHJleC5jb25maWdcclxuXHJcbiAgICAvLyBBZGp1c3QgYm90dG9tIGhvcml6b24gcGxhY2VtZW50LlxyXG4gICAgdGhpcy5ncm91bmRZUG9zID0gUnVubmVyLmRlZmF1bHREaW1lbnNpb25zLkhFSUdIVCAtIHRoaXMuY29uZmlnLkhFSUdIVCAtXHJcbiAgICAgIFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLkJPVFRPTV9QQURcclxuICAgIHRoaXMueVBvcyA9IHRoaXMuZ3JvdW5kWVBvc1xyXG4gICAgdGhpcy5yZXNldCgpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2xvdyBzcGVlZHMgYWRqdXN0bWVudHMgZm9yIHRoZSBhbHQgZ2FtZSBtb2Rlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9ncmF2aXR5VmFsdWVcclxuICAgKi9cclxuICBhZGp1c3RBbHRHYW1lQ29uZmlnRm9yU2xvd1NwZWVkOiBmdW5jdGlvbiAob3B0X2dyYXZpdHlWYWx1ZSkge1xyXG4gICAgaWYgKFJ1bm5lci5zbG93RG93bikge1xyXG4gICAgICBpZiAob3B0X2dyYXZpdHlWYWx1ZSkge1xyXG4gICAgICAgIFRyZXguY29uZmlnLkdSQVZJVFkgPSBvcHRfZ3Jhdml0eVZhbHVlIC8gMS41XHJcbiAgICAgIH1cclxuICAgICAgVHJleC5jb25maWcuTUlOX0pVTVBfSEVJR0hUICo9IDEuNVxyXG4gICAgICBUcmV4LmNvbmZpZy5NQVhfSlVNUF9IRUlHSFQgKj0gMS41XHJcbiAgICAgIFRyZXguY29uZmlnLklOSVRJQUxfSlVNUF9WRUxPQ0lUWSA9XHJcbiAgICAgICAgVHJleC5jb25maWcuSU5JVElBTF9KVU1QX1ZFTE9DSVRZICogMS41XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIHdoZXRoZXIgZGlubyBpcyBmbGFzaGluZy5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXR1c1xyXG4gICAqL1xyXG4gIHNldEZsYXNoaW5nOiBmdW5jdGlvbiAoc3RhdHVzKSB7XHJcbiAgICB0aGlzLmZsYXNoaW5nID0gc3RhdHVzXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciB0aGUganVtcCB2ZWxvY2l0eS5cclxuICAgKiBUaGUgYXBwcm9yaWF0ZSBkcm9wIHZlbG9jaXR5IGlzIGFsc28gc2V0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZXR0aW5nXHJcbiAgICovXHJcbiAgc2V0SnVtcFZlbG9jaXR5IChzZXR0aW5nKSB7XHJcbiAgICB0aGlzLmNvbmZpZy5JTklUSUFMX0pVTVBfVkVMT0NJVFkgPSAtc2V0dGluZ1xyXG4gICAgdGhpcy5jb25maWcuRFJPUF9WRUxPQ0lUWSA9IC1zZXR0aW5nIC8gMlxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgYW5pbWF0aW9uIHN0YXR1cy5cclxuICAgKiBAcGFyYW0geyFudW1iZXJ9IGRlbHRhVGltZVxyXG4gICAqIEBwYXJhbSB7VHJleC5zdGF0dXM9fSBvcHRfc3RhdHVzIE9wdGlvbmFsIHN0YXR1cyB0byBzd2l0Y2ggdG8uXHJcbiAgICovXHJcbiAgdXBkYXRlIChkZWx0YVRpbWUsIG9wdF9zdGF0dXMpIHtcclxuICAgIHRoaXMudGltZXIgKz0gZGVsdGFUaW1lXHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBzdGF0dXMuXHJcbiAgICBpZiAob3B0X3N0YXR1cykge1xyXG4gICAgICB0aGlzLnN0YXR1cyA9IG9wdF9zdGF0dXNcclxuICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwXHJcbiAgICAgIHRoaXMubXNQZXJGcmFtZSA9IFRyZXguYW5pbUZyYW1lc1tvcHRfc3RhdHVzXS5tc1BlckZyYW1lXHJcbiAgICAgIHRoaXMuY3VycmVudEFuaW1GcmFtZXMgPSBUcmV4LmFuaW1GcmFtZXNbb3B0X3N0YXR1c10uZnJhbWVzXHJcblxyXG4gICAgICBpZiAob3B0X3N0YXR1cyA9PT0gVHJleC5zdGF0dXMuV0FJVElORykge1xyXG4gICAgICAgIHRoaXMuYW5pbVN0YXJ0VGltZSA9IGdldFRpbWVTdGFtcCgpXHJcbiAgICAgICAgdGhpcy5zZXRCbGlua0RlbGF5KClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gR2FtZSBpbnRybyBhbmltYXRpb24sIFQtcmV4IG1vdmVzIGluIGZyb20gdGhlIGxlZnQuXHJcbiAgICBpZiAodGhpcy5wbGF5aW5nSW50cm8gJiYgdGhpcy54UG9zIDwgdGhpcy5jb25maWcuU1RBUlRfWF9QT1MpIHtcclxuICAgICAgdGhpcy54UG9zICs9IE1hdGgucm91bmQoKHRoaXMuY29uZmlnLlNUQVJUX1hfUE9TIC9cclxuICAgICAgICB0aGlzLmNvbmZpZy5JTlRST19EVVJBVElPTikgKiBkZWx0YVRpbWUpXHJcbiAgICAgIHRoaXMueEluaXRpYWxQb3MgPSB0aGlzLnhQb3NcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IFRyZXguc3RhdHVzLldBSVRJTkcpIHtcclxuICAgICAgdGhpcy5ibGluayhnZXRUaW1lU3RhbXAoKSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZHJhdyh0aGlzLmN1cnJlbnRBbmltRnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXSwgMClcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGZyYW1lIHBvc2l0aW9uLlxyXG4gICAgaWYgKCF0aGlzLmZsYXNoaW5nICYmIHRoaXMudGltZXIgPj0gdGhpcy5tc1BlckZyYW1lKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWUgPT1cclxuICAgICAgdGhpcy5jdXJyZW50QW5pbUZyYW1lcy5sZW5ndGggLSAxXHJcbiAgICAgICAgPyAwXHJcbiAgICAgICAgOiB0aGlzLmN1cnJlbnRGcmFtZSArIDFcclxuICAgICAgdGhpcy50aW1lciA9IDBcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuYWx0R2FtZU1vZGVFbmFibGVkKSB7XHJcbiAgICAgIC8vIFNwZWVkIGRyb3AgYmVjb21lcyBkdWNrIGlmIHRoZSBkb3duIGtleSBpcyBzdGlsbCBiZWluZyBwcmVzc2VkLlxyXG4gICAgICBpZiAodGhpcy5zcGVlZERyb3AgJiYgdGhpcy55UG9zID09PSB0aGlzLmdyb3VuZFlQb3MpIHtcclxuICAgICAgICB0aGlzLnNwZWVkRHJvcCA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5zZXREdWNrKHRydWUpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEcmF3IHRoZSB0LXJleCB0byBhIHBhcnRpY3VsYXIgcG9zaXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAqL1xyXG4gIGRyYXcgKHgsIHkpIHtcclxuICAgIGxldCBzb3VyY2VYID0geFxyXG4gICAgbGV0IHNvdXJjZVkgPSB5XHJcbiAgICBsZXQgc291cmNlV2lkdGggPSB0aGlzLmR1Y2tpbmcgJiYgdGhpcy5zdGF0dXMgIT09IFRyZXguc3RhdHVzLkNSQVNIRURcclxuICAgICAgPyB0aGlzLmNvbmZpZy5XSURUSF9EVUNLXHJcbiAgICAgIDogdGhpcy5jb25maWcuV0lEVEhcclxuICAgIGxldCBzb3VyY2VIZWlnaHQgPSB0aGlzLmNvbmZpZy5IRUlHSFRcclxuICAgIGNvbnN0IG91dHB1dEhlaWdodCA9IHNvdXJjZUhlaWdodFxyXG5cclxuICAgIGxldCBqdW1wT2Zmc2V0ID0gUnVubmVyLnNwcml0ZURlZmluaXRpb24uVFJFWC5KVU1QSU5HLnhPZmZzZXRcclxuXHJcbiAgICAvLyBXaWR0aCBvZiBzcHJpdGUgY2hhbmdlcyBvbiBqdW1wLlxyXG4gICAgaWYgKHRoaXMuYWx0R2FtZU1vZGVFbmFibGVkICYmIHRoaXMuanVtcGluZyAmJlxyXG4gICAgICB0aGlzLnN0YXR1cyAhPT0gVHJleC5zdGF0dXMuQ1JBU0hFRCkge1xyXG4gICAgICBzb3VyY2VXaWR0aCA9IHRoaXMuY29uZmlnLldJRFRIX0pVTVBcclxuICAgIH1cclxuXHJcbiAgICBpZiAoSVNfSElEUEkpIHtcclxuICAgICAgc291cmNlWCAqPSAyXHJcbiAgICAgIHNvdXJjZVkgKj0gMlxyXG4gICAgICBzb3VyY2VXaWR0aCAqPSAyXHJcbiAgICAgIHNvdXJjZUhlaWdodCAqPSAyXHJcbiAgICAgIGp1bXBPZmZzZXQgKj0gMlxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkanVzdG1lbnRzIGZvciBzcHJpdGUgc2hlZXQgcG9zaXRpb24uXHJcbiAgICBzb3VyY2VYICs9IHRoaXMuc3ByaXRlUG9zLnhcclxuICAgIHNvdXJjZVkgKz0gdGhpcy5zcHJpdGVQb3MueVxyXG5cclxuICAgIC8vIEZsYXNoaW5nLlxyXG4gICAgaWYgKHRoaXMuZmxhc2hpbmcpIHtcclxuICAgICAgaWYgKHRoaXMudGltZXIgPCB0aGlzLmNvbmZpZy5GTEFTSF9PTikge1xyXG4gICAgICAgIHRoaXMuY2FudmFzQ3R4Lmdsb2JhbEFscGhhID0gMC41XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50aW1lciA+IHRoaXMuY29uZmlnLkZMQVNIX09GRikge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSAwXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEdWNraW5nLlxyXG4gICAgaWYgKCF0aGlzLmFsdEdhbWVNb2RlRW5hYmxlZCAmJiB0aGlzLmR1Y2tpbmcgJiZcclxuICAgICAgdGhpcy5zdGF0dXMgIT09IFRyZXguc3RhdHVzLkNSQVNIRUQpIHtcclxuICAgICAgdGhpcy5jYW52YXNDdHguZHJhd0ltYWdlKFJ1bm5lci5pbWFnZVNwcml0ZSwgc291cmNlWCwgc291cmNlWSxcclxuICAgICAgICBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LFxyXG4gICAgICAgIHRoaXMueFBvcywgdGhpcy55UG9zLFxyXG4gICAgICAgIHRoaXMuY29uZmlnLldJRFRIX0RVQ0ssIG91dHB1dEhlaWdodClcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHRoaXMuYWx0R2FtZU1vZGVFbmFibGVkICYmIHRoaXMuanVtcGluZyAmJlxyXG4gICAgICB0aGlzLnN0YXR1cyAhPT0gVHJleC5zdGF0dXMuQ1JBU0hFRCkge1xyXG4gICAgICAvLyBKdW1waW5nIHdpdGggYWRqdXN0bWVudHMuXHJcbiAgICAgIHRoaXMuY2FudmFzQ3R4LmRyYXdJbWFnZShcclxuICAgICAgICBSdW5uZXIuaW1hZ2VTcHJpdGUsIHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsXHJcbiAgICAgICAgdGhpcy54UG9zIC0ganVtcE9mZnNldCwgdGhpcy55UG9zLCB0aGlzLmNvbmZpZy5XSURUSF9KVU1QLFxyXG4gICAgICAgIG91dHB1dEhlaWdodClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENyYXNoZWQgd2hpbHN0IGR1Y2tpbmcuIFRyZXggaXMgc3RhbmRpbmcgdXAgc28gbmVlZHMgYWRqdXN0bWVudC5cclxuICAgICAgaWYgKHRoaXMuZHVja2luZyAmJiB0aGlzLnN0YXR1cyA9PT0gVHJleC5zdGF0dXMuQ1JBU0hFRCkge1xyXG4gICAgICAgIHRoaXMueFBvcysrXHJcbiAgICAgIH1cclxuICAgICAgLy8gU3RhbmRpbmcgLyBydW5uaW5nXHJcbiAgICAgIHRoaXMuY2FudmFzQ3R4LmRyYXdJbWFnZShSdW5uZXIuaW1hZ2VTcHJpdGUsIHNvdXJjZVgsIHNvdXJjZVksXHJcbiAgICAgICAgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCxcclxuICAgICAgICB0aGlzLnhQb3MsIHRoaXMueVBvcyxcclxuICAgICAgICB0aGlzLmNvbmZpZy5XSURUSCwgb3V0cHV0SGVpZ2h0KVxyXG4gICAgfVxyXG4gICAgdGhpcy5jYW52YXNDdHguZ2xvYmFsQWxwaGEgPSAxXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIHJhbmRvbSB0aW1lIGZvciB0aGUgYmxpbmsgdG8gaGFwcGVuLlxyXG4gICAqL1xyXG4gIHNldEJsaW5rRGVsYXkgKCkge1xyXG4gICAgdGhpcy5ibGlua0RlbGF5ID0gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBUcmV4LkJMSU5LX1RJTUlORylcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBNYWtlIHQtcmV4IGJsaW5rIGF0IHJhbmRvbSBpbnRlcnZhbHMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgQ3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuICAgKi9cclxuICBibGluayAodGltZSkge1xyXG4gICAgY29uc3QgZGVsdGFUaW1lID0gdGltZSAtIHRoaXMuYW5pbVN0YXJ0VGltZVxyXG5cclxuICAgIGlmIChkZWx0YVRpbWUgPj0gdGhpcy5ibGlua0RlbGF5KSB7XHJcbiAgICAgIHRoaXMuZHJhdyh0aGlzLmN1cnJlbnRBbmltRnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXSwgMClcclxuXHJcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSA9PT0gMSkge1xyXG4gICAgICAgIC8vIFNldCBuZXcgcmFuZG9tIGRlbGF5IHRvIGJsaW5rLlxyXG4gICAgICAgIHRoaXMuc2V0QmxpbmtEZWxheSgpXHJcbiAgICAgICAgdGhpcy5hbmltU3RhcnRUaW1lID0gdGltZVxyXG4gICAgICAgIHRoaXMuYmxpbmtDb3VudCsrXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXNlIGEganVtcC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWRcclxuICAgKi9cclxuICBzdGFydEp1bXAgKHNwZWVkKSB7XHJcbiAgICBpZiAoIXRoaXMuanVtcGluZykge1xyXG4gICAgICB0aGlzLnVwZGF0ZSgwLCBUcmV4LnN0YXR1cy5KVU1QSU5HKVxyXG4gICAgICAvLyBUd2VhayB0aGUganVtcCB2ZWxvY2l0eSBiYXNlZCBvbiB0aGUgc3BlZWQuXHJcbiAgICAgIHRoaXMuanVtcFZlbG9jaXR5ID0gdGhpcy5jb25maWcuSU5JVElBTF9KVU1QX1ZFTE9DSVRZIC0gKHNwZWVkIC8gMTApXHJcbiAgICAgIHRoaXMuanVtcGluZyA9IHRydWVcclxuICAgICAgdGhpcy5yZWFjaGVkTWluSGVpZ2h0ID0gZmFsc2VcclxuICAgICAgdGhpcy5zcGVlZERyb3AgPSBmYWxzZVxyXG5cclxuICAgICAgaWYgKHRoaXMuY29uZmlnLklOVkVSVF9KVU1QKSB7XHJcbiAgICAgICAgdGhpcy5taW5KdW1wSGVpZ2h0ID0gdGhpcy5ncm91bmRZUG9zICsgdGhpcy5jb25maWcuTUlOX0pVTVBfSEVJR0hUXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBKdW1wIGlzIGNvbXBsZXRlLCBmYWxsaW5nIGRvd24uXHJcbiAgICovXHJcbiAgZW5kSnVtcCAoKSB7XHJcbiAgICBpZiAodGhpcy5yZWFjaGVkTWluSGVpZ2h0ICYmXHJcbiAgICAgIHRoaXMuanVtcFZlbG9jaXR5IDwgdGhpcy5jb25maWcuRFJPUF9WRUxPQ0lUWSkge1xyXG4gICAgICB0aGlzLmp1bXBWZWxvY2l0eSA9IHRoaXMuY29uZmlnLkRST1BfVkVMT0NJVFlcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgZnJhbWUgZm9yIGEganVtcC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lXHJcbiAgICovXHJcbiAgdXBkYXRlSnVtcCAoZGVsdGFUaW1lKSB7XHJcbiAgICBjb25zdCBtc1BlckZyYW1lID0gVHJleC5hbmltRnJhbWVzW3RoaXMuc3RhdHVzXS5tc1BlckZyYW1lXHJcbiAgICBjb25zdCBmcmFtZXNFbGFwc2VkID0gZGVsdGFUaW1lIC8gbXNQZXJGcmFtZVxyXG5cclxuICAgIC8vIFNwZWVkIGRyb3AgbWFrZXMgVHJleCBmYWxsIGZhc3Rlci5cclxuICAgIGlmICh0aGlzLnNwZWVkRHJvcCkge1xyXG4gICAgICB0aGlzLnlQb3MgKz0gTWF0aC5yb3VuZCh0aGlzLmp1bXBWZWxvY2l0eSAqXHJcbiAgICAgICAgdGhpcy5jb25maWcuU1BFRURfRFJPUF9DT0VGRklDSUVOVCAqIGZyYW1lc0VsYXBzZWQpXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29uZmlnLklOVkVSVF9KVU1QKSB7XHJcbiAgICAgIHRoaXMueVBvcyAtPSBNYXRoLnJvdW5kKHRoaXMuanVtcFZlbG9jaXR5ICogZnJhbWVzRWxhcHNlZClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMueVBvcyArPSBNYXRoLnJvdW5kKHRoaXMuanVtcFZlbG9jaXR5ICogZnJhbWVzRWxhcHNlZClcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmp1bXBWZWxvY2l0eSArPSB0aGlzLmNvbmZpZy5HUkFWSVRZICogZnJhbWVzRWxhcHNlZFxyXG5cclxuICAgIC8vIE1pbmltdW0gaGVpZ2h0IGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICBpZiAodGhpcy5jb25maWcuSU5WRVJUX0pVTVAgJiYgKHRoaXMueVBvcyA+IHRoaXMubWluSnVtcEhlaWdodCkgfHxcclxuICAgICAgIXRoaXMuY29uZmlnLklOVkVSVF9KVU1QICYmICh0aGlzLnlQb3MgPCB0aGlzLm1pbkp1bXBIZWlnaHQpIHx8XHJcbiAgICAgIHRoaXMuc3BlZWREcm9wKSB7XHJcbiAgICAgIHRoaXMucmVhY2hlZE1pbkhlaWdodCA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWFjaGVkIG1heCBoZWlnaHQuXHJcbiAgICBpZiAodGhpcy5jb25maWcuSU5WRVJUX0pVTVAgJiYgKHRoaXMueVBvcyA+IC10aGlzLmNvbmZpZy5NQVhfSlVNUF9IRUlHSFQpIHx8XHJcbiAgICAgICF0aGlzLmNvbmZpZy5JTlZFUlRfSlVNUCAmJiAodGhpcy55UG9zIDwgdGhpcy5jb25maWcuTUFYX0pVTVBfSEVJR0hUKSB8fFxyXG4gICAgICB0aGlzLnNwZWVkRHJvcCkge1xyXG4gICAgICB0aGlzLmVuZEp1bXAoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEJhY2sgZG93biBhdCBncm91bmQgbGV2ZWwuIEp1bXAgY29tcGxldGVkLlxyXG4gICAgaWYgKCh0aGlzLmNvbmZpZy5JTlZFUlRfSlVNUCAmJiB0aGlzLnlQb3MpIDwgdGhpcy5ncm91bmRZUG9zIHx8XHJcbiAgICAgICghdGhpcy5jb25maWcuSU5WRVJUX0pVTVAgJiYgdGhpcy55UG9zKSA+IHRoaXMuZ3JvdW5kWVBvcykge1xyXG4gICAgICB0aGlzLnJlc2V0KClcclxuICAgICAgdGhpcy5qdW1wQ291bnQrK1xyXG5cclxuICAgICAgaWYgKFJ1bm5lci5hdWRpb0N1ZXMpIHtcclxuICAgICAgICBSdW5uZXIuZ2VuZXJhdGVkU291bmRGeC5sb29wRm9vdFN0ZXBzKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc3BlZWQgZHJvcC4gSW1tZWRpYXRlbHkgY2FuY2VscyB0aGUgY3VycmVudCBqdW1wLlxyXG4gICAqL1xyXG4gIHNldFNwZWVkRHJvcCAoKSB7XHJcbiAgICB0aGlzLnNwZWVkRHJvcCA9IHRydWVcclxuICAgIHRoaXMuanVtcFZlbG9jaXR5ID0gMVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEdWNraW5nXHJcbiAgICovXHJcbiAgc2V0RHVjayAoaXNEdWNraW5nKSB7XHJcbiAgICBpZiAoaXNEdWNraW5nICYmIHRoaXMuc3RhdHVzICE9PSBUcmV4LnN0YXR1cy5EVUNLSU5HKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlKDAsIFRyZXguc3RhdHVzLkRVQ0tJTkcpXHJcbiAgICAgIHRoaXMuZHVja2luZyA9IHRydWVcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IFRyZXguc3RhdHVzLkRVQ0tJTkcpIHtcclxuICAgICAgdGhpcy51cGRhdGUoMCwgVHJleC5zdGF0dXMuUlVOTklORylcclxuICAgICAgdGhpcy5kdWNraW5nID0gZmFsc2VcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgdC1yZXggdG8gcnVubmluZyBhdCBzdGFydCBvZiBnYW1lLlxyXG4gICAqL1xyXG4gIHJlc2V0ICgpIHtcclxuICAgIHRoaXMueFBvcyA9IHRoaXMueEluaXRpYWxQb3NcclxuICAgIHRoaXMueVBvcyA9IHRoaXMuZ3JvdW5kWVBvc1xyXG4gICAgdGhpcy5qdW1wVmVsb2NpdHkgPSAwXHJcbiAgICB0aGlzLmp1bXBpbmcgPSBmYWxzZVxyXG4gICAgdGhpcy5kdWNraW5nID0gZmFsc2VcclxuICAgIHRoaXMudXBkYXRlKDAsIFRyZXguc3RhdHVzLlJVTk5JTkcpXHJcbiAgICB0aGlzLm1pZGFpciA9IGZhbHNlXHJcbiAgICB0aGlzLnNwZWVkRHJvcCA9IGZhbHNlXHJcbiAgICB0aGlzLmp1bXBDb3VudCA9IDBcclxuICB9XHJcbn1cclxuXHJcbi8vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgZGlzcGxheWluZyB0aGUgZGlzdGFuY2UgbWV0ZXIuXHJcbiAqIEBwYXJhbSB7IUhUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcclxuICogQHBhcmFtIHtPYmplY3R9IHNwcml0ZVBvcyBJbWFnZSBwb3NpdGlvbiBpbiBzcHJpdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNXaWR0aFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIERpc3RhbmNlTWV0ZXIgKGNhbnZhcywgc3ByaXRlUG9zLCBjYW52YXNXaWR0aCkge1xyXG4gIHRoaXMuY2FudmFzID0gY2FudmFzXHJcbiAgdGhpcy5jYW52YXNDdHggPVxyXG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovIChjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSlcclxuICB0aGlzLmltYWdlID0gUnVubmVyLmltYWdlU3ByaXRlXHJcbiAgdGhpcy5zcHJpdGVQb3MgPSBzcHJpdGVQb3NcclxuICB0aGlzLnggPSAwXHJcbiAgdGhpcy55ID0gNVxyXG5cclxuICB0aGlzLmN1cnJlbnREaXN0YW5jZSA9IDBcclxuICB0aGlzLm1heFNjb3JlID0gMFxyXG4gIHRoaXMuaGlnaFNjb3JlID0gJzAnXHJcbiAgdGhpcy5jb250YWluZXIgPSBudWxsXHJcblxyXG4gIHRoaXMuZGlnaXRzID0gW11cclxuICB0aGlzLmFjaGlldmVtZW50ID0gZmFsc2VcclxuICB0aGlzLmRlZmF1bHRTdHJpbmcgPSAnJ1xyXG4gIHRoaXMuZmxhc2hUaW1lciA9IDBcclxuICB0aGlzLmZsYXNoSXRlcmF0aW9ucyA9IDBcclxuICB0aGlzLmludmVydFRyaWdnZXIgPSBmYWxzZVxyXG4gIHRoaXMuZmxhc2hpbmdSYWZJZCA9IG51bGxcclxuICB0aGlzLmhpZ2hTY29yZUJvdW5kcyA9IHt9XHJcbiAgdGhpcy5oaWdoU2NvcmVGbGFzaGluZyA9IGZhbHNlXHJcblxyXG4gIHRoaXMuY29uZmlnID0gRGlzdGFuY2VNZXRlci5jb25maWdcclxuICB0aGlzLm1heFNjb3JlVW5pdHMgPSB0aGlzLmNvbmZpZy5NQVhfRElTVEFOQ0VfVU5JVFNcclxuICB0aGlzLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGhcclxuICB0aGlzLmluaXQoY2FudmFzV2lkdGgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxuRGlzdGFuY2VNZXRlci5kaW1lbnNpb25zID0ge1xyXG4gIFdJRFRIOiAxMCxcclxuICBIRUlHSFQ6IDEzLFxyXG4gIERFU1RfV0lEVEg6IDExXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBZIHBvc2l0aW9uaW5nIG9mIHRoZSBkaWdpdHMgaW4gdGhlIHNwcml0ZSBzaGVldC5cclxuICogWCBwb3NpdGlvbiBpcyBhbHdheXMgMC5cclxuICogQHR5cGUge0FycmF5PG51bWJlcj59XHJcbiAqL1xyXG5EaXN0YW5jZU1ldGVyLnlQb3MgPSBbMCwgMTMsIDI3LCA0MCwgNTMsIDY3LCA4MCwgOTMsIDEwNywgMTIwXVxyXG5cclxuLyoqXHJcbiAqIERpc3RhbmNlIG1ldGVyIGNvbmZpZy5cclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbkRpc3RhbmNlTWV0ZXIuY29uZmlnID0ge1xyXG4gIC8vIE51bWJlciBvZiBkaWdpdHMuXHJcbiAgTUFYX0RJU1RBTkNFX1VOSVRTOiA1LFxyXG5cclxuICAvLyBEaXN0YW5jZSB0aGF0IGNhdXNlcyBhY2hpZXZlbWVudCBhbmltYXRpb24uXHJcbiAgQUNISUVWRU1FTlRfRElTVEFOQ0U6IDEwMCxcclxuXHJcbiAgLy8gVXNlZCBmb3IgY29udmVyc2lvbiBmcm9tIHBpeGVsIGRpc3RhbmNlIHRvIGEgc2NhbGVkIHVuaXQuXHJcbiAgQ09FRkZJQ0lFTlQ6IDAuMDI1LFxyXG5cclxuICAvLyBGbGFzaCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXHJcbiAgRkxBU0hfRFVSQVRJT046IDEwMDAgLyA0LFxyXG5cclxuICAvLyBGbGFzaCBpdGVyYXRpb25zIGZvciBhY2hpZXZlbWVudCBhbmltYXRpb24uXHJcbiAgRkxBU0hfSVRFUkFUSU9OUzogMyxcclxuXHJcbiAgLy8gUGFkZGluZyBhcm91bmQgdGhlIGhpZ2ggc2NvcmUgaGl0IGFyZWEuXHJcbiAgSElHSF9TQ09SRV9ISVRfQVJFQV9QQURESU5HOiA0XHJcbn1cclxuXHJcbkRpc3RhbmNlTWV0ZXIucHJvdG90eXBlID0ge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpc2UgdGhlIGRpc3RhbmNlIG1ldGVyIHRvICcwMDAwMCcuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIENhbnZhcyB3aWR0aCBpbiBweC5cclxuICAgKi9cclxuICBpbml0ICh3aWR0aCkge1xyXG4gICAgbGV0IG1heERpc3RhbmNlU3RyID0gJydcclxuXHJcbiAgICB0aGlzLmNhbGNYUG9zKHdpZHRoKVxyXG4gICAgdGhpcy5tYXhTY29yZSA9IHRoaXMubWF4U2NvcmVVbml0c1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1heFNjb3JlVW5pdHM7IGkrKykge1xyXG4gICAgICB0aGlzLmRyYXcoaSwgMClcclxuICAgICAgdGhpcy5kZWZhdWx0U3RyaW5nICs9ICcwJ1xyXG4gICAgICBtYXhEaXN0YW5jZVN0ciArPSAnOSdcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1heFNjb3JlID0gcGFyc2VJbnQobWF4RGlzdGFuY2VTdHIsIDEwKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgeFBvcyBpbiB0aGUgY2FudmFzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNXaWR0aFxyXG4gICAqL1xyXG4gIGNhbGNYUG9zIChjYW52YXNXaWR0aCkge1xyXG4gICAgdGhpcy54ID0gY2FudmFzV2lkdGggLSAoRGlzdGFuY2VNZXRlci5kaW1lbnNpb25zLkRFU1RfV0lEVEggKlxyXG4gICAgICAodGhpcy5tYXhTY29yZVVuaXRzICsgMSkpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhdyBhIGRpZ2l0IHRvIGNhbnZhcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlnaXRQb3MgUG9zaXRpb24gb2YgdGhlIGRpZ2l0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBEaWdpdCB2YWx1ZSAwLTkuXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2hpZ2hTY29yZSBXaGV0aGVyIGRyYXdpbmcgdGhlIGhpZ2ggc2NvcmUuXHJcbiAgICovXHJcbiAgZHJhdyAoZGlnaXRQb3MsIHZhbHVlLCBvcHRfaGlnaFNjb3JlKSB7XHJcbiAgICBsZXQgc291cmNlV2lkdGggPSBEaXN0YW5jZU1ldGVyLmRpbWVuc2lvbnMuV0lEVEhcclxuICAgIGxldCBzb3VyY2VIZWlnaHQgPSBEaXN0YW5jZU1ldGVyLmRpbWVuc2lvbnMuSEVJR0hUXHJcbiAgICBsZXQgc291cmNlWCA9IERpc3RhbmNlTWV0ZXIuZGltZW5zaW9ucy5XSURUSCAqIHZhbHVlXHJcbiAgICBsZXQgc291cmNlWSA9IDBcclxuXHJcbiAgICBjb25zdCB0YXJnZXRYID0gZGlnaXRQb3MgKiBEaXN0YW5jZU1ldGVyLmRpbWVuc2lvbnMuREVTVF9XSURUSFxyXG4gICAgY29uc3QgdGFyZ2V0WSA9IHRoaXMueVxyXG4gICAgY29uc3QgdGFyZ2V0V2lkdGggPSBEaXN0YW5jZU1ldGVyLmRpbWVuc2lvbnMuV0lEVEhcclxuICAgIGNvbnN0IHRhcmdldEhlaWdodCA9IERpc3RhbmNlTWV0ZXIuZGltZW5zaW9ucy5IRUlHSFRcclxuXHJcbiAgICAvLyBGb3IgaGlnaCBEUEkgd2UgMnggc291cmNlIHZhbHVlcy5cclxuICAgIGlmIChJU19ISURQSSkge1xyXG4gICAgICBzb3VyY2VXaWR0aCAqPSAyXHJcbiAgICAgIHNvdXJjZUhlaWdodCAqPSAyXHJcbiAgICAgIHNvdXJjZVggKj0gMlxyXG4gICAgfVxyXG5cclxuICAgIHNvdXJjZVggKz0gdGhpcy5zcHJpdGVQb3MueFxyXG4gICAgc291cmNlWSArPSB0aGlzLnNwcml0ZVBvcy55XHJcblxyXG4gICAgdGhpcy5jYW52YXNDdHguc2F2ZSgpXHJcblxyXG4gICAgaWYgKElTX1JUTCkge1xyXG4gICAgICBpZiAob3B0X2hpZ2hTY29yZSkge1xyXG4gICAgICAgIHRoaXMuY2FudmFzQ3R4LnRyYW5zbGF0ZShcclxuICAgICAgICAgIHRoaXMuY2FudmFzV2lkdGggLVxyXG4gICAgICAgICAgKERpc3RhbmNlTWV0ZXIuZGltZW5zaW9ucy5XSURUSCAqICh0aGlzLm1heFNjb3JlVW5pdHMgKyAzKSksXHJcbiAgICAgICAgICB0aGlzLnkpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDdHgudHJhbnNsYXRlKFxyXG4gICAgICAgICAgdGhpcy5jYW52YXNXaWR0aCAtIERpc3RhbmNlTWV0ZXIuZGltZW5zaW9ucy5XSURUSCwgdGhpcy55KVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY2FudmFzQ3R4LnNjYWxlKC0xLCAxKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaGlnaFNjb3JlWCA9XHJcbiAgICAgICAgdGhpcy54IC0gKHRoaXMubWF4U2NvcmVVbml0cyAqIDIpICogRGlzdGFuY2VNZXRlci5kaW1lbnNpb25zLldJRFRIXHJcbiAgICAgIGlmIChvcHRfaGlnaFNjb3JlKSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDdHgudHJhbnNsYXRlKGhpZ2hTY29yZVgsIHRoaXMueSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNhbnZhc0N0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNhbnZhc0N0eC5kcmF3SW1hZ2UoXHJcbiAgICAgIHRoaXMuaW1hZ2UsXHJcbiAgICAgIHNvdXJjZVgsXHJcbiAgICAgIHNvdXJjZVksXHJcbiAgICAgIHNvdXJjZVdpZHRoLFxyXG4gICAgICBzb3VyY2VIZWlnaHQsXHJcbiAgICAgIHRhcmdldFgsXHJcbiAgICAgIHRhcmdldFksXHJcbiAgICAgIHRhcmdldFdpZHRoLFxyXG4gICAgICB0YXJnZXRIZWlnaHRcclxuICAgIClcclxuXHJcbiAgICB0aGlzLmNhbnZhc0N0eC5yZXN0b3JlKClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDb3ZlcnQgcGl4ZWwgZGlzdGFuY2UgdG8gYSAncmVhbCcgZGlzdGFuY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIFBpeGVsIGRpc3RhbmNlIHJhbi5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSAncmVhbCcgZGlzdGFuY2UgcmFuLlxyXG4gICAqL1xyXG4gIGdldEFjdHVhbERpc3RhbmNlIChkaXN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGRpc3RhbmNlID8gTWF0aC5yb3VuZChkaXN0YW5jZSAqIHRoaXMuY29uZmlnLkNPRUZGSUNJRU5UKSA6IDBcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGRpc3RhbmNlIG1ldGVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWVcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBhY2hlaXZlbWVudCBzb3VuZCBmeCBzaG91bGQgYmUgcGxheWVkLlxyXG4gICAqL1xyXG4gIHVwZGF0ZSAoZGVsdGFUaW1lLCBkaXN0YW5jZSkge1xyXG4gICAgbGV0IHBhaW50ID0gdHJ1ZVxyXG4gICAgbGV0IHBsYXlTb3VuZCA9IGZhbHNlXHJcblxyXG4gICAgaWYgKCF0aGlzLmFjaGlldmVtZW50KSB7XHJcbiAgICAgIGRpc3RhbmNlID0gdGhpcy5nZXRBY3R1YWxEaXN0YW5jZShkaXN0YW5jZSlcclxuICAgICAgLy8gU2NvcmUgaGFzIGdvbmUgYmV5b25kIHRoZSBpbml0aWFsIGRpZ2l0IGNvdW50LlxyXG4gICAgICBpZiAoZGlzdGFuY2UgPiB0aGlzLm1heFNjb3JlICYmIHRoaXMubWF4U2NvcmVVbml0cyA9PVxyXG4gICAgICAgIHRoaXMuY29uZmlnLk1BWF9ESVNUQU5DRV9VTklUUykge1xyXG4gICAgICAgIHRoaXMubWF4U2NvcmVVbml0cysrXHJcbiAgICAgICAgdGhpcy5tYXhTY29yZSA9IHBhcnNlSW50KHRoaXMubWF4U2NvcmUgKyAnOScsIDEwKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAwXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcclxuICAgICAgICAvLyBBY2hpZXZlbWVudCB1bmxvY2tlZC5cclxuICAgICAgICBpZiAoZGlzdGFuY2UgJSB0aGlzLmNvbmZpZy5BQ0hJRVZFTUVOVF9ESVNUQU5DRSA9PT0gMCkge1xyXG4gICAgICAgICAgLy8gRmxhc2ggc2NvcmUgYW5kIHBsYXkgc291bmQuXHJcbiAgICAgICAgICB0aGlzLmFjaGlldmVtZW50ID0gdHJ1ZVxyXG4gICAgICAgICAgdGhpcy5mbGFzaFRpbWVyID0gMFxyXG4gICAgICAgICAgcGxheVNvdW5kID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkaXN0YW5jZSB3aXRoIGxlYWRpbmcgMC5cclxuICAgICAgICBjb25zdCBkaXN0YW5jZVN0ciA9ICh0aGlzLmRlZmF1bHRTdHJpbmcgK1xyXG4gICAgICAgICAgZGlzdGFuY2UpLnN1YnN0cigtdGhpcy5tYXhTY29yZVVuaXRzKVxyXG4gICAgICAgIHRoaXMuZGlnaXRzID0gZGlzdGFuY2VTdHIuc3BsaXQoJycpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kaWdpdHMgPSB0aGlzLmRlZmF1bHRTdHJpbmcuc3BsaXQoJycpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENvbnRyb2wgZmxhc2hpbmcgb2YgdGhlIHNjb3JlIG9uIHJlYWNoaW5nIGFjaGVpdmVtZW50LlxyXG4gICAgICBpZiAodGhpcy5mbGFzaEl0ZXJhdGlvbnMgPD0gdGhpcy5jb25maWcuRkxBU0hfSVRFUkFUSU9OUykge1xyXG4gICAgICAgIHRoaXMuZmxhc2hUaW1lciArPSBkZWx0YVRpbWVcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZmxhc2hUaW1lciA8IHRoaXMuY29uZmlnLkZMQVNIX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgICBwYWludCA9IGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZsYXNoVGltZXIgPiB0aGlzLmNvbmZpZy5GTEFTSF9EVVJBVElPTiAqIDIpIHtcclxuICAgICAgICAgIHRoaXMuZmxhc2hUaW1lciA9IDBcclxuICAgICAgICAgIHRoaXMuZmxhc2hJdGVyYXRpb25zKytcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hY2hpZXZlbWVudCA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5mbGFzaEl0ZXJhdGlvbnMgPSAwXHJcbiAgICAgICAgdGhpcy5mbGFzaFRpbWVyID0gMFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyB0aGUgZGlnaXRzIGlmIG5vdCBmbGFzaGluZy5cclxuICAgIGlmIChwYWludCkge1xyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5kaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB0aGlzLmRyYXcoaSwgcGFyc2VJbnQodGhpcy5kaWdpdHNbaV0sIDEwKSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJhd0hpZ2hTY29yZSgpXHJcbiAgICByZXR1cm4gcGxheVNvdW5kXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhdyB0aGUgaGlnaCBzY29yZS5cclxuICAgKi9cclxuICBkcmF3SGlnaFNjb3JlICgpIHtcclxuICAgIGlmIChwYXJzZUludCh0aGlzLmhpZ2hTY29yZSwgMTApID4gMCkge1xyXG4gICAgICB0aGlzLmNhbnZhc0N0eC5zYXZlKClcclxuICAgICAgdGhpcy5jYW52YXNDdHguZ2xvYmFsQWxwaGEgPSAwLjhcclxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGlnaFNjb3JlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgdGhpcy5kcmF3KGksIHBhcnNlSW50KHRoaXMuaGlnaFNjb3JlW2ldLCAxMCksIHRydWUpXHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jYW52YXNDdHgucmVzdG9yZSgpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBoaWdoc2NvcmUgYXMgYSBhcnJheSBzdHJpbmcuXHJcbiAgICogUG9zaXRpb24gb2YgY2hhciBpbiB0aGUgc3ByaXRlOiBIIC0gMTAsIEkgLSAxMS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgRGlzdGFuY2UgcmFuIGluIHBpeGVscy5cclxuICAgKi9cclxuICBzZXRIaWdoU2NvcmUgKGRpc3RhbmNlKSB7XHJcbiAgICBkaXN0YW5jZSA9IHRoaXMuZ2V0QWN0dWFsRGlzdGFuY2UoZGlzdGFuY2UpXHJcbiAgICBjb25zdCBoaWdoU2NvcmVTdHIgPSAodGhpcy5kZWZhdWx0U3RyaW5nICtcclxuICAgICAgZGlzdGFuY2UpLnN1YnN0cigtdGhpcy5tYXhTY29yZVVuaXRzKVxyXG5cclxuICAgIHRoaXMuaGlnaFNjb3JlID0gWycxMCcsICcxMScsICcnXS5jb25jYXQoaGlnaFNjb3JlU3RyLnNwbGl0KCcnKSlcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIGEgY2xpY2tlZCBpcyBpbiB0aGUgaGlnaCBzY29yZSBhcmVhLlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNsaWNrIHdhcyBpbiB0aGUgaGlnaCBzY29yZSBib3VuZHMuXHJcbiAgICovXHJcbiAgaGFzQ2xpY2tlZE9uSGlnaFNjb3JlIChlKSB7XHJcbiAgICBsZXQgeCA9IDBcclxuICAgIGxldCB5ID0gMFxyXG5cclxuICAgIGlmIChlLnRvdWNoZXMpIHtcclxuICAgICAgLy8gQm91bmRzIGZvciB0b3VjaCBkaWZmZXIgZnJvbSBwb2ludGVyLlxyXG4gICAgICBjb25zdCBjYW52YXNCb3VuZHMgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICB4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBjYW52YXNCb3VuZHMubGVmdFxyXG4gICAgICB5ID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBjYW52YXNCb3VuZHMudG9wXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0gZS5vZmZzZXRYXHJcbiAgICAgIHkgPSBlLm9mZnNldFlcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmhpZ2hTY29yZUJvdW5kcyA9IHRoaXMuZ2V0SGlnaFNjb3JlQm91bmRzKClcclxuICAgIHJldHVybiB4ID49IHRoaXMuaGlnaFNjb3JlQm91bmRzLnggJiYgeCA8PVxyXG4gICAgICB0aGlzLmhpZ2hTY29yZUJvdW5kcy54ICsgdGhpcy5oaWdoU2NvcmVCb3VuZHMud2lkdGggJiZcclxuICAgICAgeSA+PSB0aGlzLmhpZ2hTY29yZUJvdW5kcy55ICYmIHkgPD1cclxuICAgICAgdGhpcy5oaWdoU2NvcmVCb3VuZHMueSArIHRoaXMuaGlnaFNjb3JlQm91bmRzLmhlaWdodFxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYm91bmRpbmcgYm94IGZvciB0aGUgaGlnaCBzY29yZS5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllcy5cclxuICAgKi9cclxuICBnZXRIaWdoU2NvcmVCb3VuZHMgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogKHRoaXMueCAtICh0aGlzLm1heFNjb3JlVW5pdHMgKiAyKSAqIERpc3RhbmNlTWV0ZXIuZGltZW5zaW9ucy5XSURUSCkgLVxyXG4gICAgICAgIERpc3RhbmNlTWV0ZXIuY29uZmlnLkhJR0hfU0NPUkVfSElUX0FSRUFfUEFERElORyxcclxuICAgICAgeTogdGhpcy55LFxyXG4gICAgICB3aWR0aDogRGlzdGFuY2VNZXRlci5kaW1lbnNpb25zLldJRFRIICogKHRoaXMuaGlnaFNjb3JlLmxlbmd0aCArIDEpICtcclxuICAgICAgICBEaXN0YW5jZU1ldGVyLmNvbmZpZy5ISUdIX1NDT1JFX0hJVF9BUkVBX1BBRERJTkcsXHJcbiAgICAgIGhlaWdodDogRGlzdGFuY2VNZXRlci5kaW1lbnNpb25zLkhFSUdIVCArXHJcbiAgICAgICAgKERpc3RhbmNlTWV0ZXIuY29uZmlnLkhJR0hfU0NPUkVfSElUX0FSRUFfUEFERElORyAqIDIpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQW5pbWF0ZSBmbGFzaGluZyB0aGUgaGlnaCBzY29yZSB0byBpbmRpY2F0ZSByZWFkeSBmb3IgcmVzZXR0aW5nLlxyXG4gICAqIFRoZSBmbGFzaGluZyBzdG9wcyBmb2xsb3dpbmcgdGhpcy5jb25maWcuRkxBU0hfSVRFUkFUSU9OUyB4IDIgZmxhc2hlcy5cclxuICAgKi9cclxuICBmbGFzaEhpZ2hTY29yZSAoKSB7XHJcbiAgICBjb25zdCBub3cgPSBnZXRUaW1lU3RhbXAoKVxyXG4gICAgY29uc3QgZGVsdGFUaW1lID0gbm93IC0gKHRoaXMuZnJhbWVUaW1lU3RhbXAgfHwgbm93KVxyXG4gICAgbGV0IHBhaW50ID0gdHJ1ZVxyXG4gICAgdGhpcy5mcmFtZVRpbWVTdGFtcCA9IG5vd1xyXG5cclxuICAgIC8vIFJlYWNoZWQgdGhlIG1heCBudW1iZXIgb2YgZmxhc2hlcy5cclxuICAgIGlmICh0aGlzLmZsYXNoSXRlcmF0aW9ucyA+IHRoaXMuY29uZmlnLkZMQVNIX0lURVJBVElPTlMgKiAyKSB7XHJcbiAgICAgIHRoaXMuY2FuY2VsSGlnaFNjb3JlRmxhc2hpbmcoKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZsYXNoVGltZXIgKz0gZGVsdGFUaW1lXHJcblxyXG4gICAgaWYgKHRoaXMuZmxhc2hUaW1lciA8IHRoaXMuY29uZmlnLkZMQVNIX0RVUkFUSU9OKSB7XHJcbiAgICAgIHBhaW50ID0gZmFsc2VcclxuICAgIH0gZWxzZSBpZiAodGhpcy5mbGFzaFRpbWVyID4gdGhpcy5jb25maWcuRkxBU0hfRFVSQVRJT04gKiAyKSB7XHJcbiAgICAgIHRoaXMuZmxhc2hUaW1lciA9IDBcclxuICAgICAgdGhpcy5mbGFzaEl0ZXJhdGlvbnMrK1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYWludCkge1xyXG4gICAgICB0aGlzLmRyYXdIaWdoU2NvcmUoKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jbGVhckhpZ2hTY29yZUJvdW5kcygpXHJcbiAgICB9XHJcbiAgICAvLyBGcmFtZSB1cGRhdGUuXHJcbiAgICB0aGlzLmZsYXNoaW5nUmFmSWQgPVxyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5mbGFzaEhpZ2hTY29yZS5iaW5kKHRoaXMpKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXcgZW1wdHkgcmVjdGFuZ2xlIG92ZXIgaGlnaCBzY29yZS5cclxuICAgKi9cclxuICBjbGVhckhpZ2hTY29yZUJvdW5kcyAoKSB7XHJcbiAgICB0aGlzLmNhbnZhc0N0eC5zYXZlKClcclxuICAgIHRoaXMuY2FudmFzQ3R4LmZpbGxTdHlsZSA9ICcjZmZmJ1xyXG4gICAgdGhpcy5jYW52YXNDdHgucmVjdCh0aGlzLmhpZ2hTY29yZUJvdW5kcy54LCB0aGlzLmhpZ2hTY29yZUJvdW5kcy55LFxyXG4gICAgICB0aGlzLmhpZ2hTY29yZUJvdW5kcy53aWR0aCwgdGhpcy5oaWdoU2NvcmVCb3VuZHMuaGVpZ2h0KVxyXG4gICAgdGhpcy5jYW52YXNDdHguZmlsbCgpXHJcbiAgICB0aGlzLmNhbnZhc0N0eC5yZXN0b3JlKClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgdGhlIGZsYXNoaW5nIG9mIHRoZSBoaWdoIHNjb3JlLlxyXG4gICAqL1xyXG4gIHN0YXJ0SGlnaFNjb3JlRmxhc2hpbmcgKCkge1xyXG4gICAgdGhpcy5oaWdoU2NvcmVGbGFzaGluZyA9IHRydWVcclxuICAgIHRoaXMuZmxhc2hIaWdoU2NvcmUoKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgaGlnaCBzY29yZSBpcyBmbGFzaGluZy5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGlzSGlnaFNjb3JlRmxhc2hpbmcgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaFNjb3JlRmxhc2hpbmdcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGZsYXNoaW5nIHRoZSBoaWdoIHNjb3JlLlxyXG4gICAqL1xyXG4gIGNhbmNlbEhpZ2hTY29yZUZsYXNoaW5nICgpIHtcclxuICAgIGlmICh0aGlzLmZsYXNoaW5nUmFmSWQpIHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbGFzaGluZ1JhZklkKVxyXG4gICAgfVxyXG4gICAgdGhpcy5mbGFzaEl0ZXJhdGlvbnMgPSAwXHJcbiAgICB0aGlzLmZsYXNoVGltZXIgPSAwXHJcbiAgICB0aGlzLmhpZ2hTY29yZUZsYXNoaW5nID0gZmFsc2VcclxuICAgIHRoaXMuY2xlYXJIaWdoU2NvcmVCb3VuZHMoKVxyXG4gICAgdGhpcy5kcmF3SGlnaFNjb3JlKClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciB0aGUgaGlnaCBzY29yZS5cclxuICAgKi9cclxuICByZXNldEhpZ2hTY29yZSAoKSB7XHJcbiAgICB0aGlzLnNldEhpZ2hTY29yZSgwKVxyXG4gICAgdGhpcy5jYW5jZWxIaWdoU2NvcmVGbGFzaGluZygpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIGRpc3RhbmNlIG1ldGVyIGJhY2sgdG8gJzAwMDAwJy5cclxuICAgKi9cclxuICByZXNldCAoKSB7XHJcbiAgICB0aGlzLnVwZGF0ZSgwLCAwKVxyXG4gICAgdGhpcy5hY2hpZXZlbWVudCA9IGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG4vLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbi8qKlxyXG4gKiBDbG91ZCBiYWNrZ3JvdW5kIGl0ZW0uXHJcbiAqIFNpbWlsYXIgdG8gYW4gb2JzdGFjbGUgb2JqZWN0IGJ1dCB3aXRob3V0IGNvbGxpc2lvbiBib3hlcy5cclxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIENhbnZhcyBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3ByaXRlUG9zIFBvc2l0aW9uIG9mIGltYWdlIGluIHNwcml0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gQ2xvdWQgKGNhbnZhcywgc3ByaXRlUG9zLCBjb250YWluZXJXaWR0aCkge1xyXG4gIHRoaXMuY2FudmFzID0gY2FudmFzXHJcbiAgdGhpcy5jYW52YXNDdHggPVxyXG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovICh0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKVxyXG4gIHRoaXMuc3ByaXRlUG9zID0gc3ByaXRlUG9zXHJcbiAgdGhpcy5jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lcldpZHRoXHJcbiAgdGhpcy54UG9zID0gY29udGFpbmVyV2lkdGhcclxuICB0aGlzLnlQb3MgPSAwXHJcbiAgdGhpcy5yZW1vdmUgPSBmYWxzZVxyXG4gIHRoaXMuZ2FwID1cclxuICAgIGdldFJhbmRvbU51bShDbG91ZC5jb25maWcuTUlOX0NMT1VEX0dBUCwgQ2xvdWQuY29uZmlnLk1BWF9DTE9VRF9HQVApXHJcblxyXG4gIHRoaXMuaW5pdCgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbG91ZCBvYmplY3QgY29uZmlnLlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxuQ2xvdWQuY29uZmlnID0ge1xyXG4gIEhFSUdIVDogMTQsXHJcbiAgTUFYX0NMT1VEX0dBUDogNDAwLFxyXG4gIE1BWF9TS1lfTEVWRUw6IDMwLFxyXG4gIE1JTl9DTE9VRF9HQVA6IDEwMCxcclxuICBNSU5fU0tZX0xFVkVMOiA3MSxcclxuICBXSURUSDogNDZcclxufVxyXG5cclxuQ2xvdWQucHJvdG90eXBlID0ge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpc2UgdGhlIGNsb3VkLiBTZXRzIHRoZSBDbG91ZCBoZWlnaHQuXHJcbiAgICovXHJcbiAgaW5pdCAoKSB7XHJcbiAgICB0aGlzLnlQb3MgPSBnZXRSYW5kb21OdW0oQ2xvdWQuY29uZmlnLk1BWF9TS1lfTEVWRUwsXHJcbiAgICAgIENsb3VkLmNvbmZpZy5NSU5fU0tZX0xFVkVMKVxyXG4gICAgdGhpcy5kcmF3KClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEcmF3IHRoZSBjbG91ZC5cclxuICAgKi9cclxuICBkcmF3ICgpIHtcclxuICAgIHRoaXMuY2FudmFzQ3R4LnNhdmUoKVxyXG4gICAgbGV0IHNvdXJjZVdpZHRoID0gQ2xvdWQuY29uZmlnLldJRFRIXHJcbiAgICBsZXQgc291cmNlSGVpZ2h0ID0gQ2xvdWQuY29uZmlnLkhFSUdIVFxyXG4gICAgY29uc3Qgb3V0cHV0V2lkdGggPSBzb3VyY2VXaWR0aFxyXG4gICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gc291cmNlSGVpZ2h0XHJcbiAgICBpZiAoSVNfSElEUEkpIHtcclxuICAgICAgc291cmNlV2lkdGggPSBzb3VyY2VXaWR0aCAqIDJcclxuICAgICAgc291cmNlSGVpZ2h0ID0gc291cmNlSGVpZ2h0ICogMlxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FudmFzQ3R4LmRyYXdJbWFnZShSdW5uZXIuaW1hZ2VTcHJpdGUsIHRoaXMuc3ByaXRlUG9zLngsXHJcbiAgICAgIHRoaXMuc3ByaXRlUG9zLnksXHJcbiAgICAgIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsXHJcbiAgICAgIHRoaXMueFBvcywgdGhpcy55UG9zLFxyXG4gICAgICBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KVxyXG5cclxuICAgIHRoaXMuY2FudmFzQ3R4LnJlc3RvcmUoKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgY2xvdWQgcG9zaXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXHJcbiAgICovXHJcbiAgdXBkYXRlIChzcGVlZCkge1xyXG4gICAgaWYgKCF0aGlzLnJlbW92ZSkge1xyXG4gICAgICB0aGlzLnhQb3MgLT0gTWF0aC5jZWlsKHNwZWVkKVxyXG4gICAgICB0aGlzLmRyYXcoKVxyXG5cclxuICAgICAgLy8gTWFyayBhcyByZW1vdmVhYmxlIGlmIG5vIGxvbmdlciBpbiB0aGUgY2FudmFzLlxyXG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZSA9IHRydWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBjbG91ZCBpcyB2aXNpYmxlIG9uIHRoZSBzdGFnZS5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGlzVmlzaWJsZSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy54UG9zICsgQ2xvdWQuY29uZmlnLldJRFRIID4gMFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJhY2tncm91bmQgaXRlbS5cclxuICogU2ltaWxhciB0byBjbG91ZCwgd2l0aG91dCByYW5kb20geSBwb3NpdGlvbi5cclxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIENhbnZhcyBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3ByaXRlUG9zIFBvc2l0aW9uIG9mIGltYWdlIGluIHNwcml0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVsZW1lbnQgdHlwZS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBCYWNrZ3JvdW5kRWwgKGNhbnZhcywgc3ByaXRlUG9zLCBjb250YWluZXJXaWR0aCwgdHlwZSkge1xyXG4gIHRoaXMuY2FudmFzID0gY2FudmFzXHJcbiAgdGhpcy5jYW52YXNDdHggPVxyXG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovICh0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKVxyXG4gIHRoaXMuc3ByaXRlUG9zID0gc3ByaXRlUG9zXHJcbiAgdGhpcy5jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lcldpZHRoXHJcbiAgdGhpcy54UG9zID0gY29udGFpbmVyV2lkdGhcclxuICB0aGlzLnlQb3MgPSAwXHJcbiAgdGhpcy5yZW1vdmUgPSBmYWxzZVxyXG4gIHRoaXMudHlwZSA9IHR5cGVcclxuICB0aGlzLmdhcCA9XHJcbiAgICBnZXRSYW5kb21OdW0oQmFja2dyb3VuZEVsLmNvbmZpZy5NSU5fR0FQLCBCYWNrZ3JvdW5kRWwuY29uZmlnLk1BWF9HQVApXHJcbiAgdGhpcy5hbmltVGltZXIgPSAwXHJcbiAgdGhpcy5zd2l0Y2hGcmFtZXMgPSBmYWxzZVxyXG5cclxuICB0aGlzLnNwcml0ZUNvbmZpZyA9IHt9XHJcbiAgdGhpcy5pbml0KClcclxufVxyXG5cclxuLyoqXHJcbiAqIEJhY2tncm91bmQgZWxlbWVudCBvYmplY3QgY29uZmlnLlxyXG4gKiBSZWFsIHZhbHVlcyBhc3NpZ25lZCB3aGVuIGdhbWUgdHlwZSBjaGFuZ2VzLlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxuQmFja2dyb3VuZEVsLmNvbmZpZyA9IHtcclxuICBNQVhfQkdfRUxTOiAwLFxyXG4gIE1BWF9HQVA6IDAsXHJcbiAgTUlOX0dBUDogMCxcclxuICBQT1M6IDAsXHJcbiAgU1BFRUQ6IDAsXHJcbiAgWV9QT1M6IDAsXHJcbiAgTVNfUEVSX0ZSQU1FOiAwIC8vIG9ubHkgbmVlZGVkIHdoZW4gQkFDS0dST1VORF9FTC5GSVhFRCBpcyB0cnVlXHJcbn1cclxuXHJcbkJhY2tncm91bmRFbC5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGlzZSB0aGUgZWxlbWVudCBzZXR0aW5nIHRoZSB5IHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIGluaXQgKCkge1xyXG4gICAgdGhpcy5zcHJpdGVDb25maWcgPSBSdW5uZXIuc3ByaXRlRGVmaW5pdGlvbi5CQUNLR1JPVU5EX0VMW3RoaXMudHlwZV1cclxuICAgIGlmICh0aGlzLnNwcml0ZUNvbmZpZy5GSVhFRCkge1xyXG4gICAgICB0aGlzLnhQb3MgPSB0aGlzLnNwcml0ZUNvbmZpZy5GSVhFRF9YX1BPU1xyXG4gICAgfVxyXG4gICAgdGhpcy55UG9zID0gQmFja2dyb3VuZEVsLmNvbmZpZy5ZX1BPUyAtIHRoaXMuc3ByaXRlQ29uZmlnLkhFSUdIVCArXHJcbiAgICAgIHRoaXMuc3ByaXRlQ29uZmlnLk9GRlNFVFxyXG4gICAgdGhpcy5kcmF3KClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEcmF3IHRoZSBlbGVtZW50LlxyXG4gICAqL1xyXG4gIGRyYXcgKCkge1xyXG4gICAgdGhpcy5jYW52YXNDdHguc2F2ZSgpXHJcbiAgICBsZXQgc291cmNlV2lkdGggPSB0aGlzLnNwcml0ZUNvbmZpZy5XSURUSFxyXG4gICAgbGV0IHNvdXJjZUhlaWdodCA9IHRoaXMuc3ByaXRlQ29uZmlnLkhFSUdIVFxyXG4gICAgbGV0IHNvdXJjZVggPSB0aGlzLnNwcml0ZUNvbmZpZy5YX1BPU1xyXG4gICAgY29uc3Qgb3V0cHV0V2lkdGggPSBzb3VyY2VXaWR0aFxyXG4gICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gc291cmNlSGVpZ2h0XHJcblxyXG4gICAgaWYgKElTX0hJRFBJKSB7XHJcbiAgICAgIHNvdXJjZVdpZHRoICo9IDJcclxuICAgICAgc291cmNlSGVpZ2h0ICo9IDJcclxuICAgICAgc291cmNlWCAqPSAyXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYW52YXNDdHguZHJhd0ltYWdlKFxyXG4gICAgICBSdW5uZXIuaW1hZ2VTcHJpdGUsIHNvdXJjZVgsIHRoaXMuc3ByaXRlUG9zLnksIHNvdXJjZVdpZHRoLFxyXG4gICAgICBzb3VyY2VIZWlnaHQsIHRoaXMueFBvcywgdGhpcy55UG9zLCBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KVxyXG5cclxuICAgIHRoaXMuY2FudmFzQ3R4LnJlc3RvcmUoKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgYmFja2dyb3VuZCBlbGVtZW50IHBvc2l0aW9uLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxyXG4gICAqL1xyXG4gIHVwZGF0ZSAoc3BlZWQpIHtcclxuICAgIGlmICghdGhpcy5yZW1vdmUpIHtcclxuICAgICAgaWYgKHRoaXMuc3ByaXRlQ29uZmlnLkZJWEVEKSB7XHJcbiAgICAgICAgdGhpcy5hbmltVGltZXIgKz0gc3BlZWRcclxuICAgICAgICBpZiAodGhpcy5hbmltVGltZXIgPiBCYWNrZ3JvdW5kRWwuY29uZmlnLk1TX1BFUl9GUkFNRSkge1xyXG4gICAgICAgICAgdGhpcy5hbmltVGltZXIgPSAwXHJcbiAgICAgICAgICB0aGlzLnN3aXRjaEZyYW1lcyA9ICF0aGlzLnN3aXRjaEZyYW1lc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3ByaXRlQ29uZmlnLkZJWEVEX1lfUE9TXzEgJiZcclxuICAgICAgICAgIHRoaXMuc3ByaXRlQ29uZmlnLkZJWEVEX1lfUE9TXzIpIHtcclxuICAgICAgICAgIHRoaXMueVBvcyA9IHRoaXMuc3dpdGNoRnJhbWVzXHJcbiAgICAgICAgICAgID8gdGhpcy5zcHJpdGVDb25maWcuRklYRURfWV9QT1NfMVxyXG4gICAgICAgICAgICA6IHRoaXMuc3ByaXRlQ29uZmlnLkZJWEVEX1lfUE9TXzJcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRml4ZWQgc3BlZWQsIHJlZ2FyZGxlc3Mgb2YgYWN0dWFsIGdhbWUgc3BlZWQuXHJcbiAgICAgICAgdGhpcy54UG9zIC09IEJhY2tncm91bmRFbC5jb25maWcuU1BFRURcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRyYXcoKVxyXG5cclxuICAgICAgLy8gTWFyayBhcyByZW1vdmFibGUgaWYgbm8gbG9uZ2VyIGluIHRoZSBjYW52YXMuXHJcbiAgICAgIGlmICghdGhpcy5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlID0gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvbiB0aGUgc3RhZ2UuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBpc1Zpc2libGUgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMueFBvcyArIHRoaXMuc3ByaXRlQ29uZmlnLldJRFRIID4gMFxyXG4gIH1cclxufVxyXG5cclxuLy8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4vKipcclxuICogTmlnaHRtb2RlIHNob3dzIGEgbW9vbiBhbmQgc3RhcnMgb24gdGhlIGhvcml6b24uXHJcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gc3ByaXRlUG9zXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250YWluZXJXaWR0aFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE5pZ2h0TW9kZSAoY2FudmFzLCBzcHJpdGVQb3MsIGNvbnRhaW5lcldpZHRoKSB7XHJcbiAgdGhpcy5zcHJpdGVQb3MgPSBzcHJpdGVQb3NcclxuICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xyXG4gIHRoaXMuY2FudmFzQ3R4ID1cclxuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoY2FudmFzLmdldENvbnRleHQoJzJkJykpXHJcbiAgdGhpcy54UG9zID0gY29udGFpbmVyV2lkdGggLSA1MFxyXG4gIHRoaXMueVBvcyA9IDMwXHJcbiAgdGhpcy5jdXJyZW50UGhhc2UgPSAwXHJcbiAgdGhpcy5vcGFjaXR5ID0gMFxyXG4gIHRoaXMuY29udGFpbmVyV2lkdGggPSBjb250YWluZXJXaWR0aFxyXG4gIHRoaXMuc3RhcnMgPSBbXVxyXG4gIHRoaXMuZHJhd1N0YXJzID0gZmFsc2VcclxuICB0aGlzLnBsYWNlU3RhcnMoKVxyXG59XHJcblxyXG4vKipcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbk5pZ2h0TW9kZS5jb25maWcgPSB7XHJcbiAgRkFERV9TUEVFRDogMC4wMzUsXHJcbiAgSEVJR0hUOiA0MCxcclxuICBNT09OX1NQRUVEOiAwLjI1LFxyXG4gIE5VTV9TVEFSUzogMixcclxuICBTVEFSX1NJWkU6IDksXHJcbiAgU1RBUl9TUEVFRDogMC4zLFxyXG4gIFNUQVJfTUFYX1k6IDcwLFxyXG4gIFdJRFRIOiAyMFxyXG59XHJcblxyXG5OaWdodE1vZGUucGhhc2VzID0gWzE0MCwgMTIwLCAxMDAsIDYwLCA0MCwgMjAsIDBdXHJcblxyXG5OaWdodE1vZGUucHJvdG90eXBlID0ge1xyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBtb3ZpbmcgbW9vbiwgY2hhbmdpbmcgcGhhc2VzLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZhdGVkIFdoZXRoZXIgbmlnaHQgbW9kZSBpcyBhY3RpdmF0ZWQuXHJcbiAgICovXHJcbiAgdXBkYXRlIChhY3RpdmF0ZWQpIHtcclxuICAgIC8vIE1vb24gcGhhc2UuXHJcbiAgICBpZiAoYWN0aXZhdGVkICYmIHRoaXMub3BhY2l0eSA9PT0gMCkge1xyXG4gICAgICB0aGlzLmN1cnJlbnRQaGFzZSsrXHJcblxyXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGhhc2UgPj0gTmlnaHRNb2RlLnBoYXNlcy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQaGFzZSA9IDBcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZhZGUgaW4gLyBvdXQuXHJcbiAgICBpZiAoYWN0aXZhdGVkICYmICh0aGlzLm9wYWNpdHkgPCAxIHx8IHRoaXMub3BhY2l0eSA9PT0gMCkpIHtcclxuICAgICAgdGhpcy5vcGFjaXR5ICs9IE5pZ2h0TW9kZS5jb25maWcuRkFERV9TUEVFRFxyXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wYWNpdHkgPiAwKSB7XHJcbiAgICAgIHRoaXMub3BhY2l0eSAtPSBOaWdodE1vZGUuY29uZmlnLkZBREVfU1BFRURcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgbW9vbiBwb3NpdGlvbmluZy5cclxuICAgIGlmICh0aGlzLm9wYWNpdHkgPiAwKSB7XHJcbiAgICAgIHRoaXMueFBvcyA9IHRoaXMudXBkYXRlWFBvcyh0aGlzLnhQb3MsIE5pZ2h0TW9kZS5jb25maWcuTU9PTl9TUEVFRClcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBzdGFycy5cclxuICAgICAgaWYgKHRoaXMuZHJhd1N0YXJzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOaWdodE1vZGUuY29uZmlnLk5VTV9TVEFSUzsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnN0YXJzW2ldLnggPVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVhQb3ModGhpcy5zdGFyc1tpXS54LCBOaWdodE1vZGUuY29uZmlnLlNUQVJfU1BFRUQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZHJhdygpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm9wYWNpdHkgPSAwXHJcbiAgICAgIHRoaXMucGxhY2VTdGFycygpXHJcbiAgICB9XHJcbiAgICB0aGlzLmRyYXdTdGFycyA9IHRydWVcclxuICB9LFxyXG5cclxuICB1cGRhdGVYUG9zIChjdXJyZW50UG9zLCBzcGVlZCkge1xyXG4gICAgaWYgKGN1cnJlbnRQb3MgPCAtTmlnaHRNb2RlLmNvbmZpZy5XSURUSCkge1xyXG4gICAgICBjdXJyZW50UG9zID0gdGhpcy5jb250YWluZXJXaWR0aFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3VycmVudFBvcyAtPSBzcGVlZFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cnJlbnRQb3NcclxuICB9LFxyXG5cclxuICBkcmF3ICgpIHtcclxuICAgIGxldCBtb29uU291cmNlV2lkdGggPSB0aGlzLmN1cnJlbnRQaGFzZSA9PT0gM1xyXG4gICAgICA/IE5pZ2h0TW9kZS5jb25maWcuV0lEVEggKiAyXHJcbiAgICAgIDogTmlnaHRNb2RlLmNvbmZpZy5XSURUSFxyXG4gICAgbGV0IG1vb25Tb3VyY2VIZWlnaHQgPSBOaWdodE1vZGUuY29uZmlnLkhFSUdIVFxyXG4gICAgbGV0IG1vb25Tb3VyY2VYID0gdGhpcy5zcHJpdGVQb3MueCArIE5pZ2h0TW9kZS5waGFzZXNbdGhpcy5jdXJyZW50UGhhc2VdXHJcbiAgICBjb25zdCBtb29uT3V0cHV0V2lkdGggPSBtb29uU291cmNlV2lkdGhcclxuICAgIGxldCBzdGFyU2l6ZSA9IE5pZ2h0TW9kZS5jb25maWcuU1RBUl9TSVpFXHJcbiAgICBsZXQgc3RhclNvdXJjZVggPSBSdW5uZXIuc3ByaXRlRGVmaW5pdGlvbkJ5VHlwZS5vcmlnaW5hbC5MRFBJLlNUQVIueFxyXG5cclxuICAgIGlmIChJU19ISURQSSkge1xyXG4gICAgICBtb29uU291cmNlV2lkdGggKj0gMlxyXG4gICAgICBtb29uU291cmNlSGVpZ2h0ICo9IDJcclxuICAgICAgbW9vblNvdXJjZVggPSB0aGlzLnNwcml0ZVBvcy54ICtcclxuICAgICAgICAoTmlnaHRNb2RlLnBoYXNlc1t0aGlzLmN1cnJlbnRQaGFzZV0gKiAyKVxyXG4gICAgICBzdGFyU2l6ZSAqPSAyXHJcbiAgICAgIHN0YXJTb3VyY2VYID0gUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGUub3JpZ2luYWwuSERQSS5TVEFSLnhcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNhbnZhc0N0eC5zYXZlKClcclxuICAgIHRoaXMuY2FudmFzQ3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5XHJcblxyXG4gICAgLy8gU3RhcnMuXHJcbiAgICBpZiAodGhpcy5kcmF3U3RhcnMpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOaWdodE1vZGUuY29uZmlnLk5VTV9TVEFSUzsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgUnVubmVyLm9yaWdJbWFnZVNwcml0ZSwgc3RhclNvdXJjZVgsIHRoaXMuc3RhcnNbaV0uc291cmNlWSxcclxuICAgICAgICAgIHN0YXJTaXplLCBzdGFyU2l6ZSwgTWF0aC5yb3VuZCh0aGlzLnN0YXJzW2ldLngpLCB0aGlzLnN0YXJzW2ldLnksXHJcbiAgICAgICAgICBOaWdodE1vZGUuY29uZmlnLlNUQVJfU0laRSwgTmlnaHRNb2RlLmNvbmZpZy5TVEFSX1NJWkUpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNb29uLlxyXG4gICAgdGhpcy5jYW52YXNDdHguZHJhd0ltYWdlKFxyXG4gICAgICBSdW5uZXIub3JpZ0ltYWdlU3ByaXRlLCBtb29uU291cmNlWCwgdGhpcy5zcHJpdGVQb3MueSwgbW9vblNvdXJjZVdpZHRoLFxyXG4gICAgICBtb29uU291cmNlSGVpZ2h0LCBNYXRoLnJvdW5kKHRoaXMueFBvcyksIHRoaXMueVBvcywgbW9vbk91dHB1dFdpZHRoLFxyXG4gICAgICBOaWdodE1vZGUuY29uZmlnLkhFSUdIVClcclxuXHJcbiAgICB0aGlzLmNhbnZhc0N0eC5nbG9iYWxBbHBoYSA9IDFcclxuICAgIHRoaXMuY2FudmFzQ3R4LnJlc3RvcmUoKVxyXG4gIH0sXHJcblxyXG4gIC8vIERvIHN0YXIgcGxhY2VtZW50LlxyXG4gIHBsYWNlU3RhcnMgKCkge1xyXG4gICAgY29uc3Qgc2VnbWVudFNpemUgPSBNYXRoLnJvdW5kKHRoaXMuY29udGFpbmVyV2lkdGggL1xyXG4gICAgICBOaWdodE1vZGUuY29uZmlnLk5VTV9TVEFSUylcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5pZ2h0TW9kZS5jb25maWcuTlVNX1NUQVJTOyBpKyspIHtcclxuICAgICAgdGhpcy5zdGFyc1tpXSA9IHt9XHJcbiAgICAgIHRoaXMuc3RhcnNbaV0ueCA9IGdldFJhbmRvbU51bShzZWdtZW50U2l6ZSAqIGksIHNlZ21lbnRTaXplICogKGkgKyAxKSlcclxuICAgICAgdGhpcy5zdGFyc1tpXS55ID0gZ2V0UmFuZG9tTnVtKDAsIE5pZ2h0TW9kZS5jb25maWcuU1RBUl9NQVhfWSlcclxuXHJcbiAgICAgIGlmIChJU19ISURQSSkge1xyXG4gICAgICAgIHRoaXMuc3RhcnNbaV0uc291cmNlWSA9XHJcbiAgICAgICAgICBSdW5uZXIuc3ByaXRlRGVmaW5pdGlvbkJ5VHlwZS5vcmlnaW5hbC5IRFBJLlNUQVIueSArXHJcbiAgICAgICAgICBOaWdodE1vZGUuY29uZmlnLlNUQVJfU0laRSAqIDIgKiBpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGFyc1tpXS5zb3VyY2VZID1cclxuICAgICAgICAgIFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uQnlUeXBlLm9yaWdpbmFsLkxEUEkuU1RBUi55ICtcclxuICAgICAgICAgIE5pZ2h0TW9kZS5jb25maWcuU1RBUl9TSVpFICogaVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgdGhpcy5jdXJyZW50UGhhc2UgPSAwXHJcbiAgICB0aGlzLm9wYWNpdHkgPSAwXHJcbiAgICB0aGlzLnVwZGF0ZShmYWxzZSlcclxuICB9XHJcblxyXG59XHJcblxyXG4vLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbi8qKlxyXG4gKiBIb3Jpem9uIExpbmUuXHJcbiAqIENvbnNpc3RzIG9mIHR3byBjb25uZWN0aW5nIGxpbmVzLiBSYW5kb21seSBhc3NpZ25zIGEgZmxhdCAvIGJ1bXB5IGhvcml6b24uXHJcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gbGluZUNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBIb3Jpem9uTGluZSAoY2FudmFzLCBsaW5lQ29uZmlnKSB7XHJcbiAgbGV0IHNvdXJjZVggPSBsaW5lQ29uZmlnLlNPVVJDRV9YXHJcbiAgbGV0IHNvdXJjZVkgPSBsaW5lQ29uZmlnLlNPVVJDRV9ZXHJcblxyXG4gIGlmIChJU19ISURQSSkge1xyXG4gICAgc291cmNlWCAqPSAyXHJcbiAgICBzb3VyY2VZICo9IDJcclxuICB9XHJcblxyXG4gIHRoaXMuc3ByaXRlUG9zID0geyB4OiBzb3VyY2VYLCB5OiBzb3VyY2VZIH1cclxuICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xyXG4gIHRoaXMuY2FudmFzQ3R4ID1cclxuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoY2FudmFzLmdldENvbnRleHQoJzJkJykpXHJcbiAgdGhpcy5zb3VyY2VEaW1lbnNpb25zID0ge31cclxuICB0aGlzLmRpbWVuc2lvbnMgPSBsaW5lQ29uZmlnXHJcblxyXG4gIHRoaXMuc291cmNlWFBvcyA9IFt0aGlzLnNwcml0ZVBvcy54LCB0aGlzLnNwcml0ZVBvcy54ICtcclxuICB0aGlzLmRpbWVuc2lvbnMuV0lEVEhdXHJcbiAgdGhpcy54UG9zID0gW11cclxuICB0aGlzLnlQb3MgPSAwXHJcbiAgdGhpcy5idW1wVGhyZXNob2xkID0gMC41XHJcblxyXG4gIHRoaXMuc2V0U291cmNlRGltZW5zaW9ucyhsaW5lQ29uZmlnKVxyXG4gIHRoaXMuZHJhdygpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIb3Jpem9uIGxpbmUgZGltZW5zaW9ucy5cclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbkhvcml6b25MaW5lLmRpbWVuc2lvbnMgPSB7XHJcbiAgV0lEVEg6IDYwMCxcclxuICBIRUlHSFQ6IDEyLFxyXG4gIFlQT1M6IDEyN1xyXG59XHJcblxyXG5Ib3Jpem9uTGluZS5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzb3VyY2UgZGltZW5zaW9ucyBvZiB0aGUgaG9yaXpvbiBsaW5lLlxyXG4gICAqL1xyXG4gIHNldFNvdXJjZURpbWVuc2lvbnMgKG5ld0RpbWVuc2lvbnMpIHtcclxuICAgIGZvciAoY29uc3QgZGltZW5zaW9uIGluIG5ld0RpbWVuc2lvbnMpIHtcclxuICAgICAgaWYgKGRpbWVuc2lvbiAhPT0gJ1NPVVJDRV9YJyAmJiBkaW1lbnNpb24gIT09ICdTT1VSQ0VfWScpIHtcclxuICAgICAgICBpZiAoSVNfSElEUEkpIHtcclxuICAgICAgICAgIGlmIChkaW1lbnNpb24gIT09ICdZUE9TJykge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZURpbWVuc2lvbnNbZGltZW5zaW9uXSA9IG5ld0RpbWVuc2lvbnNbZGltZW5zaW9uXSAqIDJcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5zb3VyY2VEaW1lbnNpb25zW2RpbWVuc2lvbl0gPSBuZXdEaW1lbnNpb25zW2RpbWVuc2lvbl1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zW2RpbWVuc2lvbl0gPSBuZXdEaW1lbnNpb25zW2RpbWVuc2lvbl1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMueFBvcyA9IFswLCBuZXdEaW1lbnNpb25zLldJRFRIXVxyXG4gICAgdGhpcy55UG9zID0gbmV3RGltZW5zaW9ucy5ZUE9TXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBjcm9wIHggcG9zaXRpb24gb2YgYSB0eXBlLlxyXG4gICAqL1xyXG4gIGdldFJhbmRvbVR5cGUgKCkge1xyXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPiB0aGlzLmJ1bXBUaHJlc2hvbGQgPyB0aGlzLmRpbWVuc2lvbnMuV0lEVEggOiAwXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhdyB0aGUgaG9yaXpvbiBsaW5lLlxyXG4gICAqL1xyXG4gIGRyYXcgKCkge1xyXG4gICAgdGhpcy5jYW52YXNDdHguZHJhd0ltYWdlKFJ1bm5lci5pbWFnZVNwcml0ZSwgdGhpcy5zb3VyY2VYUG9zWzBdLFxyXG4gICAgICB0aGlzLnNwcml0ZVBvcy55LFxyXG4gICAgICB0aGlzLnNvdXJjZURpbWVuc2lvbnMuV0lEVEgsIHRoaXMuc291cmNlRGltZW5zaW9ucy5IRUlHSFQsXHJcbiAgICAgIHRoaXMueFBvc1swXSwgdGhpcy55UG9zLFxyXG4gICAgICB0aGlzLmRpbWVuc2lvbnMuV0lEVEgsIHRoaXMuZGltZW5zaW9ucy5IRUlHSFQpXHJcblxyXG4gICAgdGhpcy5jYW52YXNDdHguZHJhd0ltYWdlKFJ1bm5lci5pbWFnZVNwcml0ZSwgdGhpcy5zb3VyY2VYUG9zWzFdLFxyXG4gICAgICB0aGlzLnNwcml0ZVBvcy55LFxyXG4gICAgICB0aGlzLnNvdXJjZURpbWVuc2lvbnMuV0lEVEgsIHRoaXMuc291cmNlRGltZW5zaW9ucy5IRUlHSFQsXHJcbiAgICAgIHRoaXMueFBvc1sxXSwgdGhpcy55UG9zLFxyXG4gICAgICB0aGlzLmRpbWVuc2lvbnMuV0lEVEgsIHRoaXMuZGltZW5zaW9ucy5IRUlHSFQpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSB4IHBvc2l0aW9uIG9mIGFuIGluZGl2ZHVhbCBwaWVjZSBvZiB0aGUgbGluZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zIExpbmUgcG9zaXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluY3JlbWVudFxyXG4gICAqL1xyXG4gIHVwZGF0ZVhQb3MgKHBvcywgaW5jcmVtZW50KSB7XHJcbiAgICBjb25zdCBsaW5lMSA9IHBvc1xyXG4gICAgY29uc3QgbGluZTIgPSBwb3MgPT09IDAgPyAxIDogMFxyXG5cclxuICAgIHRoaXMueFBvc1tsaW5lMV0gLT0gaW5jcmVtZW50XHJcbiAgICB0aGlzLnhQb3NbbGluZTJdID0gdGhpcy54UG9zW2xpbmUxXSArIHRoaXMuZGltZW5zaW9ucy5XSURUSFxyXG5cclxuICAgIGlmICh0aGlzLnhQb3NbbGluZTFdIDw9IC10aGlzLmRpbWVuc2lvbnMuV0lEVEgpIHtcclxuICAgICAgdGhpcy54UG9zW2xpbmUxXSArPSB0aGlzLmRpbWVuc2lvbnMuV0lEVEggKiAyXHJcbiAgICAgIHRoaXMueFBvc1tsaW5lMl0gPSB0aGlzLnhQb3NbbGluZTFdIC0gdGhpcy5kaW1lbnNpb25zLldJRFRIXHJcbiAgICAgIHRoaXMuc291cmNlWFBvc1tsaW5lMV0gPSB0aGlzLmdldFJhbmRvbVR5cGUoKSArIHRoaXMuc3ByaXRlUG9zLnhcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGhvcml6b24gbGluZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXHJcbiAgICovXHJcbiAgdXBkYXRlIChkZWx0YVRpbWUsIHNwZWVkKSB7XHJcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKHNwZWVkICogKEZQUyAvIDEwMDApICogZGVsdGFUaW1lKVxyXG5cclxuICAgIGlmICh0aGlzLnhQb3NbMF0gPD0gMCkge1xyXG4gICAgICB0aGlzLnVwZGF0ZVhQb3MoMCwgaW5jcmVtZW50KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy51cGRhdGVYUG9zKDEsIGluY3JlbWVudClcclxuICAgIH1cclxuICAgIHRoaXMuZHJhdygpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgaG9yaXpvbiB0byB0aGUgc3RhcnRpbmcgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgdGhpcy54UG9zWzBdID0gMFxyXG4gICAgdGhpcy54UG9zWzFdID0gdGhpcy5kaW1lbnNpb25zLldJRFRIXHJcbiAgfVxyXG59XHJcblxyXG4vLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbi8qKlxyXG4gKiBIb3Jpem9uIGJhY2tncm91bmQgY2xhc3MuXHJcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gc3ByaXRlUG9zIFNwcml0ZSBwb3NpdGlvbmluZy5cclxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnMgQ2FudmFzIGRpbWVuc2lvbnMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBnYXBDb2VmZmljaWVudFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEhvcml6b24gKGNhbnZhcywgc3ByaXRlUG9zLCBkaW1lbnNpb25zLCBnYXBDb2VmZmljaWVudCkge1xyXG4gIHRoaXMuY2FudmFzID0gY2FudmFzXHJcbiAgdGhpcy5jYW52YXNDdHggPVxyXG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovICh0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKVxyXG4gIHRoaXMuY29uZmlnID0gSG9yaXpvbi5jb25maWdcclxuICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25zXHJcbiAgdGhpcy5nYXBDb2VmZmljaWVudCA9IGdhcENvZWZmaWNpZW50XHJcbiAgdGhpcy5vYnN0YWNsZXMgPSBbXVxyXG4gIHRoaXMub2JzdGFjbGVIaXN0b3J5ID0gW11cclxuICB0aGlzLmhvcml6b25PZmZzZXRzID0gWzAsIDBdXHJcbiAgdGhpcy5jbG91ZEZyZXF1ZW5jeSA9IHRoaXMuY29uZmlnLkNMT1VEX0ZSRVFVRU5DWVxyXG4gIHRoaXMuc3ByaXRlUG9zID0gc3ByaXRlUG9zXHJcbiAgdGhpcy5uaWdodE1vZGUgPSBudWxsXHJcbiAgdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSA9IGZhbHNlXHJcblxyXG4gIC8vIENsb3VkXHJcbiAgdGhpcy5jbG91ZHMgPSBbXVxyXG4gIHRoaXMuY2xvdWRTcGVlZCA9IHRoaXMuY29uZmlnLkJHX0NMT1VEX1NQRUVEXHJcblxyXG4gIC8vIEJhY2tncm91bmQgZWxlbWVudHNcclxuICB0aGlzLmJhY2tncm91bmRFbHMgPSBbXVxyXG4gIHRoaXMubGFzdEVsID0gbnVsbFxyXG4gIHRoaXMuYmFja2dyb3VuZFNwZWVkID0gdGhpcy5jb25maWcuQkdfQ0xPVURfU1BFRURcclxuXHJcbiAgLy8gSG9yaXpvblxyXG4gIHRoaXMuaG9yaXpvbkxpbmUgPSBudWxsXHJcbiAgdGhpcy5ob3Jpem9uTGluZXMgPSBbXVxyXG4gIHRoaXMuaW5pdCgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIb3Jpem9uIGNvbmZpZy5cclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbkhvcml6b24uY29uZmlnID0ge1xyXG4gIEJHX0NMT1VEX1NQRUVEOiAwLjIsXHJcbiAgQlVNUFlfVEhSRVNIT0xEOiAwLjMsXHJcbiAgQ0xPVURfRlJFUVVFTkNZOiAwLjUsXHJcbiAgSE9SSVpPTl9IRUlHSFQ6IDE2LFxyXG4gIE1BWF9DTE9VRFM6IDZcclxufVxyXG5cclxuSG9yaXpvbi5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGlzZSB0aGUgaG9yaXpvbi4gSnVzdCBhZGQgdGhlIGxpbmUgYW5kIGEgY2xvdWQuIE5vIG9ic3RhY2xlcy5cclxuICAgKi9cclxuICBpbml0ICgpIHtcclxuICAgIE9ic3RhY2xlLnR5cGVzID0gUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGUub3JpZ2luYWwuT0JTVEFDTEVTXHJcbiAgICB0aGlzLmFkZENsb3VkKClcclxuICAgIC8vIE11bHRpcGxlIEhvcml6b24gbGluZXNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUnVubmVyLnNwcml0ZURlZmluaXRpb24uTElORVMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5ob3Jpem9uTGluZXMucHVzaChcclxuICAgICAgICBuZXcgSG9yaXpvbkxpbmUodGhpcy5jYW52YXMsIFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLkxJTkVTW2ldKSlcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm5pZ2h0TW9kZSA9IG5ldyBOaWdodE1vZGUodGhpcy5jYW52YXMsIHRoaXMuc3ByaXRlUG9zLk1PT04sXHJcbiAgICAgIHRoaXMuZGltZW5zaW9ucy5XSURUSClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgb2JzdGFjbGUgZGVmaW5pdGlvbnMgYmFzZWQgb24gdGhlIHNwZWVkIG9mIHRoZSBnYW1lLlxyXG4gICAqL1xyXG4gIGFkanVzdE9ic3RhY2xlU3BlZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgT2JzdGFjbGUudHlwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKFJ1bm5lci5zbG93RG93bikge1xyXG4gICAgICAgIE9ic3RhY2xlLnR5cGVzW2ldLm11bHRpcGxlU3BlZWQgPSBPYnN0YWNsZS50eXBlc1tpXS5tdWx0aXBsZVNwZWVkIC8gMlxyXG4gICAgICAgIE9ic3RhY2xlLnR5cGVzW2ldLm1pbkdhcCAqPSAxLjVcclxuICAgICAgICBPYnN0YWNsZS50eXBlc1tpXS5taW5TcGVlZCA9IE9ic3RhY2xlLnR5cGVzW2ldLm1pblNwZWVkIC8gMlxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHZhcmlhYmxlIHkgcG9zaXRpb24gb2JzdGFjbGVzIHRvIGZpeGVkLlxyXG4gICAgICAgIGlmICh0eXBlb2YgKE9ic3RhY2xlLnR5cGVzW2ldLnlQb3MpID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgT2JzdGFjbGUudHlwZXNbaV0ueVBvcyA9IE9ic3RhY2xlLnR5cGVzW2ldLnlQb3NbMF1cclxuICAgICAgICAgIE9ic3RhY2xlLnR5cGVzW2ldLnlQb3NNb2JpbGUgPSBPYnN0YWNsZS50eXBlc1tpXS55UG9zWzBdXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHNwcml0ZXMgdG8gY29ycmVzcG9uZCB0byBjaGFuZ2UgaW4gc3ByaXRlIHNoZWV0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcHJpdGVQb3NcclxuICAgKi9cclxuICBlbmFibGVBbHRHYW1lTW9kZTogZnVuY3Rpb24gKHNwcml0ZVBvcykge1xyXG4gICAgLy8gQ2xlYXIgZXhpc3RpbmcgaG9yaXpvbiBvYmplY3RzLlxyXG4gICAgdGhpcy5jbG91ZHMgPSBbXVxyXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxzID0gW11cclxuXHJcbiAgICB0aGlzLmFsdEdhbWVNb2RlQWN0aXZlID0gdHJ1ZVxyXG4gICAgdGhpcy5zcHJpdGVQb3MgPSBzcHJpdGVQb3NcclxuXHJcbiAgICBPYnN0YWNsZS50eXBlcyA9IFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLk9CU1RBQ0xFU1xyXG4gICAgdGhpcy5hZGp1c3RPYnN0YWNsZVNwZWVkKClcclxuXHJcbiAgICBPYnN0YWNsZS5NQVhfR0FQX0NPRUZGSUNJRU5UID0gUnVubmVyLnNwcml0ZURlZmluaXRpb24uTUFYX0dBUF9DT0VGRklDSUVOVFxyXG4gICAgT2JzdGFjbGUuTUFYX09CU1RBQ0xFX0xFTkdUSCA9IFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLk1BWF9PQlNUQUNMRV9MRU5HVEhcclxuXHJcbiAgICBCYWNrZ3JvdW5kRWwuY29uZmlnID0gUnVubmVyLnNwcml0ZURlZmluaXRpb24uQkFDS0dST1VORF9FTF9DT05GSUdcclxuXHJcbiAgICB0aGlzLmhvcml6b25MaW5lcyA9IFtdXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLkxJTkVTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRoaXMuaG9yaXpvbkxpbmVzLnB1c2goXHJcbiAgICAgICAgbmV3IEhvcml6b25MaW5lKHRoaXMuY2FudmFzLCBSdW5uZXIuc3ByaXRlRGVmaW5pdGlvbi5MSU5FU1tpXSkpXHJcbiAgICB9XHJcbiAgICB0aGlzLnJlc2V0KClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRTcGVlZFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlT2JzdGFjbGVzIFVzZWQgYXMgYW4gb3ZlcnJpZGUgdG8gcHJldmVudFxyXG4gICAqICAgICB0aGUgb2JzdGFjbGVzIGZyb20gYmVpbmcgdXBkYXRlZCAvIGFkZGVkLiBUaGlzIGhhcHBlbnMgaW4gdGhlXHJcbiAgICogICAgIGVhc2UgaW4gc2VjdGlvbi5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dOaWdodE1vZGUgTmlnaHQgbW9kZSBhY3RpdmF0ZWQuXHJcbiAgICovXHJcbiAgdXBkYXRlIChkZWx0YVRpbWUsIGN1cnJlbnRTcGVlZCwgdXBkYXRlT2JzdGFjbGVzLCBzaG93TmlnaHRNb2RlKSB7XHJcbiAgICB0aGlzLnJ1bm5pbmdUaW1lICs9IGRlbHRhVGltZVxyXG5cclxuICAgIGlmICh0aGlzLmFsdEdhbWVNb2RlQWN0aXZlKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZEVscyhkZWx0YVRpbWUsIGN1cnJlbnRTcGVlZClcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaG9yaXpvbkxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRoaXMuaG9yaXpvbkxpbmVzW2ldLnVwZGF0ZShkZWx0YVRpbWUsIGN1cnJlbnRTcGVlZClcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuYWx0R2FtZU1vZGVBY3RpdmUgfHwgUnVubmVyLnNwcml0ZURlZmluaXRpb24uSEFTX0NMT1VEUykge1xyXG4gICAgICB0aGlzLm5pZ2h0TW9kZS51cGRhdGUoc2hvd05pZ2h0TW9kZSlcclxuICAgICAgdGhpcy51cGRhdGVDbG91ZHMoZGVsdGFUaW1lLCBjdXJyZW50U3BlZWQpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwZGF0ZU9ic3RhY2xlcykge1xyXG4gICAgICB0aGlzLnVwZGF0ZU9ic3RhY2xlcyhkZWx0YVRpbWUsIGN1cnJlbnRTcGVlZClcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYmFja2dyb3VuZCBlbGVtZW50IHBvc2l0aW9ucy4gQWxzbyBoYW5kbGVzIGNyZWF0aW5nIG5ldyBlbGVtZW50cy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZWxTcGVlZFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gYmdFbEFycmF5XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heEJnRWxcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiZ0VsQWRkRnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJlcXVlbmN5XHJcbiAgICovXHJcbiAgdXBkYXRlQmFja2dyb3VuZEVsIChlbFNwZWVkLCBiZ0VsQXJyYXksIG1heEJnRWwsIGJnRWxBZGRGdW5jdGlvbiwgZnJlcXVlbmN5KSB7XHJcbiAgICBjb25zdCBudW1FbGVtZW50cyA9IGJnRWxBcnJheS5sZW5ndGhcclxuXHJcbiAgICBpZiAobnVtRWxlbWVudHMpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IG51bUVsZW1lbnRzIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBiZ0VsQXJyYXlbaV0udXBkYXRlKGVsU3BlZWQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGxhc3RFbCA9IGJnRWxBcnJheVtudW1FbGVtZW50cyAtIDFdXHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgYWRkaW5nIGEgbmV3IGVsZW1lbnQuXHJcbiAgICAgIGlmIChudW1FbGVtZW50cyA8IG1heEJnRWwgJiZcclxuICAgICAgICAodGhpcy5kaW1lbnNpb25zLldJRFRIIC0gbGFzdEVsLnhQb3MpID4gbGFzdEVsLmdhcCAmJlxyXG4gICAgICAgIGZyZXF1ZW5jeSA+IE1hdGgucmFuZG9tKCkpIHtcclxuICAgICAgICBiZ0VsQWRkRnVuY3Rpb24oKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiZ0VsQWRkRnVuY3Rpb24oKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgY2xvdWQgcG9zaXRpb25zLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWRcclxuICAgKi9cclxuICB1cGRhdGVDbG91ZHMgKGRlbHRhVGltZSwgc3BlZWQpIHtcclxuICAgIGNvbnN0IGVsU3BlZWQgPSB0aGlzLmNsb3VkU3BlZWQgLyAxMDAwICogZGVsdGFUaW1lICogc3BlZWRcclxuICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZEVsKFxyXG4gICAgICBlbFNwZWVkLCB0aGlzLmNsb3VkcywgdGhpcy5jb25maWcuTUFYX0NMT1VEUywgdGhpcy5hZGRDbG91ZC5iaW5kKHRoaXMpLFxyXG4gICAgICB0aGlzLmNsb3VkRnJlcXVlbmN5KVxyXG5cclxuICAgIC8vIFJlbW92ZSBleHBpcmVkIGVsZW1lbnRzLlxyXG4gICAgdGhpcy5jbG91ZHMgPSB0aGlzLmNsb3Vkcy5maWx0ZXIoKG9iaikgPT4gIW9iai5yZW1vdmUpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBiYWNrZ3JvdW5kIGVsZW1lbnQgcG9zaXRpb25zLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWRcclxuICAgKi9cclxuICB1cGRhdGVCYWNrZ3JvdW5kRWxzIChkZWx0YVRpbWUsIHNwZWVkKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUJhY2tncm91bmRFbChcclxuICAgICAgZGVsdGFUaW1lLCB0aGlzLmJhY2tncm91bmRFbHMsIEJhY2tncm91bmRFbC5jb25maWcuTUFYX0JHX0VMUyxcclxuICAgICAgdGhpcy5hZGRCYWNrZ3JvdW5kRWwuYmluZCh0aGlzKSwgdGhpcy5jbG91ZEZyZXF1ZW5jeSlcclxuXHJcbiAgICAvLyBSZW1vdmUgZXhwaXJlZCBlbGVtZW50cy5cclxuICAgIHRoaXMuYmFja2dyb3VuZEVscyA9IHRoaXMuYmFja2dyb3VuZEVscy5maWx0ZXIoKG9iaikgPT4gIW9iai5yZW1vdmUpXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBvYnN0YWNsZSBwb3NpdGlvbnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50U3BlZWRcclxuICAgKi9cclxuICB1cGRhdGVPYnN0YWNsZXMgKGRlbHRhVGltZSwgY3VycmVudFNwZWVkKSB7XHJcbiAgICBjb25zdCB1cGRhdGVkT2JzdGFjbGVzID0gdGhpcy5vYnN0YWNsZXMuc2xpY2UoMClcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub2JzdGFjbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IG9ic3RhY2xlID0gdGhpcy5vYnN0YWNsZXNbaV1cclxuICAgICAgb2JzdGFjbGUudXBkYXRlKGRlbHRhVGltZSwgY3VycmVudFNwZWVkKVxyXG5cclxuICAgICAgLy8gQ2xlYW4gdXAgZXhpc3Rpbmcgb2JzdGFjbGVzLlxyXG4gICAgICBpZiAob2JzdGFjbGUucmVtb3ZlKSB7XHJcbiAgICAgICAgdXBkYXRlZE9ic3RhY2xlcy5zaGlmdCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMub2JzdGFjbGVzID0gdXBkYXRlZE9ic3RhY2xlc1xyXG5cclxuICAgIGlmICh0aGlzLm9ic3RhY2xlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGxhc3RPYnN0YWNsZSA9IHRoaXMub2JzdGFjbGVzW3RoaXMub2JzdGFjbGVzLmxlbmd0aCAtIDFdXHJcblxyXG4gICAgICBpZiAobGFzdE9ic3RhY2xlICYmICFsYXN0T2JzdGFjbGUuZm9sbG93aW5nT2JzdGFjbGVDcmVhdGVkICYmXHJcbiAgICAgICAgbGFzdE9ic3RhY2xlLmlzVmlzaWJsZSgpICYmXHJcbiAgICAgICAgKGxhc3RPYnN0YWNsZS54UG9zICsgbGFzdE9ic3RhY2xlLndpZHRoICsgbGFzdE9ic3RhY2xlLmdhcCkgPFxyXG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5XSURUSCkge1xyXG4gICAgICAgIHRoaXMuYWRkTmV3T2JzdGFjbGUoY3VycmVudFNwZWVkKVxyXG4gICAgICAgIGxhc3RPYnN0YWNsZS5mb2xsb3dpbmdPYnN0YWNsZUNyZWF0ZWQgPSB0cnVlXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENyZWF0ZSBuZXcgb2JzdGFjbGVzLlxyXG4gICAgICB0aGlzLmFkZE5ld09ic3RhY2xlKGN1cnJlbnRTcGVlZClcclxuICAgIH1cclxuICB9LFxyXG5cclxuICByZW1vdmVGaXJzdE9ic3RhY2xlICgpIHtcclxuICAgIHRoaXMub2JzdGFjbGVzLnNoaWZ0KClcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBuZXcgb2JzdGFjbGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRTcGVlZFxyXG4gICAqL1xyXG4gIGFkZE5ld09ic3RhY2xlIChjdXJyZW50U3BlZWQpIHtcclxuICAgIGNvbnN0IG9ic3RhY2xlQ291bnQgPVxyXG4gICAgICBPYnN0YWNsZS50eXBlc1tPYnN0YWNsZS50eXBlcy5sZW5ndGggLSAxXS50eXBlICE9ICdDT0xMRUNUQUJMRScgfHxcclxuICAgICAgKFJ1bm5lci5pc0FsdEdhbWVNb2RlRW5hYmxlZCgpICYmICF0aGlzLmFsdEdhbWVNb2RlQWN0aXZlIHx8XHJcbiAgICAgICAgdGhpcy5hbHRHYW1lTW9kZUFjdGl2ZSlcclxuICAgICAgICA/IE9ic3RhY2xlLnR5cGVzLmxlbmd0aCAtIDFcclxuICAgICAgICA6IE9ic3RhY2xlLnR5cGVzLmxlbmd0aCAtIDJcclxuICAgIGNvbnN0IG9ic3RhY2xlVHlwZUluZGV4ID1cclxuICAgICAgb2JzdGFjbGVDb3VudCA+IDAgPyBnZXRSYW5kb21OdW0oMCwgb2JzdGFjbGVDb3VudCkgOiAwXHJcbiAgICBjb25zdCBvYnN0YWNsZVR5cGUgPSBPYnN0YWNsZS50eXBlc1tvYnN0YWNsZVR5cGVJbmRleF1cclxuXHJcbiAgICAvLyBDaGVjayBmb3IgbXVsdGlwbGVzIG9mIHRoZSBzYW1lIHR5cGUgb2Ygb2JzdGFjbGUuXHJcbiAgICAvLyBBbHNvIGNoZWNrIG9ic3RhY2xlIGlzIGF2YWlsYWJsZSBhdCBjdXJyZW50IHNwZWVkLlxyXG4gICAgaWYgKChvYnN0YWNsZUNvdW50ID4gMCAmJiB0aGlzLmR1cGxpY2F0ZU9ic3RhY2xlQ2hlY2sob2JzdGFjbGVUeXBlLnR5cGUpKSB8fFxyXG4gICAgICBjdXJyZW50U3BlZWQgPCBvYnN0YWNsZVR5cGUubWluU3BlZWQpIHtcclxuICAgICAgdGhpcy5hZGROZXdPYnN0YWNsZShjdXJyZW50U3BlZWQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBvYnN0YWNsZVNwcml0ZVBvcyA9IHRoaXMuc3ByaXRlUG9zW29ic3RhY2xlVHlwZS50eXBlXVxyXG5cclxuICAgICAgdGhpcy5vYnN0YWNsZXMucHVzaChuZXcgT2JzdGFjbGUoXHJcbiAgICAgICAgdGhpcy5jYW52YXNDdHgsIG9ic3RhY2xlVHlwZSwgb2JzdGFjbGVTcHJpdGVQb3MsIHRoaXMuZGltZW5zaW9ucyxcclxuICAgICAgICB0aGlzLmdhcENvZWZmaWNpZW50LCBjdXJyZW50U3BlZWQsIG9ic3RhY2xlVHlwZS53aWR0aCxcclxuICAgICAgICB0aGlzLmFsdEdhbWVNb2RlQWN0aXZlKSlcclxuXHJcbiAgICAgIHRoaXMub2JzdGFjbGVIaXN0b3J5LnVuc2hpZnQob2JzdGFjbGVUeXBlLnR5cGUpXHJcblxyXG4gICAgICBpZiAodGhpcy5vYnN0YWNsZUhpc3RvcnkubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHRoaXMub2JzdGFjbGVIaXN0b3J5LnNwbGljZShSdW5uZXIuY29uZmlnLk1BWF9PQlNUQUNMRV9EVVBMSUNBVElPTilcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJldmlvdXMgdHdvIG9ic3RhY2xlcyBhcmUgdGhlIHNhbWUgYXMgdGhlIG5leHQgb25lLlxyXG4gICAqIE1heGltdW0gZHVwbGljYXRpb24gaXMgc2V0IGluIGNvbmZpZyB2YWx1ZSBNQVhfT0JTVEFDTEVfRFVQTElDQVRJT04uXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBkdXBsaWNhdGVPYnN0YWNsZUNoZWNrIChuZXh0T2JzdGFjbGVUeXBlKSB7XHJcbiAgICBsZXQgZHVwbGljYXRlQ291bnQgPSAwXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic3RhY2xlSGlzdG9yeS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkdXBsaWNhdGVDb3VudCA9XHJcbiAgICAgICAgdGhpcy5vYnN0YWNsZUhpc3RvcnlbaV0gPT09IG5leHRPYnN0YWNsZVR5cGUgPyBkdXBsaWNhdGVDb3VudCArIDEgOiAwXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHVwbGljYXRlQ291bnQgPj0gUnVubmVyLmNvbmZpZy5NQVhfT0JTVEFDTEVfRFVQTElDQVRJT05cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgaG9yaXpvbiBsYXllci5cclxuICAgKiBSZW1vdmUgZXhpc3Rpbmcgb2JzdGFjbGVzIGFuZCByZXBvc2l0aW9uIHRoZSBob3Jpem9uIGxpbmUuXHJcbiAgICovXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgdGhpcy5vYnN0YWNsZXMgPSBbXVxyXG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCB0aGlzLmhvcml6b25MaW5lcy5sZW5ndGg7IGwrKykge1xyXG4gICAgICB0aGlzLmhvcml6b25MaW5lc1tsXS5yZXNldCgpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5uaWdodE1vZGUucmVzZXQoKVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgY2FudmFzIHdpZHRoIGFuZCBzY2FsaW5nLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBDYW52YXMgd2lkdGguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBDYW52YXMgaGVpZ2h0LlxyXG4gICAqL1xyXG4gIHJlc2l6ZSAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aFxyXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IGNsb3VkIHRvIHRoZSBob3Jpem9uLlxyXG4gICAqL1xyXG4gIGFkZENsb3VkICgpIHtcclxuICAgIHRoaXMuY2xvdWRzLnB1c2gobmV3IENsb3VkKHRoaXMuY2FudmFzLCB0aGlzLnNwcml0ZVBvcy5DTE9VRCxcclxuICAgICAgdGhpcy5kaW1lbnNpb25zLldJRFRIKSlcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSByYW5kb20gYmFja2dyb3VuZCBlbGVtZW50IHRvIHRoZSBob3Jpem9uLlxyXG4gICAqL1xyXG4gIGFkZEJhY2tncm91bmRFbCAoKSB7XHJcbiAgICBjb25zdCBiYWNrZ3JvdW5kRWxUeXBlcyA9XHJcbiAgICAgIE9iamVjdC5rZXlzKFJ1bm5lci5zcHJpdGVEZWZpbml0aW9uLkJBQ0tHUk9VTkRfRUwpXHJcblxyXG4gICAgaWYgKGJhY2tncm91bmRFbFR5cGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgbGV0IGluZGV4ID0gZ2V0UmFuZG9tTnVtKDAsIGJhY2tncm91bmRFbFR5cGVzLmxlbmd0aCAtIDEpXHJcbiAgICAgIGxldCB0eXBlID0gYmFja2dyb3VuZEVsVHlwZXNbaW5kZXhdXHJcblxyXG4gICAgICAvLyBBZGQgdmFyaWF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgICAgd2hpbGUgKHR5cGUgPT0gdGhpcy5sYXN0RWwgJiYgYmFja2dyb3VuZEVsVHlwZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGluZGV4ID0gZ2V0UmFuZG9tTnVtKDAsIGJhY2tncm91bmRFbFR5cGVzLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgdHlwZSA9IGJhY2tncm91bmRFbFR5cGVzW2luZGV4XVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmxhc3RFbCA9IHR5cGVcclxuICAgICAgdGhpcy5iYWNrZ3JvdW5kRWxzLnB1c2gobmV3IEJhY2tncm91bmRFbChcclxuICAgICAgICB0aGlzLmNhbnZhcywgdGhpcy5zcHJpdGVQb3MuQkFDS0dST1VORF9FTCwgdGhpcy5kaW1lbnNpb25zLldJRFRILFxyXG4gICAgICAgIHR5cGUpKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBDb2xsaXNpb25Cb3ggfSBmcm9tICcuL29mZmxpbmUnXHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMSBUaGUgQ2hyb21pdW0gQXV0aG9yc1xyXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXHJcblxyXG4vKiBAY29uc3RcclxuICogQWRkIG1hdGNoaW5nIHNwcml0ZSBkZWZpbml0aW9uIGFuZCBjb25maWcgdG8gUnVubmVyLnNwcml0ZURlZmluaXRpb25CeVR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgR0FNRV9UWVBFID0gW11cclxuXHJcbi8qKlxyXG4gKiBPYnN0YWNsZSBkZWZpbml0aW9ucy5cclxuICogbWluR2FwOiBtaW5pbXVtIHBpeGVsIHNwYWNlIGJldHdlZW4gb2JzdGFjbGVzLlxyXG4gKiBtdWx0aXBsZVNwZWVkOiBTcGVlZCBhdCB3aGljaCBtdWx0aXBsZXMgYXJlIGFsbG93ZWQuXHJcbiAqIHNwZWVkT2Zmc2V0OiBzcGVlZCBmYXN0ZXIgLyBzbG93ZXIgdGhhbiB0aGUgaG9yaXpvbi5cclxuICogbWluU3BlZWQ6IE1pbmltdW0gc3BlZWQgd2hpY2ggdGhlIG9ic3RhY2xlIGNhbiBtYWtlIGFuIGFwcGVhcmFuY2UuXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHt7XHJcbiAqICAgdHlwZTogc3RyaW5nLFxyXG4gKiAgIHdpZHRoOiBudW1iZXIsXHJcbiAqICAgaGVpZ2h0OiBudW1iZXIsXHJcbiAqICAgeVBvczogbnVtYmVyLFxyXG4gKiAgIG11bHRpcGxlU3BlZWQ6IG51bWJlcixcclxuICogICBtaW5HYXA6IG51bWJlcixcclxuICogICBtaW5TcGVlZDogbnVtYmVyLFxyXG4gKiAgIGNvbGxpc2lvbkJveGVzOiBBcnJheTxDb2xsaXNpb25Cb3g+LFxyXG4gKiB9fVxyXG4gKi9cclxuZXhwb3J0IGxldCBPYnN0YWNsZVR5cGVcclxuXHJcbi8qKlxyXG4gKiBULVJleCBydW5uZXIgc3ByaXRlIGRlZmluaXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNwcml0ZURlZmluaXRpb25CeVR5cGUgPSB7XHJcbiAgb3JpZ2luYWw6IHtcclxuICAgIExEUEk6IHtcclxuICAgICAgQkFDS0dST1VORF9FTDogeyB4OiA4NiwgeTogMiB9LFxyXG4gICAgICBDQUNUVVNfTEFSR0U6IHsgeDogMzMyLCB5OiAyIH0sXHJcbiAgICAgIENBQ1RVU19TTUFMTDogeyB4OiAyMjgsIHk6IDIgfSxcclxuICAgICAgT0JTVEFDTEVfMjogeyB4OiAzMzIsIHk6IDIgfSxcclxuICAgICAgT0JTVEFDTEU6IHsgeDogMjI4LCB5OiAyIH0sXHJcbiAgICAgIENMT1VEOiB7IHg6IDg2LCB5OiAyIH0sXHJcbiAgICAgIEhPUklaT046IHsgeDogMiwgeTogNTQgfSxcclxuICAgICAgTU9PTjogeyB4OiA0ODQsIHk6IDIgfSxcclxuICAgICAgUFRFUk9EQUNUWUw6IHsgeDogMTM0LCB5OiAyIH0sXHJcbiAgICAgIFJFU1RBUlQ6IHsgeDogMiwgeTogNjggfSxcclxuICAgICAgVEVYVF9TUFJJVEU6IHsgeDogNjU1LCB5OiAyIH0sXHJcbiAgICAgIFRSRVg6IHsgeDogODQ4LCB5OiAyIH0sXHJcbiAgICAgIFNUQVI6IHsgeDogNjQ1LCB5OiAyIH0sXHJcbiAgICAgIENPTExFQ1RBQkxFOiB7IHg6IDIsIHk6IDIgfSxcclxuICAgICAgQUxUX0dBTUVfRU5EOiB7IHg6IDEyMSwgeTogMiB9XHJcbiAgICB9LFxyXG4gICAgSERQSToge1xyXG4gICAgICBCQUNLR1JPVU5EX0VMOiB7IHg6IDE2NiwgeTogMiB9LFxyXG4gICAgICBDQUNUVVNfTEFSR0U6IHsgeDogNjUyLCB5OiAyIH0sXHJcbiAgICAgIENBQ1RVU19TTUFMTDogeyB4OiA0NDYsIHk6IDIgfSxcclxuICAgICAgT0JTVEFDTEVfMjogeyB4OiA2NTIsIHk6IDIgfSxcclxuICAgICAgT0JTVEFDTEU6IHsgeDogNDQ2LCB5OiAyIH0sXHJcbiAgICAgIENMT1VEOiB7IHg6IDE2NiwgeTogMiB9LFxyXG4gICAgICBIT1JJWk9OOiB7IHg6IDIsIHk6IDEwNCB9LFxyXG4gICAgICBNT09OOiB7IHg6IDk1NCwgeTogMiB9LFxyXG4gICAgICBQVEVST0RBQ1RZTDogeyB4OiAyNjAsIHk6IDIgfSxcclxuICAgICAgUkVTVEFSVDogeyB4OiAyLCB5OiAxMzAgfSxcclxuICAgICAgVEVYVF9TUFJJVEU6IHsgeDogMTI5NCwgeTogMiB9LFxyXG4gICAgICBUUkVYOiB7IHg6IDE2NzgsIHk6IDIgfSxcclxuICAgICAgU1RBUjogeyB4OiAxMjc2LCB5OiAyIH0sXHJcbiAgICAgIENPTExFQ1RBQkxFOiB7IHg6IDQsIHk6IDQgfSxcclxuICAgICAgQUxUX0dBTUVfRU5EOiB7IHg6IDI0MiwgeTogNCB9XHJcbiAgICB9LFxyXG4gICAgTUFYX0dBUF9DT0VGRklDSUVOVDogMS41LFxyXG4gICAgTUFYX09CU1RBQ0xFX0xFTkdUSDogMyxcclxuICAgIEhBU19DTE9VRFM6IDEsXHJcbiAgICBCT1RUT01fUEFEOiAxMCxcclxuICAgIFRSRVg6IHtcclxuICAgICAgV0FJVElOR18xOiB7IHg6IDQ0LCB3OiA0NCwgaDogNDcsIHhPZmZzZXQ6IDAgfSxcclxuICAgICAgV0FJVElOR18yOiB7IHg6IDAsIHc6IDQ0LCBoOiA0NywgeE9mZnNldDogMCB9LFxyXG4gICAgICBSVU5OSU5HXzE6IHsgeDogODgsIHc6IDQ0LCBoOiA0NywgeE9mZnNldDogMCB9LFxyXG4gICAgICBSVU5OSU5HXzI6IHsgeDogMTMyLCB3OiA0NCwgaDogNDcsIHhPZmZzZXQ6IDAgfSxcclxuICAgICAgSlVNUElORzogeyB4OiAwLCB3OiA0NCwgaDogNDcsIHhPZmZzZXQ6IDAgfSxcclxuICAgICAgQ1JBU0hFRDogeyB4OiAyMjAsIHc6IDQ0LCBoOiA0NywgeE9mZnNldDogMCB9LFxyXG4gICAgICBDT0xMSVNJT05fQk9YRVM6IFtcclxuICAgICAgICBuZXcgQ29sbGlzaW9uQm94KDIyLCAwLCAxNywgMTYpLFxyXG4gICAgICAgIG5ldyBDb2xsaXNpb25Cb3goMSwgMTgsIDMwLCA5KSxcclxuICAgICAgICBuZXcgQ29sbGlzaW9uQm94KDEwLCAzNSwgMTQsIDgpLFxyXG4gICAgICAgIG5ldyBDb2xsaXNpb25Cb3goMSwgMjQsIDI5LCA1KSxcclxuICAgICAgICBuZXcgQ29sbGlzaW9uQm94KDUsIDMwLCAyMSwgNCksXHJcbiAgICAgICAgbmV3IENvbGxpc2lvbkJveCg5LCAzNCwgMTUsIDQpXHJcbiAgICAgIF1cclxuICAgIH0sXHJcbiAgICAvKiogQHR5cGUge0FycmF5PE9ic3RhY2xlVHlwZT59ICovXHJcbiAgICBPQlNUQUNMRVM6IFtcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdDQUNUVVNfU01BTEwnLFxyXG4gICAgICAgIHdpZHRoOiAxNyxcclxuICAgICAgICBoZWlnaHQ6IDM1LFxyXG4gICAgICAgIHlQb3M6IDEwNSxcclxuICAgICAgICBtdWx0aXBsZVNwZWVkOiA0LFxyXG4gICAgICAgIG1pbkdhcDogMTIwLFxyXG4gICAgICAgIG1pblNwZWVkOiAwLFxyXG4gICAgICAgIGNvbGxpc2lvbkJveGVzOiBbXHJcbiAgICAgICAgICBuZXcgQ29sbGlzaW9uQm94KDAsIDcsIDUsIDI3KSxcclxuICAgICAgICAgIG5ldyBDb2xsaXNpb25Cb3goNCwgMCwgNiwgMzQpLFxyXG4gICAgICAgICAgbmV3IENvbGxpc2lvbkJveCgxMCwgNCwgNywgMTQpXHJcbiAgICAgICAgXVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogJ0NBQ1RVU19MQVJHRScsXHJcbiAgICAgICAgd2lkdGg6IDI1LFxyXG4gICAgICAgIGhlaWdodDogNTAsXHJcbiAgICAgICAgeVBvczogOTAsXHJcbiAgICAgICAgbXVsdGlwbGVTcGVlZDogNyxcclxuICAgICAgICBtaW5HYXA6IDEyMCxcclxuICAgICAgICBtaW5TcGVlZDogMCxcclxuICAgICAgICBjb2xsaXNpb25Cb3hlczogW1xyXG4gICAgICAgICAgbmV3IENvbGxpc2lvbkJveCgwLCAxMiwgNywgMzgpLFxyXG4gICAgICAgICAgbmV3IENvbGxpc2lvbkJveCg4LCAwLCA3LCA0OSksXHJcbiAgICAgICAgICBuZXcgQ29sbGlzaW9uQm94KDEzLCAxMCwgMTAsIDM4KVxyXG4gICAgICAgIF1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdQVEVST0RBQ1RZTCcsXHJcbiAgICAgICAgd2lkdGg6IDQ2LFxyXG4gICAgICAgIGhlaWdodDogNDAsXHJcbiAgICAgICAgeVBvczogWzEwMCwgNzUsIDUwXSwgLy8gVmFyaWFibGUgaGVpZ2h0LlxyXG4gICAgICAgIHlQb3NNb2JpbGU6IFsxMDAsIDUwXSwgLy8gVmFyaWFibGUgaGVpZ2h0IG1vYmlsZS5cclxuICAgICAgICBtdWx0aXBsZVNwZWVkOiA5OTksXHJcbiAgICAgICAgbWluU3BlZWQ6IDguNSxcclxuICAgICAgICBtaW5HYXA6IDE1MCxcclxuICAgICAgICBjb2xsaXNpb25Cb3hlczogW1xyXG4gICAgICAgICAgbmV3IENvbGxpc2lvbkJveCgxNSwgMTUsIDE2LCA1KSxcclxuICAgICAgICAgIG5ldyBDb2xsaXNpb25Cb3goMTgsIDIxLCAyNCwgNiksXHJcbiAgICAgICAgICBuZXcgQ29sbGlzaW9uQm94KDIsIDE0LCA0LCAzKSxcclxuICAgICAgICAgIG5ldyBDb2xsaXNpb25Cb3goNiwgMTAsIDQsIDcpLFxyXG4gICAgICAgICAgbmV3IENvbGxpc2lvbkJveCgxMCwgOCwgNiwgOSlcclxuICAgICAgICBdLFxyXG4gICAgICAgIG51bUZyYW1lczogMixcclxuICAgICAgICBmcmFtZVJhdGU6IDEwMDAgLyA2LFxyXG4gICAgICAgIHNwZWVkT2Zmc2V0OiAwLjhcclxuICAgICAgfVxyXG4gICAgXSxcclxuICAgIEJBQ0tHUk9VTkRfRUw6IHtcclxuICAgICAgQ0xPVUQ6IHtcclxuICAgICAgICBIRUlHSFQ6IDE0LFxyXG4gICAgICAgIE1BWF9DTE9VRF9HQVA6IDQwMCxcclxuICAgICAgICBNQVhfU0tZX0xFVkVMOiAzMCxcclxuICAgICAgICBNSU5fQ0xPVURfR0FQOiAxMDAsXHJcbiAgICAgICAgTUlOX1NLWV9MRVZFTDogNzEsXHJcbiAgICAgICAgT0ZGU0VUOiA0LFxyXG4gICAgICAgIFdJRFRIOiA0NixcclxuICAgICAgICBYX1BPUzogMSxcclxuICAgICAgICBZX1BPUzogMTIwXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBCQUNLR1JPVU5EX0VMX0NPTkZJRzoge1xyXG4gICAgICBNQVhfQkdfRUxTOiAxLFxyXG4gICAgICBNQVhfR0FQOiA0MDAsXHJcbiAgICAgIE1JTl9HQVA6IDEwMCxcclxuICAgICAgUE9TOiAwLFxyXG4gICAgICBTUEVFRDogMC41LFxyXG4gICAgICBZX1BPUzogMTI1XHJcbiAgICB9LFxyXG4gICAgTElORVM6IFtcclxuICAgICAgeyBTT1VSQ0VfWDogMiwgU09VUkNFX1k6IDUyLCBXSURUSDogNjAwLCBIRUlHSFQ6IDEyLCBZUE9TOiAxMjcgfVxyXG4gICAgXVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHt7XHJcbiAqICAgZG93bmxvYWRCdXR0b25DbGljazogZnVuY3Rpb24oKSxcclxuICogICByZWxvYWRCdXR0b25DbGljazogZnVuY3Rpb24oc3RyaW5nKSxcclxuICogICBkZXRhaWxzQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uKCksXHJcbiAqICAgZGlhZ25vc2VFcnJvcnNCdXR0b25DbGljazogZnVuY3Rpb24oKSxcclxuICogICB0cmFja0Vhc3RlckVnZzogZnVuY3Rpb24oKSxcclxuICogICB1cGRhdGVFYXN0ZXJFZ2dIaWdoU2NvcmU6IGZ1bmN0aW9uKG51bWJlciksXHJcbiAqICAgcmVzZXRFYXN0ZXJFZ2dIaWdoU2NvcmU6IGZ1bmN0aW9uKCksXHJcbiAqICAgbGF1bmNoT2ZmbGluZUl0ZW06IGZ1bmN0aW9uKHN0cmluZywgc3RyaW5nKSxcclxuICogICBzYXZlUGFnZUZvckxhdGVyOiBmdW5jdGlvbigpLFxyXG4gKiAgIGNhbmNlbFNhdmVQYWdlOiBmdW5jdGlvbigpLFxyXG4gKiAgIGxpc3RWaXNpYmlsaXR5Q2hhbmdlOiBmdW5jdGlvbihib29sZWFuKSxcclxuICogfX1cclxuICovXHJcbmV4cG9ydCBsZXQgZXJyb3JQYWdlQ29udHJvbGxlclxyXG5cclxuZXhwb3J0IGNvbnN0IEhJRERFTl9DTEFTUyA9ICdoaWRkZW4nXHJcbiIsIi8vIENvcHlyaWdodCAyMDE1IFRoZSBDaHJvbWl1bSBBdXRob3JzXHJcbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cclxuaW1wb3J0IHsgSElEREVOX0NMQVNTIH0gZnJvbSAnLi9vZmZsaW5lLXNwcml0ZS1kZWZpbml0aW9ucydcclxuXHJcbmV4cG9ydCBsZXQgbW9iaWxlTmF2ID0gZmFsc2VcclxuXHJcbi8qKlxyXG4gKiBGb3Igc21hbGwgc2NyZWVuIG1vYmlsZSB0aGUgbmF2aWdhdGlvbiBidXR0b25zIGFyZSBtb3ZlZFxyXG4gKiBiZWxvdyB0aGUgYWR2YW5jZWQgdGV4dC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvblJlc2l6ZSAoKSB7XHJcbiAgY29uc3QgaGVscE91dGVyQm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RldGFpbHMnKVxyXG4gIGNvbnN0IG1haW5Db250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21haW4tY29udGVudCcpXHJcbiAgY29uc3QgbWVkaWFRdWVyeSA9ICcobWluLXdpZHRoOiAyNDBweCkgYW5kIChtYXgtd2lkdGg6IDQyMHB4KSBhbmQgJyArXHJcbiAgICAnKG1pbi1oZWlnaHQ6IDQwMXB4KSwgJyArXHJcbiAgICAnKG1heC1oZWlnaHQ6IDU2MHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDI0MHB4KSBhbmQgJyArXHJcbiAgICAnKG1pbi13aWR0aDogNDIxcHgpJ1xyXG5cclxuICBjb25zdCBkZXRhaWxzSGlkZGVuID0gaGVscE91dGVyQm94LmNsYXNzTGlzdC5jb250YWlucyhISURERU5fQ0xBU1MpXHJcbiAgY29uc3QgcnVubmVyQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJ1bm5lci1jb250YWluZXInKVxyXG5cclxuICAvLyBDaGVjayBmb3IgY2hhbmdlIGluIG5hdiBzdGF0dXMuXHJcbiAgaWYgKG1vYmlsZU5hdiAhPT0gd2luZG93Lm1hdGNoTWVkaWEobWVkaWFRdWVyeSkubWF0Y2hlcykge1xyXG4gICAgbW9iaWxlTmF2ID0gIW1vYmlsZU5hdlxyXG5cclxuICAgIC8vIEhhbmRsZSBzaG93aW5nIHRoZSB0b3AgY29udGVudCAvIGRldGFpbHMgc2VjdGlvbnMgYWNjb3JkaW5nIHRvIHN0YXRlLlxyXG4gICAgaWYgKG1vYmlsZU5hdikge1xyXG4gICAgICBtYWluQ29udGVudC5jbGFzc0xpc3QudG9nZ2xlKEhJRERFTl9DTEFTUywgIWRldGFpbHNIaWRkZW4pXHJcbiAgICAgIGhlbHBPdXRlckJveC5jbGFzc0xpc3QudG9nZ2xlKEhJRERFTl9DTEFTUywgZGV0YWlsc0hpZGRlbilcclxuICAgICAgaWYgKHJ1bm5lckNvbnRhaW5lcikge1xyXG4gICAgICAgIHJ1bm5lckNvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKEhJRERFTl9DTEFTUywgIWRldGFpbHNIaWRkZW4pXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIWRldGFpbHNIaWRkZW4pIHtcclxuICAgICAgLy8gTm9uLW1vYmlsZSBuYXYgd2l0aCB2aXNpYmxlIGRldGFpbHMuXHJcbiAgICAgIG1haW5Db250ZW50LmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTKVxyXG4gICAgICBoZWxwT3V0ZXJCb3guY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1MpXHJcbiAgICAgIGlmIChydW5uZXJDb250YWluZXIpIHtcclxuICAgICAgICBydW5uZXJDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1MpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cE1vYmlsZU5hdiAoKSB7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKVxyXG4gIG9uUmVzaXplKClcclxufVxyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHNldHVwTW9iaWxlTmF2KVxyXG4iLCIvLyBDb3B5cmlnaHQgMjAyMCBUaGUgQ2hyb21pdW0gQXV0aG9yc1xyXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXHJcblxyXG5leHBvcnQgY29uc3QgZXJyb3JQYWdlQ29udHJvbGxlciA9IHtcclxuICAvLyBFeGVjdXRlIGEgYnV0dG9uIGNsaWNrIHRvIGRvd25sb2FkIHBhZ2UgbGF0ZXIuXHJcbiAgZG93bmxvYWRCdXR0b25DbGljazogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gIC8vIEV4ZWN1dGUgYSBjbGljayBvbiB0aGUgcmVsb2FkIGJ1dHRvbi5cclxuICByZWxvYWRCdXR0b25DbGljazogZnVuY3Rpb24gKHVybCkge1xyXG4gICAgd2luZG93LmxvY2F0aW9uID0gdXJsXHJcbiAgfSxcclxuXHJcbiAgLy8gRXhlY3V0ZSBhIFwiRGV0YWlsc1wiIGJ1dHRvbiBjbGljay5cclxuICBkZXRhaWxzQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuICAvLyBFeGVjdXRlIGEgXCJEaWFnbm9zZSBFcnJvcnNcIiBidXR0b24gY2xpY2suXHJcbiAgZGlhZ25vc2VFcnJvcnNCdXR0b25DbGljazogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gIC8vID8/P1xyXG4gIGxhdW5jaE9mZmxpbmVJdGVtOiBmdW5jdGlvbiAoKSB7fSxcclxuICBzYXZlUGFnZUZvckxhdGVyOiBmdW5jdGlvbiAoKSB7fSxcclxuICBjYW5jZWxTYXZlUGFnZTogZnVuY3Rpb24gKCkge30sXHJcbiAgbGlzdFZpc2liaWxpdHlDaGFuZ2U6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuICAvLyBUcmFjayBlYXN0ZXIgZWdnIHBsYXlzIGFuZCBoaWdoIHNjb3Jlcy5cclxuICB0cmFja0Vhc3RlckVnZzogZnVuY3Rpb24gKCkge1xyXG4gICAgX19nQ3JXZWIubWVzc2FnZS5pbnZva2VPbkhvc3QoXHJcbiAgICAgIHsgY29tbWFuZDogJ2Vycm9yUGFnZUNvbnRyb2xsZXIudHJhY2tFYXN0ZXJFZ2cnIH0pXHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlRWFzdGVyRWdnSGlnaFNjb3JlOiBmdW5jdGlvbiAoaGlnaFNjb3JlKSB7XHJcbiAgICBfX2dDcldlYi5tZXNzYWdlLmludm9rZU9uSG9zdCh7XHJcbiAgICAgIGNvbW1hbmQ6ICdlcnJvclBhZ2VDb250cm9sbGVyLnVwZGF0ZUVhc3RlckVnZ0hpZ2hTY29yZScsXHJcbiAgICAgIGhpZ2hTY29yZTogaGlnaFNjb3JlLnRvU3RyaW5nKClcclxuICAgIH0pXHJcbiAgfSxcclxuXHJcbiAgcmVzZXRFYXN0ZXJFZ2dIaWdoU2NvcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fZ0NyV2ViLm1lc3NhZ2UuaW52b2tlT25Ib3N0KFxyXG4gICAgICB7IGNvbW1hbmQ6ICdlcnJvclBhZ2VDb250cm9sbGVyLnJlc2V0RWFzdGVyRWdnSGlnaFNjb3JlJyB9KVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ3JlYXRlIGEgX19nQ3JXZWIgYmluZGluZyBvZiBpbml0aWFsaXplRWFzdGVyRWdnSGlnaFNjb3JlIHNvIGl0IGNhbiBiZVxyXG4vLyBjYWxsZWQgdXNpbmcgSlMgbWVzc2FnaW5nLlxyXG5jb25zdCBfX2dDcldlYiA9IHt9XHJcbl9fZ0NyV2ViLmVycm9yUGFnZUNvbnRyb2xsZXIgPSBlcnJvclBhZ2VDb250cm9sbGVyXHJcbl9fZ0NyV2ViLmVycm9yUGFnZUNvbnRyb2xsZXIuaW5pdGlhbGl6ZUVhc3RlckVnZ0hpZ2hTY29yZSA9IGZ1bmN0aW9uIChoaWdoc2NvcmUpIHtcclxuICB3aW5kb3cuaW5pdGlhbGl6ZUVhc3RlckVnZ0hpZ2hTY29yZShoaWdoc2NvcmUpXHJcbn1cclxuIiwiaW1wb3J0IHsgSElEREVOX0NMQVNTLCBlcnJvclBhZ2VDb250cm9sbGVyIH0gZnJvbSAnLi9vZmZsaW5lLXNwcml0ZS1kZWZpbml0aW9ucydcclxuaW1wb3J0IFJ1bm5lciBmcm9tICcuL29mZmxpbmUnXHJcbmltcG9ydCB7IGxvYWRUaW1lRGF0YSB9IGZyb20gJy4vbG9hZF90aW1lX2RhdGFfZGVwcmVjYXRlZCdcclxuaW1wb3J0IHsgbW9iaWxlTmF2IH0gZnJvbSAnLi9pbnRlcnN0aXRpYWxfbW9iaWxlX25hdidcclxuXHJcbi8vIERlY29kZXMgYSBVVEYxNiBzdHJpbmcgdGhhdCBpcyBlbmNvZGVkIGFzIGJhc2U2NC5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVURjE2QmFzZTY0VG9TdHJpbmcgKGVuY29kZWRUZXh0KSB7XHJcbiAgY29uc3QgZGF0YSA9IGF0b2IoZW5jb2RlZFRleHQpXHJcbiAgbGV0IHJlc3VsdCA9ICcnXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICByZXN1bHQgKz1cclxuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLmNoYXJDb2RlQXQoaSkgKiAyNTYgKyBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVIZWxwQm94ICgpIHtcclxuICBjb25zdCBoZWxwQm94T3V0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlscycpXHJcbiAgaGVscEJveE91dGVyLmNsYXNzTGlzdC50b2dnbGUoSElEREVOX0NMQVNTKVxyXG4gIGNvbnN0IGRldGFpbHNCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlscy1idXR0b24nKVxyXG4gIGlmIChoZWxwQm94T3V0ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKEhJRERFTl9DTEFTUykpIHtcclxuICAgIC8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xyXG4gICAgZGV0YWlsc0J1dHRvbi5pbm5lclRleHQgPSBkZXRhaWxzQnV0dG9uLmRldGFpbHNUZXh0XHJcbiAgfSBlbHNlIHtcclxuICAgIC8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xyXG4gICAgZGV0YWlsc0J1dHRvbi5pbm5lclRleHQgPSBkZXRhaWxzQnV0dG9uLmhpZGVEZXRhaWxzVGV4dFxyXG4gIH1cclxuXHJcbiAgLy8gRGV0YWlscyBhcHBlYXJzIG92ZXIgdGhlIG1haW4gY29udGVudCBvbiBzbWFsbCBzY3JlZW5zLlxyXG4gIGlmIChtb2JpbGVOYXYpIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluLWNvbnRlbnQnKS5jbGFzc0xpc3QudG9nZ2xlKEhJRERFTl9DTEFTUylcclxuICAgIGNvbnN0IHJ1bm5lckNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ydW5uZXItY29udGFpbmVyJylcclxuICAgIGlmIChydW5uZXJDb250YWluZXIpIHtcclxuICAgICAgcnVubmVyQ29udGFpbmVyLmNsYXNzTGlzdC50b2dnbGUoSElEREVOX0NMQVNTKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpYWdub3NlRXJyb3JzICgpIHtcclxuICBpZiAod2luZG93LmVycm9yUGFnZUNvbnRyb2xsZXIpIHtcclxuICAgIGVycm9yUGFnZUNvbnRyb2xsZXIuZGlhZ25vc2VFcnJvcnNCdXR0b25DbGljaygpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBTdWJmcmFtZXMgdXNlIGEgZGlmZmVyZW50IGxheW91dCBidXQgdGhlIHNhbWUgaHRtbCBmaWxlLiAgVGhpcyBpcyB0byBtYWtlIGl0XHJcbi8vIGVhc2llciB0byBzdXBwb3J0IHBsYXRmb3JtcyB0aGF0IGxvYWQgdGhlIGVycm9yIHBhZ2UgdmlhIGRpZmZlcmVudFxyXG4vLyBtZWNoYW5pc21zIChDdXJyZW50bHkganVzdCBpT1MpLiBXZSBhbHNvIHVzZSB0aGUgc3ViZnJhbWUgc3R5bGUgZm9yIHBvcnRhbHNcclxuLy8gYXMgdGhleSBhcmUgZW1iZWRkZWQgbGlrZSBzdWJmcmFtZXMgYW5kIGNhbid0IGJlIGludGVyYWN0ZWQgd2l0aCBieSB0aGUgdXNlci5cclxuZXhwb3J0IGxldCBpc1N1YkZyYW1lID0gZmFsc2VcclxuaWYgKHdpbmRvdy50b3AubG9jYXRpb24gIT09IHdpbmRvdy5sb2NhdGlvbiB8fCB3aW5kb3cucG9ydGFsSG9zdCkge1xyXG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N1YmZyYW1lJywgJycpXHJcbiAgaXNTdWJGcmFtZSA9IHRydWVcclxufVxyXG5cclxuLy8gQWRkcyBhbiBpY29uIGNsYXNzIHRvIHRoZSBsaXN0IGFuZCByZW1vdmVzIGNsYXNzZXMgcHJldmlvdXNseSBzZXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVJY29uQ2xhc3MgKG5ld0NsYXNzKSB7XHJcbiAgY29uc3QgZnJhbWVTZWxlY3RvciA9IGlzU3ViRnJhbWUgPyAnI3N1Yi1mcmFtZS1lcnJvcicgOiAnI21haW4tZnJhbWUtZXJyb3InXHJcbiAgY29uc3QgaWNvbkVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihmcmFtZVNlbGVjdG9yICsgJyAuaWNvbicpXHJcblxyXG4gIGlmIChpY29uRWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5ld0NsYXNzKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICBpY29uRWwuY2xhc3NOYW1lID0gJ2ljb24gJyArIG5ld0NsYXNzXHJcbn1cclxuXHJcbi8vIEltcGxlbWVudHMgYnV0dG9uIGNsaWNrcy4gIFRoaXMgZnVuY3Rpb24gaXMgbmVlZGVkIGR1cmluZyB0aGUgdHJhbnNpdGlvblxyXG4vLyBiZXR3ZWVuIGltcGxlbWVudGluZyB0aGVzZSBpbiB0cnVuayBjaHJvbWl1bSBhbmQgaW1wbGVtZW50aW5nIHRoZW0gaW4gaU9TLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVsb2FkQnV0dG9uQ2xpY2sgKHVybCkge1xyXG4gIGlmICh3aW5kb3cuZXJyb3JQYWdlQ29udHJvbGxlcikge1xyXG4gICAgLy8gPGlmIGV4cHI9XCJpc19pb3NcIj5cclxuICAgIGVycm9yUGFnZUNvbnRyb2xsZXIucmVsb2FkQnV0dG9uQ2xpY2sodXJsKVxyXG4gICAgLy8gPC9pZj5cclxuXHJcbiAgICAvLyA8aWYgZXhwcj1cIm5vdCBpc19pb3NcIj5cclxuICAgIGVycm9yUGFnZUNvbnRyb2xsZXIucmVsb2FkQnV0dG9uQ2xpY2soKVxyXG4gICAgLy8gPC9pZj5cclxuICB9IGVsc2Uge1xyXG4gICAgd2luZG93LmxvY2F0aW9uID0gdXJsXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRCdXR0b25DbGljayAoKSB7XHJcbiAgaWYgKHdpbmRvdy5lcnJvclBhZ2VDb250cm9sbGVyKSB7XHJcbiAgICBlcnJvclBhZ2VDb250cm9sbGVyLmRvd25sb2FkQnV0dG9uQ2xpY2soKVxyXG4gICAgY29uc3QgZG93bmxvYWRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWQtYnV0dG9uJylcclxuICAgIGRvd25sb2FkQnV0dG9uLmRpc2FibGVkID0gdHJ1ZVxyXG4gICAgLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXHJcbiAgICBkb3dubG9hZEJ1dHRvbi50ZXh0Q29udGVudCA9IGRvd25sb2FkQnV0dG9uLmRpc2FibGVkVGV4dFxyXG5cclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkb3dubG9hZC1saW5rLXdyYXBwZXInKVxyXG4gICAgICAuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1MpXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWQtbGluay1jbGlja2VkLXdyYXBwZXInKVxyXG4gICAgICAuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1MpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGV0YWlsc0J1dHRvbkNsaWNrICgpIHtcclxuICBpZiAod2luZG93LmVycm9yUGFnZUNvbnRyb2xsZXIpIHtcclxuICAgIGVycm9yUGFnZUNvbnRyb2xsZXIuZGV0YWlsc0J1dHRvbkNsaWNrKClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBsZXQgcHJpbWFyeUNvbnRyb2xPbkxlZnQgPSB0cnVlXHJcbi8vIGNsYW5nLWZvcm1hdCBvZmZcclxuLy8gPGlmIGV4cHI9XCJpc19tYWNvc3ggb3IgaXNfaW9zIG9yIGlzX2xpbnV4IG9yIGlzX2Nocm9tZW9zIG9yIGlzX2FuZHJvaWRcIj5cclxuLy8gY2xhbmctZm9ybWF0IG9uXHJcbnByaW1hcnlDb250cm9sT25MZWZ0ID0gZmFsc2VcclxuLy8gPC9pZj5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRBdXRvRmV0Y2hTdGF0ZSAoc2NoZWR1bGVkLCBjYW5TY2hlZHVsZSkge1xyXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW5jZWwtc2F2ZS1wYWdlLWJ1dHRvbicpXHJcbiAgICAuY2xhc3NMaXN0LnRvZ2dsZShISURERU5fQ0xBU1MsICFzY2hlZHVsZWQpXHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NhdmUtcGFnZS1mb3ItbGF0ZXItYnV0dG9uJylcclxuICAgIC5jbGFzc0xpc3QudG9nZ2xlKEhJRERFTl9DTEFTUywgc2NoZWR1bGVkIHx8ICFjYW5TY2hlZHVsZSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVQYWdlTGF0ZXJDbGljayAoKSB7XHJcbiAgZXJyb3JQYWdlQ29udHJvbGxlci5zYXZlUGFnZUZvckxhdGVyKClcclxuICAvLyBzYXZlUGFnZUZvckxhdGVyIHdpbGwgZXZlbnR1YWxseSB0cmlnZ2VyIGEgY2FsbCB0byBzZXRBdXRvRmV0Y2hTdGF0ZSgpIHdoZW5cclxuICAvLyBpdCBjb21wbGV0ZXMuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxTYXZlUGFnZUNsaWNrICgpIHtcclxuICBlcnJvclBhZ2VDb250cm9sbGVyLmNhbmNlbFNhdmVQYWdlKClcclxuICAvLyBzZXRBdXRvRmV0Y2hTdGF0ZSBpcyBub3QgY2FsbGVkIGluIHJlc3BvbnNlIHRvIGNhbmNlbFNhdmVQYWdlKCksIHNvIGRvIGl0XHJcbiAgLy8gbm93LlxyXG4gIHNldEF1dG9GZXRjaFN0YXRlKGZhbHNlLCB0cnVlKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlRXJyb3JJbmZvcm1hdGlvblBvcHVwICgpIHtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3ItaW5mb3JtYXRpb24tcG9wdXAtY29udGFpbmVyJylcclxuICAgIC5jbGFzc0xpc3QudG9nZ2xlKEhJRERFTl9DTEFTUylcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdW5jaE9mZmxpbmVJdGVtIChpdGVtSUQsIG5hbWVTcGFjZSkge1xyXG4gIGVycm9yUGFnZUNvbnRyb2xsZXIubGF1bmNoT2ZmbGluZUl0ZW0oaXRlbUlELCBuYW1lU3BhY2UpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXVuY2hEb3dubG9hZHNQYWdlICgpIHtcclxuICBlcnJvclBhZ2VDb250cm9sbGVyLmxhdW5jaERvd25sb2Fkc1BhZ2UoKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNvbkZvclN1Z2dlc3RlZEl0ZW0gKGl0ZW0pIHtcclxuICAvLyBOb3RlOiB8aXRlbS5jb250ZW50X3R5cGV8IGNvbnRhaW5zIHRoZSBlbnVtIHZhbHVlcyBmcm9tXHJcbiAgLy8gY2hyb21lOjptb2pvbTo6QXZhaWxhYmxlQ29udGVudFR5cGUuXHJcbiAgc3dpdGNoIChpdGVtLmNvbnRlbnRfdHlwZSkge1xyXG4gICAgY2FzZSAxOiAvLyBrVmlkZW9cclxuICAgICAgcmV0dXJuICdpbWFnZS12aWRlbydcclxuICAgIGNhc2UgMjogLy8ga0F1ZGlvXHJcbiAgICAgIHJldHVybiAnaW1hZ2UtbXVzaWMtbm90ZSdcclxuICAgIGNhc2UgMDogLy8ga1ByZWZldGNoZWRQYWdlXHJcbiAgICBjYXNlIDM6IC8vIGtPdGhlclBhZ2VcclxuICAgICAgcmV0dXJuICdpbWFnZS1lYXJ0aCdcclxuICB9XHJcbiAgcmV0dXJuICdpbWFnZS1maWxlJ1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VnZ2VzdGVkQ29udGVudERpdiAoaXRlbSwgaW5kZXgpIHtcclxuICAvLyBOb3RlOiBTZWUgQXZhaWxhYmxlQ29udGVudFRvVmFsdWUgaW4gYXZhaWxhYmxlX29mZmxpbmVfY29udGVudF9oZWxwZXIuY2NcclxuICAvLyBmb3IgdGhlIGRhdGEgY29udGFpbmVkIGluIGFuIHxpdGVtfC5cclxuICAvLyBUT0RPKGNhcmxvc2spOiBQcmVzZW50IHxzbmlwcGV0X2Jhc2U2NHwgd2hlbiB0aGF0IGNvbnRlbnQgYmVjb21lc1xyXG4gIC8vIGF2YWlsYWJsZS5cclxuICBsZXQgdGh1bWJuYWlsID0gJydcclxuICBjb25zdCBleHRyYUNvbnRhaW5lckNsYXNzZXMgPSBbXVxyXG4gIC8vIGh0bWxfaW5saW5lLnB5IHdpbGwgdHJ5IHRvIHJlcGxhY2Ugc3JjIGF0dHJpYnV0ZXMgd2l0aCBkYXRhIFVSSXMgdXNpbmcgYVxyXG4gIC8vIHNpbXBsZSByZWdleC4gVGhlIGZvbGxvd2luZyBpcyBvYmZ1c2NhdGVkIHNsaWdodGx5IHRvIGF2b2lkIHRoYXQuXHJcbiAgY29uc3Qgc291cmNlID0gJ3NyYydcclxuICBpZiAoaXRlbS50aHVtYm5haWxfZGF0YV91cmkpIHtcclxuICAgIGV4dHJhQ29udGFpbmVyQ2xhc3Nlcy5wdXNoKCdzdWdnZXN0aW9uLXdpdGgtaW1hZ2UnKVxyXG4gICAgdGh1bWJuYWlsID0gYDxpbWcgJHtzb3VyY2V9PVwiJHtpdGVtLnRodW1ibmFpbF9kYXRhX3VyaX1cIj5gXHJcbiAgfSBlbHNlIHtcclxuICAgIGV4dHJhQ29udGFpbmVyQ2xhc3Nlcy5wdXNoKCdzdWdnZXN0aW9uLXdpdGgtaWNvbicpXHJcbiAgICBjb25zdCBpY29uQ2xhc3MgPSBnZXRJY29uRm9yU3VnZ2VzdGVkSXRlbShpdGVtKVxyXG4gICAgdGh1bWJuYWlsID0gYDxkaXY+PGltZyBjbGFzcz1cIiR7aWNvbkNsYXNzfVwiPjwvZGl2PmBcclxuICB9XHJcblxyXG4gIGxldCBmYXZpY29uID0gJydcclxuICBpZiAoaXRlbS5mYXZpY29uX2RhdGFfdXJpKSB7XHJcbiAgICBmYXZpY29uID0gYDxpbWcgJHtzb3VyY2V9PVwiJHtpdGVtLmZhdmljb25fZGF0YV91cml9XCI+YFxyXG4gIH0gZWxzZSB7XHJcbiAgICBleHRyYUNvbnRhaW5lckNsYXNzZXMucHVzaCgnbm8tZmF2aWNvbicpXHJcbiAgfVxyXG5cclxuICBpZiAoIWl0ZW0uYXR0cmlidXRpb25fYmFzZTY0KSB7XHJcbiAgICBleHRyYUNvbnRhaW5lckNsYXNzZXMucHVzaCgnbm8tYXR0cmlidXRpb24nKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGBcclxuICA8ZGl2IGNsYXNzPVwib2ZmbGluZS1jb250ZW50LXN1Z2dlc3Rpb24gJHtleHRyYUNvbnRhaW5lckNsYXNzZXMuam9pbignICcpfVwiXHJcbiAgICBvbmNsaWNrPVwibGF1bmNoT2ZmbGluZUl0ZW0oJyR7aXRlbS5JRH0nLCAnJHtpdGVtLm5hbWVfc3BhY2V9JylcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm9mZmxpbmUtY29udGVudC1zdWdnZXN0aW9uLXRleHRzXCI+XHJcbiAgICAgICAgPGRpdiBpZD1cIm9mZmxpbmUtY29udGVudC1zdWdnZXN0aW9uLXRpdGxlLSR7aW5kZXh9XCJcclxuICAgICAgICAgICAgIGNsYXNzPVwib2ZmbGluZS1jb250ZW50LXN1Z2dlc3Rpb24tdGl0bGVcIj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwib2ZmbGluZS1jb250ZW50LXN1Z2dlc3Rpb24tYXR0cmlidXRpb24tZnJlc2huZXNzXCI+XHJcbiAgICAgICAgICA8ZGl2IGlkPVwib2ZmbGluZS1jb250ZW50LXN1Z2dlc3Rpb24tZmF2aWNvbi0ke2luZGV4fVwiXHJcbiAgICAgICAgICAgICAgIGNsYXNzPVwib2ZmbGluZS1jb250ZW50LXN1Z2dlc3Rpb24tZmF2aWNvblwiPlxyXG4gICAgICAgICAgICAke2Zhdmljb259XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgaWQ9XCJvZmZsaW5lLWNvbnRlbnQtc3VnZ2VzdGlvbi1hdHRyaWJ1dGlvbi0ke2luZGV4fVwiXHJcbiAgICAgICAgICAgICAgIGNsYXNzPVwib2ZmbGluZS1jb250ZW50LXN1Z2dlc3Rpb24tYXR0cmlidXRpb25cIj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm9mZmxpbmUtY29udGVudC1zdWdnZXN0aW9uLWZyZXNobmVzc1wiPlxyXG4gICAgICAgICAgICAke2l0ZW0uZGF0ZV9tb2RpZmllZH1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm9mZmxpbmUtY29udGVudC1zdWdnZXN0aW9uLXBpbi1zcGFjZXJcIj48L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJvZmZsaW5lLWNvbnRlbnQtc3VnZ2VzdGlvbi1waW5cIj48L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJvZmZsaW5lLWNvbnRlbnQtc3VnZ2VzdGlvbi10aHVtYm5haWxcIj5cclxuICAgICAgICAke3RodW1ibmFpbH1cclxuICAgICAgPC9kaXY+XHJcbiAgPC9kaXY+YFxyXG59XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge3tcclxuICogICBJRDogc3RyaW5nLFxyXG4gKiAgIG5hbWVfc3BhY2U6IHN0cmluZyxcclxuICogICB0aXRsZV9iYXNlNjQ6IHN0cmluZyxcclxuICogICBzbmlwcGV0X2Jhc2U2NDogc3RyaW5nLFxyXG4gKiAgIGRhdGVfbW9kaWZpZWQ6IHN0cmluZyxcclxuICogICBhdHRyaWJ1dGlvbl9iYXNlNjQ6IHN0cmluZyxcclxuICogICB0aHVtYm5haWxfZGF0YV91cmk6IHN0cmluZyxcclxuICogICBmYXZpY29uX2RhdGFfdXJpOiBzdHJpbmcsXHJcbiAqICAgY29udGVudF90eXBlOiBudW1iZXIsXHJcbiAqIH19XHJcbiAqL1xyXG5leHBvcnQgbGV0IEF2YWlsYWJsZU9mZmxpbmVDb250ZW50XHJcblxyXG4vLyBQb3B1bGF0ZXMgYSBsaXN0IG9mIHN1Z2dlc3RlZCBvZmZsaW5lIGNvbnRlbnQuXHJcbi8vIE5vdGU6IEZvciBzZWN1cml0eSByZWFzb25zIGFsbCBjb250ZW50IGRvd25sb2FkZWQgZnJvbSB0aGUgd2ViIGlzIGNvbnNpZGVyZWRcclxuLy8gdW5zYWZlIGFuZCBtdXN0IGJlIHNlY3VyZWx5IGhhbmRsZWQgdG8gYmUgcHJlc2VudGVkIG9uIHRoZSBkaW5vIHBhZ2UuIEltYWdlc1xyXG4vLyBoYXZlIGFscmVhZHkgYmVlbiBzYWZlbHkgcmUtZW5jb2RlZCBidXQgdGV4dHVhbCBjb250ZW50IC0tIGxpa2UgdGl0bGUgYW5kXHJcbi8vIGF0dHJpYnV0aW9uIC0tIG11c3QgYmUgcHJvcGVybHkgaGFuZGxlZCBoZXJlLlxyXG4vLyBAcGFyYW0ge2Jvb2xlYW59IGlzU2hvd25cclxuLy8gQHBhcmFtIHtBcnJheTxBdmFpbGFibGVPZmZsaW5lQ29udGVudD59IHN1Z2dlc3Rpb25zXHJcbmV4cG9ydCBmdW5jdGlvbiBvZmZsaW5lQ29udGVudEF2YWlsYWJsZSAoaXNTaG93biwgc3VnZ2VzdGlvbnMpIHtcclxuICBpZiAoIXN1Z2dlc3Rpb25zIHx8ICFsb2FkVGltZURhdGEudmFsdWVFeGlzdHMoJ29mZmxpbmVDb250ZW50TGlzdCcpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIGNvbnN0IHN1Z2dlc3Rpb25zSFRNTCA9IFtdXHJcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHN1Z2dlc3Rpb25zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgc3VnZ2VzdGlvbnNIVE1MLnB1c2goZ2V0U3VnZ2VzdGVkQ29udGVudERpdihzdWdnZXN0aW9uc1tpbmRleF0sIGluZGV4KSlcclxuICB9XHJcblxyXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvZmZsaW5lLWNvbnRlbnQtc3VnZ2VzdGlvbnMnKS5pbm5lckhUTUwgPVxyXG4gICAgc3VnZ2VzdGlvbnNIVE1MLmpvaW4oJ1xcbicpXHJcblxyXG4gIC8vIFNldHMgdGV4dHVhbCB3ZWIgY29udGVudCB1c2luZyB8dGV4dENvbnRlbnR8IHRvIG1ha2Ugc3VyZSBpdCdzIGhhbmRsZWQgYXNcclxuICAvLyBwbGFpbiB0ZXh0LlxyXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzdWdnZXN0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBvZmZsaW5lLWNvbnRlbnQtc3VnZ2VzdGlvbi10aXRsZS0ke2luZGV4fWApXHJcbiAgICAgIC50ZXh0Q29udGVudCA9XHJcbiAgICAgIGRlY29kZVVURjE2QmFzZTY0VG9TdHJpbmcoc3VnZ2VzdGlvbnNbaW5kZXhdLnRpdGxlX2Jhc2U2NClcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBvZmZsaW5lLWNvbnRlbnQtc3VnZ2VzdGlvbi1hdHRyaWJ1dGlvbi0ke2luZGV4fWApXHJcbiAgICAgIC50ZXh0Q29udGVudCA9XHJcbiAgICAgIGRlY29kZVVURjE2QmFzZTY0VG9TdHJpbmcoc3VnZ2VzdGlvbnNbaW5kZXhdLmF0dHJpYnV0aW9uX2Jhc2U2NClcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbnRlbnRMaXN0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvZmZsaW5lLWNvbnRlbnQtbGlzdCcpXHJcbiAgaWYgKGRvY3VtZW50LmRpciA9PT0gJ3J0bCcpIHtcclxuICAgIGNvbnRlbnRMaXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpcy1ydGwnKVxyXG4gIH1cclxuICBjb250ZW50TGlzdEVsZW1lbnQuaGlkZGVuID0gZmFsc2VcclxuICAvLyBUaGUgbGlzdCBpcyBjb25maWd1cmVkIGFzIGhpZGRlbiBieSBkZWZhdWx0LiBTaG93IGl0IGlmIG5lZWRlZC5cclxuICBpZiAoaXNTaG93bikge1xyXG4gICAgdG9nZ2xlT2ZmbGluZUNvbnRlbnRMaXN0VmlzaWJpbGl0eShmYWxzZSlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVPZmZsaW5lQ29udGVudExpc3RWaXNpYmlsaXR5ICh1cGRhdGVQcmVmKSB7XHJcbiAgaWYgKCFsb2FkVGltZURhdGEudmFsdWVFeGlzdHMoJ29mZmxpbmVDb250ZW50TGlzdCcpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbnRlbnRMaXN0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvZmZsaW5lLWNvbnRlbnQtbGlzdCcpXHJcbiAgY29uc3QgaXNWaXNpYmxlID0gIWNvbnRlbnRMaXN0RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdsaXN0LWhpZGRlbicpXHJcblxyXG4gIGlmICh1cGRhdGVQcmVmICYmIHdpbmRvdy5lcnJvclBhZ2VDb250cm9sbGVyKSB7XHJcbiAgICBlcnJvclBhZ2VDb250cm9sbGVyLmxpc3RWaXNpYmlsaXR5Q2hhbmdlZChpc1Zpc2libGUpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBDYWxsZWQgb24gZG9jdW1lbnQgbG9hZCwgYW5kIGZyb20gdXBkYXRlRm9yRG5zUHJvYmUoKS5cclxuZXhwb3J0IGZ1bmN0aW9uIG9uRG9jdW1lbnRMb2FkT3JVcGRhdGUgKCkge1xyXG4gIGNvbnN0IGRvd25sb2FkQnV0dG9uVmlzaWJsZSA9IGxvYWRUaW1lRGF0YS52YWx1ZUV4aXN0cygnZG93bmxvYWRCdXR0b24nKSAmJlxyXG4gICAgbG9hZFRpbWVEYXRhLmdldFZhbHVlKCdkb3dubG9hZEJ1dHRvbicpLm1zZ1xyXG4gIGNvbnN0IGRldGFpbHNCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlscy1idXR0b24nKVxyXG5cclxuICAvLyBJZiBvZmZsaW5lIGNvbnRlbnQgc3VnZ2VzdGlvbnMgd2lsbCBiZSB2aXNpYmxlLCB0aGUgdXN1YWwgYnV0dG9ucyB3aWxsIG5vdFxyXG4gIC8vIGJlIHByZXNlbnRlZC5cclxuICBjb25zdCBvZmZsaW5lQ29udGVudFZpc2libGUgPVxyXG4gICAgbG9hZFRpbWVEYXRhLnZhbHVlRXhpc3RzKCdzdWdnZXN0ZWRPZmZsaW5lQ29udGVudFByZXNlbnRhdGlvbicpXHJcbiAgaWYgKG9mZmxpbmVDb250ZW50VmlzaWJsZSkge1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5hdi13cmFwcGVyJykuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1MpXHJcbiAgICBkZXRhaWxzQnV0dG9uLmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTKVxyXG5cclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkb3dubG9hZC1saW5rJykuaGlkZGVuID0gIWRvd25sb2FkQnV0dG9uVmlzaWJsZVxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkLWxpbmtzLXdyYXBwZXInKVxyXG4gICAgICAuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1MpXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3ItaW5mb3JtYXRpb24tcG9wdXAtY29udGFpbmVyJylcclxuICAgICAgLmNsYXNzTGlzdC5hZGQoJ3VzZS1wb3B1cC1jb250YWluZXInLCBISURERU5fQ0xBU1MpXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3ItaW5mb3JtYXRpb24tYnV0dG9uJylcclxuICAgICAgLmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgYXR0ZW1wdEF1dG9GZXRjaCA9IGxvYWRUaW1lRGF0YS52YWx1ZUV4aXN0cygnYXR0ZW1wdEF1dG9GZXRjaCcpICYmXHJcbiAgICBsb2FkVGltZURhdGEuZ2V0VmFsdWUoJ2F0dGVtcHRBdXRvRmV0Y2gnKVxyXG5cclxuICBjb25zdCByZWxvYWRCdXR0b25WaXNpYmxlID0gbG9hZFRpbWVEYXRhLnZhbHVlRXhpc3RzKCdyZWxvYWRCdXR0b24nKSAmJlxyXG4gICAgbG9hZFRpbWVEYXRhLmdldFZhbHVlKCdyZWxvYWRCdXR0b24nKS5tc2dcclxuXHJcbiAgY29uc3QgcmVsb2FkQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlbG9hZC1idXR0b24nKVxyXG4gIGNvbnN0IGRvd25sb2FkQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkLWJ1dHRvbicpXHJcbiAgaWYgKHJlbG9hZEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgJiZcclxuICAgIGRvd25sb2FkQnV0dG9uLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xyXG4gICAgZGV0YWlsc0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdzaW5ndWxhcicpXHJcbiAgfVxyXG5cclxuICAvLyBTaG93IG9yIGhpZGUgY29udHJvbCBidXR0b25zLlxyXG4gIGNvbnN0IGNvbnRyb2xCdXR0b25EaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udHJvbC1idXR0b25zJylcclxuICBjb250cm9sQnV0dG9uRGl2LmhpZGRlbiA9XHJcbiAgICBvZmZsaW5lQ29udGVudFZpc2libGUgfHwgIShyZWxvYWRCdXR0b25WaXNpYmxlIHx8IGRvd25sb2FkQnV0dG9uVmlzaWJsZSlcclxuXHJcbiAgY29uc3QgaWNvbkNsYXNzID0gbG9hZFRpbWVEYXRhLnZhbHVlRXhpc3RzKCdpY29uQ2xhc3MnKSAmJlxyXG4gICAgbG9hZFRpbWVEYXRhLmdldFZhbHVlKCdpY29uQ2xhc3MnKVxyXG5cclxuICB1cGRhdGVJY29uQ2xhc3MoaWNvbkNsYXNzKVxyXG5cclxuICBpZiAoIWlzU3ViRnJhbWUgJiYgaWNvbkNsYXNzID09PSAnaWNvbi1vZmZsaW5lJykge1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ29mZmxpbmUnKVxyXG4gICAgcmV0dXJuIG5ldyBSdW5uZXIoJy5pbnRlcnN0aXRpYWwtd3JhcHBlcicpXHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBAY29weXJpZ2h0IDIwMTMgVGhlIENocm9taXVtIEF1dGhvcnNcclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxyXG4gKi9cclxuXHJcbmltcG9ydCAnLi9zdHlsZXMvc3R5bGUuc2NzcydcclxuaW1wb3J0IE9mZmxpbmVTcHJpdGUxMDAgZnJvbSAnLi9pbWFnZXMvZGVmYXVsdF8xMDBfcGVyY2VudC9vZmZsaW5lLzEwMC1vZmZsaW5lLXNwcml0ZS5wbmcnXHJcbmltcG9ydCBPZmZsaW5lU3ByaXRlMjAwIGZyb20gJy4vaW1hZ2VzL2RlZmF1bHRfMjAwX3BlcmNlbnQvb2ZmbGluZS8yMDAtb2ZmbGluZS1zcHJpdGUucG5nJ1xyXG5pbXBvcnQgQnV0dG9uUHJlc3MgZnJvbSAnLi9zb3VuZHMvYnV0dG9uLXByZXNzLm1wMydcclxuaW1wb3J0IEhpdCBmcm9tICcuL3NvdW5kcy9oaXQubXAzJ1xyXG5pbXBvcnQgU2NvcmVSZWFjaGVkIGZyb20gJy4vc291bmRzL3Njb3JlLXJlYWNoZWQubXAzJ1xyXG5cclxuaW1wb3J0ICcuL3NjcmlwdHMvanN0ZW1wbGF0ZV9jb21waWxlZCdcclxuaW1wb3J0ICcuL3NjcmlwdHMvaW50ZXJzdGl0aWFsX21vYmlsZV9uYXYnXHJcbmltcG9ydCAnLi9zY3JpcHRzL29mZmxpbmUnXHJcbmltcG9ydCAnLi9zY3JpcHRzL29mZmxpbmUtc3ByaXRlLWRlZmluaXRpb25zJ1xyXG5pbXBvcnQgJy4vc2NyaXB0cy9lcnJvcl9wYWdlX2NvbnRyb2xsZXJfaW9zJ1xyXG5cclxuaW1wb3J0IHsgcHJpbWFyeUNvbnRyb2xPbkxlZnQsIG9uRG9jdW1lbnRMb2FkT3JVcGRhdGUgfSBmcm9tICcuL3NjcmlwdHMvbmV0ZXJyb3InXHJcblxyXG5mdW5jdGlvbiBvbkRvY3VtZW50TG9hZCAoKSB7XHJcblxyXG4gIC8vIHNldCBzcHJpdGVzIGltZyBlbGVtZW50IHNyY1xyXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvZmZsaW5lLXJlc291cmNlcy0xeCcpLnNyYyA9IE9mZmxpbmVTcHJpdGUxMDBcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb2ZmbGluZS1yZXNvdXJjZXMtMngnKS5zcmMgPSBPZmZsaW5lU3ByaXRlMjAwXHJcblxyXG4gIC8vIHNldCBzb3VuZHMgYXVkaW8gZWxlbWVudCBzcmNcclxuICBjb25zdCByZXNvdXJjZVRlbXBsYXRlID1cclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdWRpby1yZXNvdXJjZXMnKS5jb250ZW50XHJcblxyXG4gIHJlc291cmNlVGVtcGxhdGUuZ2V0RWxlbWVudEJ5SWQoJ29mZmxpbmUtc291bmQtcHJlc3MnKS5zcmMgPSBCdXR0b25QcmVzc1xyXG4gIHJlc291cmNlVGVtcGxhdGUuZ2V0RWxlbWVudEJ5SWQoJ29mZmxpbmUtc291bmQtaGl0Jykuc3JjID0gSGl0XHJcbiAgcmVzb3VyY2VUZW1wbGF0ZS5nZXRFbGVtZW50QnlJZCgnb2ZmbGluZS1zb3VuZC1yZWFjaGVkJykuc3JjID0gU2NvcmVSZWFjaGVkXHJcblxyXG4gIC8vIFNldHMgdXAgdGhlIHByb3BlciBidXR0b24gbGF5b3V0IGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cclxuICBjb25zdCBidXR0b25zRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvbnMnKVxyXG4gIGlmIChwcmltYXJ5Q29udHJvbE9uTGVmdCkge1xyXG4gICAgYnV0dG9uc0Rpdi5jbGFzc0xpc3QuYWRkKCdzdWdnZXN0ZWQtbGVmdCcpXHJcbiAgfSBlbHNlIHtcclxuICAgIGJ1dHRvbnNEaXYuY2xhc3NMaXN0LmFkZCgnc3VnZ2VzdGVkLXJpZ2h0JylcclxuICB9XHJcblxyXG4gIG9uRG9jdW1lbnRMb2FkT3JVcGRhdGUoKVxyXG5cclxuICBjb25zdCB0cCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0JylcclxuICB3aW5kb3cuanN0UHJvY2VzcyhuZXcgd2luZG93LkpzRXZhbENvbnRleHQocGFnZURhdGEpLCB0cClcclxufVxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgb25Eb2N1bWVudExvYWQpXHJcblxyXG5jb25zb2xlLmxvZygnbG9hZCcpXHJcbiJdLCJuYW1lcyI6WyJPZmZsaW5lU3ByaXRlMTAwIiwiT2ZmbGluZVNwcml0ZTIwMCIsIkJ1dHRvblByZXNzIiwiSGl0IiwiU2NvcmVSZWFjaGVkIiwicHJpbWFyeUNvbnRyb2xPbkxlZnQiLCJvbkRvY3VtZW50TG9hZE9yVXBkYXRlIiwib25Eb2N1bWVudExvYWQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3JjIiwicmVzb3VyY2VUZW1wbGF0ZSIsImNvbnRlbnQiLCJidXR0b25zRGl2IiwiY2xhc3NMaXN0IiwiYWRkIiwidHAiLCJ3aW5kb3ciLCJqc3RQcm9jZXNzIiwiSnNFdmFsQ29udGV4dCIsInBhZ2VEYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9